<?xml version="1.0" encoding="UTF-8"?>
<!-- 
/* 
 *
 * Copyright  2012, 2013  Freescale Semiconductor
 *
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
*/

/*
 *
 * File name: gen_structure.xsl
 * Author: Freescale Semiconductor
 * Date:   03/13/2013
 * Description: 
 * 
 */
-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns:java_func="com.fsl.utils.XMLUtils" extension-element-prefixes="java_func">
<xsl:output method="text" indent="yes" />
  <xsl:template match="/">
      <xsl:variable name="moduleName" select="DataModel/@ModuleName"/>
      <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
      <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
        <xsl:if test="//DataModelNode/References">
          <xsl:call-template name="genRefs">
             <xsl:with-param name="smallcase" select="$smallcase" />
             <xsl:with-param name="uppercase" select="$uppercase" />
          </xsl:call-template>
        </xsl:if>
        <xsl:text>/*This C structure is automatically generated by UCM Automation Tool*/&#xa;</xsl:text>
      <xsl:text>#ifndef UCM</xsl:text>
      <xsl:value-of select="translate($moduleName, $smallcase, $uppercase)" />
      <xsl:text>_H&#xa;</xsl:text>
      <xsl:text>#define UCM</xsl:text>
      <xsl:value-of select="translate($moduleName, $smallcase, $uppercase)" />
      <xsl:text>_H&#xa;&#xa;</xsl:text>
    
    <xsl:text>#define CM_</xsl:text>
    <xsl:value-of select="translate($moduleName, $smallcase, $uppercase)" />
    <xsl:text>_CHILD_COUNT&#x20;</xsl:text>        
    <xsl:for-each select="DataModel">
       <xsl:value-of select="count(DataModelNode)" />
    </xsl:for-each>
    <xsl:text>&#xa;&#xa;</xsl:text>
        
    <xsl:text>struct cm_dm_data_element&#x20;</xsl:text>
    <xsl:value-of select="translate($moduleName, $uppercase, $smallcase)" /> 
    <xsl:text>DataElements[] = {</xsl:text>
    <xsl:for-each select="DataModel/DataModelNode">
      <xsl:text>&#xa;&#x20;{&#xa;&#x20;/* Reserved section */&#xa;&#x20;</xsl:text>
      <xsl:text>NULL,       /* Reserved : internal use */&#xa;&#x20;</xsl:text>
      <xsl:text>NULL,       /* Reserved : internal use */&#xa;&#x20;</xsl:text>
      <xsl:text>{{NULL,NULL},0},  /* Reserved : internal use */&#xa;&#x20;</xsl:text>
      <xsl:text>{NULL,NULL},     /* Reserved : internal use */&#xa;&#x20;</xsl:text>
      <xsl:text>{{NULL,NULL},0}, /* Reserved : internal use */&#xa;&#x20;&#xa;</xsl:text>
      <xsl:text> /* User section */&#xa;&#x20;"</xsl:text>
      <xsl:value-of select="Name" />
      <xsl:text>",  /* Element name. Not an FQN */&#xa;&#x20;</xsl:text>
      <xsl:choose>
      <xsl:when test="FriendlyName !=''">
      <xsl:text> &#x20;"</xsl:text>
      <xsl:value-of select="FriendlyName" />
      <xsl:text>",    /* Friendly name for command. */&#xa;&#x20;&#x20;&#x20;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
      <xsl:text>NULL</xsl:text>
      <xsl:text>,    /* Friendly name for command. */&#xa;&#x20;&#x20;&#x20;</xsl:text>
      </xsl:otherwise>
      </xsl:choose>
    <xsl:call-template name="gen_ID" /> 
      <xsl:text>,  /* Unique ID with in siblings */&#xa;&#x20;</xsl:text>
      <xsl:text>NULL,  /* Reference name array */&#xa;&#x20;</xsl:text>
      <xsl:text>NULL,  /* Function ptr to validate data */&#xa;&#x20;"</xsl:text>
      <xsl:value-of select="Description" />
      <xsl:text>",  /* Short description */&#xa;&#x20;</xsl:text>
                        <xsl:choose>
                          <xsl:when test="SaveDirName">
                             <xsl:value-of select="SaveDirName" />
                          </xsl:when>
                          <xsl:otherwise>
                             <xsl:text>NULL</xsl:text>
                          </xsl:otherwise>
                        </xsl:choose>
      <xsl:text>,  /* Directory name for save */&#xa;&#x20;</xsl:text>
                        <xsl:choose>
                           <xsl:when test="StorageFileName">
           <xsl:value-of select="StorageFileName" />
                           </xsl:when>
                           <xsl:otherwise>
                             <xsl:text>NULL</xsl:text>
                          </xsl:otherwise>
                        </xsl:choose>
      <xsl:text>,  /* If NULL, use parent's filename */&#xa;</xsl:text>
      <xsl:apply-templates select="NodeAttributes" />
      <xsl:text>&#xa;</xsl:text>
      <xsl:apply-templates select="DataAttributes" />
      <xsl:text>&#xa;&#x20;},&#xa;</xsl:text>
    </xsl:for-each>
    <xsl:text>&#xa;};&#xa;</xsl:text>
    <xsl:text>#endif&#xa;</xsl:text>
  </xsl:template>
<!-- 
 /*************************************************************************
 *  This template loops through all DataModelNode/References nodes and
 *  creates the reference Strings and Names arrays.
 *************************************************************************/ 
 -->
  <xsl:template name="genRefs">
    <xsl:param name="smallcase" select="'Not Available'" />
    <xsl:param name="uppercase" select="'Not Available'" />
        <xsl:for-each select="//DataModelNode/References">
          <xsl:variable name="list" select="Node[not(.=following::Node)]" /> 
          <xsl:if test="Node[not(.=following::Node)]">
           <xsl:variable name="refStr">
             <xsl:value-of select="translate(Node, $uppercase, $smallcase)" />
             <xsl:text>RefStrings</xsl:text>
           </xsl:variable>
           <xsl:text>/* REFSTR:</xsl:text>
              <xsl:value-of select="$refStr"/>
           <xsl:text>: */&#xa;</xsl:text>
           <xsl:text>T_CHAR8 *</xsl:text>
           <xsl:value-of select="$refStr"/><xsl:text>[] = {&#xa;</xsl:text>
           <xsl:for-each select="$list">
              <xsl:text>CM_DM_</xsl:text>
              <xsl:value-of select="translate(., $smallcase, $uppercase)" />
              <xsl:text>_PATH,&#x20;</xsl:text>
           </xsl:for-each>
          <xsl:text>&#xa;};&#xa;</xsl:text>    
        </xsl:if>
        </xsl:for-each>
        
        <xsl:text>&#xa;</xsl:text>
        
        <xsl:for-each select="//DataModelNode/References">
          <xsl:variable name="list" select="Node[not(.=following::Node)]" /> 
          <xsl:if test="Node[not(.=following::Node)]">
          <xsl:variable name="refNam">
             <xsl:value-of select="translate(Node, $uppercase, $smallcase)" />
             <xsl:text>RefNames</xsl:text>
           </xsl:variable>
           <xsl:text>/* REFNAME:</xsl:text>
              <xsl:value-of select="$refNam"/>
           <xsl:text>: */&#xa;</xsl:text>
        <xsl:text>UCMArrayOfStaticStrings_t &#x20;</xsl:text>
        <xsl:value-of select="$refNam" />
        <xsl:text> = {&#xa;</xsl:text>
        <xsl:for-each select="$list">         
           <xsl:value-of select="last()" />
        </xsl:for-each> 
          <xsl:text>,&#xa;</xsl:text>
          <xsl:value-of select="translate(Node, $uppercase, $smallcase)" />
          <xsl:text>RefStrings</xsl:text>
          <xsl:text>&#xa;};&#xa;</xsl:text>
        </xsl:if>    
      </xsl:for-each>
        <xsl:text disable-output-escaping="yes">|&#xa;</xsl:text>
   </xsl:template>
<!-- 
 /*************************************************************************
 *  This template loops through all NodeAttributes nodes and and prints  
 *  each element node value.                                    
 *************************************************************************/ 
 -->
   
  <xsl:template match="NodeAttributes">
    <xsl:for-each select=".">
          <xsl:text>&#x20;&#x20;{&#xa;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:value-of select="NodeType" />
          <xsl:text>,     /* anchor/table/struct/variable */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="Visible">
                                            <xsl:value-of select="Visible" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>TRUE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* should we expose for configuration? */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                  <xsl:choose>
                                          <xsl:when test="IsKey">
                                             <xsl:value-of select="IsKey" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Is this a key for the container? */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="Mandatory">
                                             <xsl:value-of select="Mandatory" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Is this a mandatory param? */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="OrderedTable">
                                            <xsl:value-of select="OrderedTable" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Is this an ordered list? (table) */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="PriorityNode">
                          <xsl:value-of select="PriorityNode" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                              <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Is this specifies priority of container table? */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="NotifyChange">
                                            <xsl:value-of select="NotifyChange" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Inform if any config change on this element */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="NotifyType">                                        
                                           <xsl:value-of select="NotifyType" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                           <xsl:text>CM_NOT_CHANGEABLE_BY_ACS</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,       /* 1 = ActiveNotify, 
                              2 = PassiveNotify, 
                              4 = Not changeable by ACS */
          </xsl:text>
          <xsl:text>&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="RebootOnChange">
                                            <xsl:value-of select="RebootOnChange" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* Reboot required if modified */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="StickyToParent">
                                             <xsl:value-of select="StickyToParent" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                             <xsl:text>FALSE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* This node config should go along with parent config */&#xa;&#x20;&#x20;&#x20;</xsl:text>
          <!--                          <xsl:choose>
                                          <xsl:when test="SaveInParentDir">
                                            <xsl:value-of select="SaveInParentDir" />
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <xsl:text>TRUE</xsl:text>
                                          </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /*   Save this element in parent instance's
                                 directory. For example, firewall is 
                                 saved in "vsg-1", etc. */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                           <xsl:when test="NonConfigLeafNode">
                                             <xsl:value-of select="NonConfigLeafNode" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                              <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* This is a non-configurable leaf node. Like structure members.*/&#xa;&#x20;&#x20;&#x20;</xsl:text>-->
                                        <xsl:choose>
                                           <xsl:when test="AccessControl">
                                              <xsl:value-of select="AccessControl" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                              <xsl:text>CM_ACCESS_ALL</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,      /* 0 = Allowed from ALL
                             1 = HTTP Can not Edit
                             2 = CLI Can not Edit */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                           <xsl:when test="GroupedScalar">
                                               <xsl:value-of select="GroupedScalar" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,      /*  set if the scalar is part of the scalar group.*/ &#xa;&#x20;&#x20;&#x20;</xsl:text>
                                       <xsl:choose>
                                           <xsl:when test="GlobalTrans">
                                              <xsl:value-of select="GlobalTrans" />
                                            </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>, /* Set if the Global transaction is applicable. */ &#xa;&#x20;&#x20;&#x20;</xsl:text>                                            
                                        <xsl:choose>
                                           <xsl:when test="UseParentTrans">
                                             <xsl:value-of select="UseParentTrans" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>, /* Set if this node should use the parent transaction to commit the configuration */ &#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                           <xsl:when test="IsSystemCommand">
                                             <xsl:value-of select="IsSystemCommand" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>, /* Is this a system command */ &#xa;&#x20;&#x20;&#x20;</xsl:text>

                                        <xsl:choose>
                                           <xsl:when test="IsStatsCommand">
                                             <xsl:value-of select="IsStatsCommand" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>, /* Is this a stats command */ &#xa;&#x20;&#x20;&#x20;</xsl:text>

                                        <xsl:choose>
                                           <xsl:when test="IsDeviceSpecific">
                                             <xsl:value-of select="IsDeviceSpecific" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                               <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>, /* Is this Device Specific command */ &#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:text>0, /* Unused bits. */ &#xa;&#x20;&#x20;&#x20;</xsl:text>                                            
                                    <xsl:choose>
                                      <xsl:when test="SaveInParentDir">
                                        <xsl:value-of select="SaveInParentDir" />
                                      </xsl:when>
                                      <xsl:otherwise>
                                        <xsl:text>TRUE</xsl:text>
                                      </xsl:otherwise>
                                    </xsl:choose>
          <xsl:text>,          /*   Save this element in parent instance's
                                 directory. For example, firewall is 
                                 saved in "vsg-1", etc. */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                           <xsl:when test="NonConfigLeafNode">
                                             <xsl:value-of select="NonConfigLeafNode" />
                                           </xsl:when>
                                           <xsl:otherwise>
                                              <xsl:text>FALSE</xsl:text>
                                           </xsl:otherwise>
                                        </xsl:choose>
          <xsl:text>,          /* This is a non-configurable leaf node. Like structure members.*/&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:text>0, /* Unused bits. */ &#xa;&#x20;&#x20;&#x20;</xsl:text>                                            
                                        <xsl:choose>
                                          <xsl:when test="CommandName">
                                            <xsl:text>"</xsl:text>
                                            <xsl:value-of select="CommandName" />
                                            <xsl:text>"</xsl:text>
                                          </xsl:when>
                           		  <xsl:otherwise>
                                            <xsl:text>NULL</xsl:text>
                		          </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>,	/*alias for table name */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="CliIdentifier">
                                            <xsl:text>"</xsl:text>
                                            <xsl:value-of select="CliIdentifier" />
                                            <xsl:text>"</xsl:text>
                                          </xsl:when>
                           		  <xsl:otherwise>
		                	      <xsl:text>NULL</xsl:text>
                		          </xsl:otherwise>  
                                        </xsl:choose> 
			<xsl:text>,	/* identifier for optional params */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                                        <xsl:choose>
                                          <xsl:when test="CliIdentifierHelp">
                                            <xsl:text>"</xsl:text>
                                            <xsl:value-of select="CliIdentifierHelp" />
                                            <xsl:text>"</xsl:text>
                                          </xsl:when>
                           		  <xsl:otherwise>
                                            <xsl:text>NULL</xsl:text>
                		          </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>,	/* Help for cli identifier */&#xa;&#x20;&#x20;&#x20;</xsl:text>
                     <xsl:text>&#xa;&#x20;&#x20;},</xsl:text>
    </xsl:for-each>
  </xsl:template>

<!-- 
 /*************************************************************************
 *  This template loops through all DataAttributes nodes and and prints  
 *  each element node value.                                    
 *************************************************************************/ 
 -->
   
  <xsl:template match="DataAttributes">
    <xsl:for-each select=".">
      <xsl:text>&#x20;&#x20;{</xsl:text>
            <xsl:text>&#xa;&#x20;&#x20;&#x20;</xsl:text>
            <xsl:value-of select="DataType" />
            <xsl:text>,            /* int/string/ip_addr/etc */</xsl:text>
            <xsl:text>&#xa;&#x20;&#x20;&#x20;</xsl:text>
            <xsl:value-of select="Type" />
            <xsl:text>,          /* range/enum/etc */</xsl:text>
            
            <xsl:apply-templates select="DataAttrib" />
            <xsl:text>&#x20;&#x20;&#xa;</xsl:text>
                <xsl:if test="not(DefaultValue)">
            <xsl:text>&#x20;&#x20;{}</xsl:text>
                        </xsl:if> 
            <xsl:apply-templates select="DefaultValue" />
            <xsl:text>&#xa;&#x20;&#x20;},</xsl:text>
    </xsl:for-each>
  </xsl:template>

<!-- 
 /*************************************************************************
 *  This template loops through all DataAttrib nodes and and prints  
 *  each element node value.                                    
 *************************************************************************/ 
 -->
   
  <xsl:template match="DataAttrib">
    <xsl:for-each select=".">
      <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;{</xsl:text>
      <xsl:variable name="type" select="../Type" />
      <xsl:variable name="dtType" select="../DataType" />
      <xsl:call-template name="validateElementsByType" >
         <xsl:with-param name="type" select="$type"/>
         <xsl:with-param name="dtType" select="$dtType"/>
      </xsl:call-template>
      <xsl:choose>
        <xsl:when test="$type = 'CM_DATA_ATTRIB_INT_RANGE'">
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>.int_range = {</xsl:text> 
                                 <xsl:choose>
                                   <xsl:when test="(iStartValue) and (iEndValue)">
                                     <xsl:value-of select="iStartValue" />
                                     <xsl:text>,</xsl:text>
                                     <xsl:value-of select="iEndValue" />
                                   </xsl:when>
                                   <xsl:when test="(StartValue) and (EndValue)">
                                     <xsl:value-of select="StartValue" />
                                     <xsl:text>,</xsl:text>
                                     <xsl:value-of select="EndValue" />
                                   </xsl:when>
                                   <xsl:otherwise>
                                     <xsl:variable name="msg">
                                       <xsl:text>Expected (iStartValue and iEndValue) or </xsl:text> 
                                       <xsl:text>(iStartValue and iEndValue) for the Node: </xsl:text>
                                       <xsl:value-of select="../../Name"/>
                                     </xsl:variable>
                                     <xsl:value-of select="java_func:throwError($msg)" />
                                   </xsl:otherwise>
                                 </xsl:choose>
          <xsl:text>}</xsl:text>
        </xsl:when>
        <xsl:when test="$type = 'CM_DATA_ATTRIB_UINT_RANGE'">
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>.uint_range= {</xsl:text> 
                                 <xsl:choose>
                                   <xsl:when test="(uIStartValue) and (uIEndValue)">
                                     <xsl:value-of select="uIStartValue" />
                                     <xsl:text>,</xsl:text>
                                     <xsl:value-of select="uIEndValue" />
                                   </xsl:when>
                                   <xsl:otherwise>
                                     <xsl:variable name="msg">
                                       <xsl:text>Expected (uIStartValue) and (uIEndValue) for the Node: </xsl:text>
                                       <xsl:value-of select="../../Name"/>
                                     </xsl:variable>
                                     <xsl:value-of select="java_func:throwError($msg)" />
                                   </xsl:otherwise>
                                   <!--xsl:text>}</xsl:text-->
                                 </xsl:choose>
          <xsl:text>}</xsl:text>
        </xsl:when>
        <xsl:when test="$type = 'CM_DATA_ATTRIB_STR_RANGE'">
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>.string_range = {</xsl:text> 
                                 <xsl:choose>
                                   <xsl:when test="(MinLength) and (MaxLength)">
                                     <xsl:value-of select="MinLength" />
                                     <xsl:text>,</xsl:text>
                                     <xsl:value-of select="MaxLength" />                                     
                                   </xsl:when>
                                   <xsl:otherwise>
                                     <xsl:variable name="msg">
                                       <xsl:text>Expected (MinLength) and (MaxLength) for the Node: </xsl:text>
                                       <xsl:value-of select="../../Name"/>
                                     </xsl:variable>
                                     <xsl:value-of select="java_func:throwError($msg)" />
                                   </xsl:otherwise>
                                 </xsl:choose>
          <xsl:text>}</xsl:text>
        </xsl:when>
        <xsl:when test="(($type = 'CM_DATA_ATTRIB_STR_ENUM' or 
                                  'CM_DATA_ATTRIB_STR_MULTVAL' or 'CM_DATA_ATTRIB_STR_MULTVAL_NOVALD') and (StrEnum))">
          <xsl:text>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;.string_enum = {</xsl:text>
          <xsl:value-of select= "count(StrEnum/Value)" /> 
          <xsl:text>,{</xsl:text>                    
          <xsl:apply-templates select="StrEnum" />
          <xsl:text>},{&#xa;</xsl:text>
            <xsl:call-template name="gen_friendlyNamesForEnum" />
          <xsl:text>}}</xsl:text>
        </xsl:when>
        <xsl:when test="($type = 'CM_DATA_ATTRIB_INT_ENUM') and (IntEnum)">
          <xsl:text>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;.int_enum = {</xsl:text>
          <xsl:value-of select= "count(IntEnum/Value)" /> 
          <xsl:text>,{</xsl:text>                    
          <xsl:apply-templates select="IntEnum">
            <xsl:with-param  name="dataType" select="$type"/> 
          </xsl:apply-templates>
          <xsl:text>},<!--{&#xa;</xsl:text>
            <xsl:call-template name="gen_friendlyNamesForEnum" />
          <xsl:text>}-->}</xsl:text>                    
        </xsl:when>
        <xsl:when test="($type = 'CM_DATA_ATTRIB_UINT_ENUM') and (IntEnum)">
          <xsl:text>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;.uint_enum= {</xsl:text>
          <xsl:value-of select= "count(IntEnum/Value)" /> 
          <xsl:text>,{</xsl:text>                    
          <xsl:apply-templates select="IntEnum">
            <xsl:with-param  name="dataType" select="$type"/> 
          </xsl:apply-templates>
          <xsl:text>},<!--{&#xa;</xsl:text>
            <xsl:call-template name="gen_friendlyNamesForEnum" />
          <xsl:text>}-->}</xsl:text>                    
        </xsl:when>
                <xsl:otherwise>
          <!--<xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>{},</xsl:text>-->
                </xsl:otherwise>
      </xsl:choose>
      <xsl:if test ="MaxTableRows != ''">
          <xsl:text>.uiMaxTableRows=</xsl:text> 
          <xsl:value-of select= "MaxTableRows" /> 
      </xsl:if>
      <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;},</xsl:text>
    </xsl:for-each>
  </xsl:template>
<!--
 /*************************************************************************
 *  This template validates the range elements with respect to the datatype.
 *************************************************************************/ 
-->
  <xsl:template name="validateElementsByType">
    <xsl:param name="type" select="'Not Available'" />
    <xsl:param name="dtType" select="'Not Available'" />

    <xsl:variable name="attribErr">
      <xsl:text>Invalid Attrib Range Type. Use </xsl:text>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$dtType='CM_DATA_TYPE_STRING'">
        <xsl:if test="$type != 'CM_DATA_ATTRIB_STR_RANGE' and $type != 'CM_DATA_ATTRIB_STR_ENUM' and $type != 'CM_DATA_ATTRIB_STR_LARGE_ENUM' and $type !='CM_DATA_ATTRIB_NONE'">
        <xsl:variable name="msg">
          <xsl:value-of select="$attribErr" />
          <xsl:text>CM_DATA_ATTRIB_STR_RANGE for the Node: </xsl:text>
          <xsl:value-of select="../../Name" />
        </xsl:variable>
        <xsl:value-of select="java_func:throwError($msg)" />
      </xsl:if>
      </xsl:when>
      <xsl:when test="$dtType='CM_DATA_TYPE_INT'and $type != 'CM_DATA_ATTRIB_INT_ENUM' and $type !='CM_DATA_ATTRIB_NONE'">
        <xsl:if test="$type != 'CM_DATA_ATTRIB_INT_RANGE'">
          <xsl:variable name="msg">
            <xsl:value-of select="$attribErr" />
            <xsl:text>CM_DATA_ATTRIB_INT_RANGE for the Node: </xsl:text>
            <xsl:value-of select="../../Name" />
          </xsl:variable>
          <xsl:value-of select="java_func:throwError($msg)" />
        </xsl:if>
        
      </xsl:when>
      <xsl:when test="$dtType='CM_DATA_TYPE_UINT' and $type != 'CM_DATA_ATTRIB_UINT_ENUM' and $type !='CM_DATA_ATTRIB_NONE'">
        <xsl:if test="$type != 'CM_DATA_ATTRIB_UINT_RANGE'">
          <!--<xsl:value-of select="java_func:throwError('Invalid Attrib Range Type. Use CM_DATA_ATTRIB_UINT_RANGE')"/>
        -->
          <xsl:variable name="msg">
            <xsl:value-of select="$attribErr" />
            <xsl:text>CM_DATA_ATTRIB_UINT_RANGE for the Node: </xsl:text>
            <xsl:value-of select="../../Name" />
          </xsl:variable>
          <xsl:value-of select="java_func:throwError($msg)" />
        </xsl:if>
      </xsl:when>
      <xsl:when test="$dtType='CM_DATA_TYPE_INT64'and $type != 'CM_DATA_ATTRIB_INT64_ENUM' and $type !='CM_DATA_ATTRIB_NONE'">
        <xsl:if test="$type != 'CM_DATA_ATTRIB_INT64_RANGE'">
          <xsl:variable name="msg">
            <xsl:value-of select="$attribErr" />
            <xsl:text>CM_DATA_ATTRIB_INT64_RANGE for the Node: </xsl:text>
            <xsl:value-of select="../../Name" />
          </xsl:variable>
          <xsl:value-of select="java_func:throwError($msg)" />
        </xsl:if>
        
      </xsl:when>
      <xsl:when test="$dtType='CM_DATA_TYPE_UINT64' and $type != 'CM_DATA_ATTRIB_UINT64_ENUM' and $type !='CM_DATA_ATTRIB_NONE'">
        <xsl:if test="$type != 'CM_DATA_ATTRIB_UINT64_RANGE'">
          <!--<xsl:value-of select="java_func:throwError('Invalid Attrib Range Type. Use CM_DATA_ATTRIB_UINT_RANGE')"/>
        -->
          <xsl:variable name="msg">
            <xsl:value-of select="$attribErr" />
            <xsl:text>CM_DATA_ATTRIB_UINT64_RANGE for the Node: </xsl:text>
            <xsl:value-of select="../../Name" />
          </xsl:variable>
          <xsl:value-of select="java_func:throwError($msg)" />
        </xsl:if>
      </xsl:when>
    </xsl:choose>
  </xsl:template>  
<!--
 /*************************************************************************
 *  This template loops through all DefaultValue nodes and and prints  
 *  each element node value.                                    
 *************************************************************************/ 
-->
   
  <xsl:template match="DefaultValue">
    <xsl:for-each select=".">
      <xsl:text>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;{</xsl:text>
      <xsl:choose>
        <xsl:when test="(string-length(DefaultIntValue) &gt; 0)">
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
            <xsl:text>.idefault_value = </xsl:text>
          <xsl:value-of select="DefaultIntValue" />
          <xsl:text>,</xsl:text>          
        </xsl:when>
        <xsl:when test="(string-length(DefaultString) &gt; 0)">
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>.default_string = </xsl:text>
          <xsl:text>"</xsl:text>
          <xsl:value-of select="DefaultString" />
          <xsl:text>",</xsl:text>
        </xsl:when>
        <xsl:when test="(string-length(DefaultString) = 0)">
            <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
            <xsl:text>.default_string = "",</xsl:text>
        </xsl:when>
                <xsl:otherwise>
          <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</xsl:text>
          <xsl:text>NULL,</xsl:text>
                </xsl:otherwise>
      </xsl:choose>
      <xsl:text>&#xa;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;},</xsl:text>
    </xsl:for-each>
  </xsl:template>

<!-- 
 /*************************************************************************
 *  This template will prints all enum values in the xml file.                          
 *************************************************************************/ 
 -->
   
  <xsl:template match="//StrEnum/Value">
    <!--<xsl:text>.aStrEnum.aStringArr[</xsl:text>
    <xsl:value-of select="(position() div 2) - 1"/>
    <xsl:text>] = </xsl:text>-->
    <xsl:text>"</xsl:text>  
        <xsl:copy>
            <xsl:apply-templates/>
        </xsl:copy>
    <xsl:text>",</xsl:text>  
  </xsl:template>
<!-- 
 /***************************************************************************
 *  This template will prints all enum values along with the friendly names.                          
 ****************************************************************************/ 
 -->
   
  <xsl:template name="gen_friendlyNamesForEnum">
    <xsl:for-each select="StrEnum/Value">
      <xsl:text>&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;"</xsl:text>
      <xsl:choose>
        <xsl:when test="@friendlyName">
          <xsl:value-of select="@friendlyName"/>
        </xsl:when>
        <xsl:otherwise> 
        <!--  <xsl:value-of select=""/> -->
         <xsl:text></xsl:text>
        </xsl:otherwise> 
      </xsl:choose>
     <xsl:text>",&#xa;</xsl:text>
    </xsl:for-each>
  </xsl:template>
<!-- 
 /*************************************************************************
 *  This template will prints all enum values in the xml file.                          
 *************************************************************************/ 
 -->
   
  <xsl:template match="//IntEnum/Value">
    <xsl:param  name="dataType"/>  
    <xsl:choose>
      <xsl:when test="($dataType = 'CM_DATA_ATTRIB_INT_ENUM') ">
      <!--<xsl:text>.aIntEnum.aIntArr[</xsl:text>
      <xsl:value-of select="(position() div 2) - 1"/>
      <xsl:text>] = </xsl:text>-->
          <xsl:copy>
              <xsl:apply-templates/>
          </xsl:copy>
      <xsl:text>,</xsl:text>
      </xsl:when> 
    <xsl:otherwise>
      <!--<xsl:text>.aUintEnum.aUintArr</xsl:text>
      <xsl:value-of select="(position() div 2) - 1"/>
      <xsl:text>] = </xsl:text>-->
          <xsl:copy>
              <xsl:apply-templates/>
          </xsl:copy>
      <xsl:text>,</xsl:text>
    </xsl:otherwise>
    </xsl:choose>   
  </xsl:template>

<!-- 
 /*************************************************************************
 *  This template will take the module name (i.e. vsg,firewall), name of the 
 *  node(i.e. vsg name) and convert it to uppercase to generate the ID.      
 *************************************************************************/ 
-->   
  <xsl:template name="gen_ID" >
     <xsl:variable name="modName">
     <xsl:value-of select="/DataModel/@ModuleName" />
      </xsl:variable>
     <xsl:text>CM_DM_</xsl:text>
     <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
     <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
     <xsl:value-of select="translate($modName, $smallcase, $uppercase)" />  
     <xsl:text>_</xsl:text>
     <xsl:variable name="name">
      <xsl:value-of select="Name"/>
     </xsl:variable>
     <xsl:value-of select="translate($name, $smallcase, $uppercase)" />
     <xsl:text>_ID</xsl:text>
  </xsl:template>
  
</xsl:stylesheet>
