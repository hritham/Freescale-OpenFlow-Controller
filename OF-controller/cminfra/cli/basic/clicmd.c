/* 
 *
 * Copyright  2012, 2013  Freescale Semiconductor
 *
 *
 * Licensed under the Apache License, version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
*/

/*
 *
 * File name:  clicmd.c
 * Author: Freescale Semiconductor    
 * Date:   01/20/2013
 * Description: Contains CLI commands to add, modify, delete records with the 
 *              other supported commands like show, showall, cancel, done, compare, 
 *              revoke, commit and etc command APIs.
*/

#ifdef CM_CLIENG_SUPPORT
#include "cliincld.h"
#include "ldsvgif.h"
/****************************************************************************
 * Global Variable Declarations :
 ****************************************************************************/
extern struct cm_cli_session *cli_session_p;
#define MAX_A_BUFF_SIZE 512
char buff_a[CM_CLI_MAX_PROMPT_LEN];
#define CM_CLI_SHOW_NEWLINE_DELIMITER "\n\t"
#define CM_CLI_SHOW_RECORD_DELIMITER	"\n\t"  //Modify this to modify the display as required
#define CM_CLI_SHOW_TAB_START_DELIMITER "\n\t{"
#define CM_CLI_SHOW_TAB_END_DELIMITER	"\n\t}"
//#define CM_CLI_FRND_NAME   //Enable this flag to display friendly names on SHOW command
#define CM_CLI_READ_ARRAY_LENGTH 4096
#define PKI_MAX_CERT_SIZE         10240  /* 10K */
#define PKI_DEFAULT_1024_LENGTH   1024
#define PKI_GETS_BUFFER_LEN     100
#define MAX_CERT_BUFF 4096
#define CM_CLI_STDIN stdin
#define CM_MAX_DISP_LINES 3
#define CM_REC_DISP_IN_EACH_PAGE 10
/****************************************************************************
 * Local Function Declarations :
 ****************************************************************************/
 int32_t cm_cli_display_records_of_scalar (char * dm_path_p, 
                                           struct cm_cli_params *params_p,
                                               unsigned char identifier_b,
                                               char *param_name_p,
                                              unsigned char parent_table_b,
                              struct cm_array_of_nv_pair *nv_pairs_array_p );

 int32_t cm_cli_display_records_of_table (char * dm_path_p,
                              struct cm_array_of_nv_pair *keys_array_p,
                                                unsigned char exact_b);

 void cm_cli_display_nv_pair_array (struct cm_array_of_nv_pair * nv_pair_array_p,
                                           uint32_t count_ui,char * dm_path_p);
 int32_t cm_cli_get_keys_array(char *dm_path_p,  
                    struct cm_array_of_nv_pair *keys_array_p, 
                    char *param_val_p);

 int32_t cm_cli_display_param_value (char * param_name_p);

 int32_t cm_cli_get_prev_record_key (struct cm_array_of_nv_pair * out_nv_pair_array_p,
                                        struct cm_nv_pair * prev_rec_key_p,
                                        char * dm_path_p);

 int32_t cm_cli_get_prev_record_key_array (struct cm_array_of_nv_pair * out_nv_pair_array_p,
                                        struct cm_array_of_nv_pair * prev_rec_key_p,
                                        char * dm_path_p,
                                        unsigned char mand_b);

 int32_t cm_cli_end_config_session (void * config_session_p, uint32_t
op_code_ui);

 void cm_cli_display_role_permissions_info(struct cm_dm_array_of_role_permissions *role_perm_array_p);

 void cm_cli_get_permission_string(uint32_t perm_ui, char* perm_p);

 int32_t cm_cli_display_role_settings_by_role(char* role_p);

 int32_t cm_cli_display_all_role_settings(void);

 void cm_cli_display_role_info(struct cm_dm_role_permission *role_perm_p);
int32_t cm_cli_frame_and_send_set_scalar_params_to_je (struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui);
 void  cm_sort_command_display(char (*tmp_sort_buff)[MAX_A_BUFF_SIZE],int tmp_cnt_i);
int32_t cm_cli_context_help (void); 
int32_t cm_cli_display_record_with_arguments(char *dm_path_p, struct cm_cli_params * params_p, uint32_t param_cnt_ui, unsigned char is_table_b);
int32_t cm_cli_system_command (struct cm_cli_params * params_p,
                                    int32_t param_cnt_i);
int32_t cm_cli_get_nv_pairs_from_command(char *dm_path_p, struct cm_cli_params  *params_p,
                      int32_t param_cnt_i,struct cm_array_of_nv_pair *nv_pair_array_p,unsigned char mand_req_b);

int32_t cm_cli_display_table_help (void * tnsprt_channel_p,
                                   char * dm_path_p,
                                   uint32_t mgmt_engine_id,
                                   struct cm_role_info *role_info_p,
           unsigned char is_vsg_table_b);

int32_t cm_cli_display_scalar_param_value (char * dm_path_p, char *param_name_p,
      struct cm_array_of_nv_pair *keys_array_p);
int32_t cm_cli_get_mandatory_param_name(uint32_t pos_ui, char **out_name_p,uint8_t *data_type_ui);
int32_t cm_cli_display_child_node_info(void);
int32_t cm_cli_copy_node_info_into_array (struct cm_dm_node_info * node_info_p,
                                                struct cm_dm_node_info * node_info_array_p,
                                                uint32_t index_ui);
int32_t cm_cli_get_parent_path(char *dm_path_p, char *parent_path_p);
/****************************************************************************
 * Local Variable Declarations :
 ****************************************************************************/
/* Parameter declaration for LS command */
struct cm_cli_params_def cm_cli_ls_cmd_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_DIR_LENGTH, CM_CLI_OPTIONAL}
};

#define UCMCLI_LSCMD_PARAM_COUNT  \
                     (sizeof(cm_cli_ls_cmd_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for CD command */
struct cm_cli_params_def cm_cli_cd_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_DIR_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_DIR_LENGTH, CM_CLI_OPTIONAL}
};

#define UCMCLI_CDCMD_PARAM_COUNT  \
                     (sizeof(cm_cli_cd_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for NO command */
struct cm_cli_params_def cm_cli_no_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY}
};

#define UCMCLI_NOCMD_PARAMCNT \
                (sizeof(cm_cli_no_params) / sizeof(struct cm_cli_params_def))

/* Parameter declaration for COMPARE command */
struct cm_cli_params_def cm_cli_compare_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY}
};

#define UCMCLI_COMPARECMD_PARAMCNT \
             (sizeof(cm_cli_compare_params)/ sizeof(struct cm_cli_params_def))
/* Parameter declaration for COMPARE command */
struct cm_cli_params_def cm_cli_read_params[] = {
  {CM_CLI_ARRAY, CM_CLI_READ_ARRAY_LENGTH, CM_CLI_MANDATORY}
};

#define UCMCLI_COMPAREREAD_PARAMCNT \
             (sizeof(cm_cli_read_params)/ sizeof(struct cm_cli_params_def))



/* Parameter declaration for SHOW command */
struct cm_cli_params_def cm_cli_show_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},

};

#define UCMCLI_SHOWCMD_PARAMCNT \
             (sizeof(cm_cli_show_params)/ sizeof(struct cm_cli_params_def))

#ifdef CM_STATS_COLLECTOR_SUPPORT

struct cm_cli_params_def cm_cli_show_dev_stats_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
};
#define UCMCLI_SHOWDEVSTATS_PARAMCNT \
             (sizeof(cm_cli_show_dev_stats_params)/sizeof(struct cm_cli_params_def))

#endif

/* Parameter declaration for DELETE command */
struct cm_cli_params_def cm_cli_del_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY}
};

#define UCMCLI_DELCMD_PARAMCNT \
             (sizeof(cm_cli_del_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for SET command */
struct cm_cli_params_def cm_cli_set_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL}
};

#define UCMCLI_SETCMD_PARAMCNT \
             (sizeof(cm_cli_set_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for SET DEFAULT PARAM command */
struct cm_cli_params_def cm_cli_set_default_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY},
};

#define UCMCLI_SETDEFCMD_PARAMCNT \
             (sizeof(cm_cli_set_default_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for SET Role 'n' Permissions command */
struct cm_cli_params_def cm_cli_set_role_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY},
  {CM_CLI_INT, sizeof(uint32_t), CM_CLI_MANDATORY},
};
#define UCMCLI_SETROLECMD_PARAMCNT\
             (sizeof(cm_cli_set_role_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for GET Role 'n' Permissions command */
struct cm_cli_params_def cm_cli_get_role_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
};
#define UCMCLI_GETROLECMD_PARAMCNT\
             (sizeof(cm_cli_get_role_params)/ sizeof(struct cm_cli_params_def))

struct cm_cli_params_def cm_cli_set_cert_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_OPTIONAL},
};
#define UCMCLI_SETCERTCMD_PARAMCNT\
             (sizeof(cm_cli_set_cert_params)/ sizeof(struct cm_cli_params_def))

/* Parameter declaration for DEL Role 'n' Permissions command */
struct cm_cli_params_def cm_cli_del_role_params[] = {
  {CM_CLI_ARRAY, CM_CLI_DEFAULT_ARRAY_LENGTH, CM_CLI_MANDATORY},
};
#define UCMCLI_DELROLECMD_PARAMCNT\
             (sizeof(cm_cli_del_role_params)/ sizeof(struct cm_cli_params_def))


struct cm_cli_cmd cm_cli_default_cmd_list[CM_CLI_MAX_CMD] = {
  {"ls", " Usage: ls \n\r Displays available parameter names.\n\r", FALSE,
   UCMCLI_LSCMD_PARAM_COUNT, cm_cli_ls_cmd_params,
   (UCMCLIFUNPTR) cm_cli_display_child_node_names},
  {"help", " Usage: help \n\r Displays available commands.\n\r", FALSE,
   UCMCLI_LSCMD_PARAM_COUNT, cm_cli_ls_cmd_params,
   (UCMCLIFUNPTR) cm_cli_display_commands},
  {"?", " Usage: ? \n\r Displays available commands.\n\r", FALSE,
   UCMCLI_LSCMD_PARAM_COUNT, cm_cli_ls_cmd_params,
   (UCMCLIFUNPTR) cm_cli_display_commands},
  {"cd", " Usage: cd [directory name] \n\r Changes the directory.\n\r ",
   FALSE, UCMCLI_CDCMD_PARAM_COUNT, cm_cli_cd_params,
   (UCMCLIFUNPTR) cm_cli_change_directory},
  {"..", " Usage: .. \n\r Moves to parent directory. \n\r", FALSE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_move_to_prev_directory},
  {"show", " Usage: show                        Displays available records.\n\r\
   \tshow [name]                 Displays the value of the entered variable name.\n\r\
   \tshow [table_name]           Displays the records of the table.\n\r\
   \tshow [table_name] [recname] Displays the record in detail.\n\r",
   FALSE,
   UCMCLI_SHOWCMD_PARAMCNT, cm_cli_show_params,
   (UCMCLIFUNPTR) cm_cli_display_records},

#ifdef CM_STATS_COLLECTOR_SUPPORT
  {"showstats", " Usage: showstats [aggr/avg/perdev] [StatsAppl] \n\r\
    \tDefault is aggregate stats. \n\r\
    \tWhen StatsAppl is not entered, current directory is treated as Stats Application.\n\r",
    FALSE,UCMCLI_SHOWDEVSTATS_PARAMCNT,
    cm_cli_show_dev_stats_params,
    (UCMCLIFUNPTR)cm_cli_display_statistics},
#endif
  {"showall", " Usage: showall\n\r Displays all the available records from\
 this path including child nodes. \n\r", FALSE, 0, NULL, (UCMCLIFUNPTR) cm_cli_display_all_tables},
  {"del",
   " Usage: del <Table_name> <RecID> \n\r Deletes the record from the table.\n\r",
   TRUE, UCMCLI_DELCMD_PARAMCNT, cm_cli_del_params,
   (UCMCLIFUNPTR) cm_cli_delete_record},
  {"factreset", " Usage: factreset\n\r Resets to the factory default configuration.\n\r", FALSE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_set_factory_defaults},
  /* {"flush", " Usage: flush\n\r Deletes the Configuration.\n\r", FALSE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_flush_command},*/
  {"save", " Usage: save\n\r Saves the Configuration.\n\r", FALSE, 0,
   NULL,
   (UCMCLIFUNPTR) cm_cli_save_config},
  {"show_session", "Usage: show_session\n\r Displays all uncommitted commands\
  present in the UCM JE Config session. \n\r ", TRUE, 0, NULL,
   (UCMCLIFUNPTR) cm_cli_display_session},
  {"setdefault", "Usage: setdefault <parameter name> \n\r Sets the parameter\
  to its default value.\n\r", TRUE, UCMCLI_SETDEFCMD_PARAMCNT,
   cm_cli_set_default_params, (UCMCLIFUNPTR) cm_cli_set_default_parameters},
  {"commit", " Usage: commit\n\rCommit all the commands entered.\n\r", TRUE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_commit_config_session},
  {"revoke", " Usage: revoke\n\rRevoke all the commands entered. \n\r",
   TRUE, 0, NULL, (UCMCLIFUNPTR) cm_cli_revoke_config_session},
  {"no",
   "Usage: no <commandname>\n\r Cancels previously entered command. \n\r ",
   TRUE, UCMCLI_NOCMD_PARAMCNT, cm_cli_no_params,
   (UCMCLIFUNPTR) cm_cli_cancel_prev_command},
  {"compare", "Usage: compare <variable name>\n\r Show the value entered\
    previously by user, that is residing in config session, with the actual \
    value residing at application.\n\r ", TRUE, UCMCLI_COMPARECMD_PARAMCNT,
   cm_cli_compare_params, (UCMCLIFUNPTR) cm_cli_compare},
  {"set",
   " Usage: set [param_name1][param_value1]...  [param_name10][param_value10]\n\r"
   " sets the Parameter value to parameter.\n\r", TRUE, UCMCLI_SETCMD_PARAMCNT,
   cm_cli_set_params, (UCMCLIFUNPTR) cm_cli_frame_and_send_set_params_to_je},
  {"cancel", " Usage: cancel\n\r cleans the command when in a transaction.\n\r", TRUE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_cancel_command},
  {"done", " Usage: done\n\r Executes the command in the transaction immediately.\n\r", TRUE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_done_command},
  {"version", " Usage: version\n\r Gets version information.\n\r", FALSE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_get_versions},
#ifdef CONFIGSYNC_SUPPORT
  {"reboot", " Usage: reboot\n\r Reboots the device.\n\r", FALSE,
   0, NULL, (UCMCLIFUNPTR) cm_cli_reboot_device},
#endif
#ifdef CM_ROLES_PERM_SUPPORT
  {"setrole",
   "Usage: setrole <rolename> <permission>\n\r"\
   " Sets Role (string) and Permission "
   " 0 - CM_PERMISSION_NOACCESS,\n\r"
   " 1 - CM_PERMISSION_READ_ONLY,\n\r"
   " 2 - CM_PERMISSION_READ_WRITE,\n\r"
        " 3 -CM_PERMISSION_READ_ROLEPERM,\n\r"
 " 4- CM_PERMISSION_READ_WRITE_ROLEPERM,\n\r",
   FALSE, UCMCLI_SETROLECMD_PARAMCNT, cm_cli_set_role_params,
   (UCMCLIFUNPTR) cm_cli_set_role_and_permissions},
  {"getrole",
   " Usage: getrole\n\r"
   " Gets the Role and Permissions information for the DMPath.\n\r",
   FALSE, UCMCLI_GETROLECMD_PARAMCNT, cm_cli_get_role_params, 
   (UCMCLIFUNPTR) cm_cli_get_role_and_permissions},
  {"delrole",
   " Usage: delrole <rolename>\n\r"
   " Deletes the Role and Permissions information for the DMPath.\n\r",
   FALSE, UCMCLI_DELROLECMD_PARAMCNT, cm_cli_del_role_params, 
   (UCMCLIFUNPTR) cm_cli_delete_role_and_permissions},

#endif /* CM_ROLES_PERM_SUPPORT*/
  {"setcert", " Usage: setcert\n\r Reads the entered certificate buffer from command prompt.\n\r", FALSE,
   UCMCLI_SETCERTCMD_PARAMCNT, cm_cli_set_cert_params, (UCMCLIFUNPTR) cm_cli_set_certificate_command}
};

/***************************************************************************
 * Function Name : cm_cli_display_commands
 * Description   : This callback API is used to list out all the commands.
 * Input         : cli_session_p - Cli session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_commands (struct cm_cli_session * cli_session_p,
                               struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   int32_t i,index_i;
   struct cm_cli_data_ele_node *data_ele_node_p;
   UCMDllQNode_t *dll_q_node_p;
   unsigned char found_b = FALSE,scalar_var_b = FALSE;
   struct cm_dm_node_info *node_info_p=NULL, *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];

   if (!cli_session_p)
   {
      printf ("Invalid input\n\r");
      return OF_FAILURE;
   }

   if(param_cnt_ui == 0) // only 'help' command is entered
   {
      /* List all standard CLI commands */
      for (i = 0; i < CM_CLI_MAX_CMD; i++)
      {
         if (!(param_cnt_ui) || (param_cnt_ui && (!of_strcmp ((char *) params_p[0].param_value,cm_cli_default_cmd_list[i].command_name_c))))
         {
            if ((cm_cli_default_cmd_list[i].session_b == FALSE) ||
                  ((cli_session_p->context_b) && (cm_cli_default_cmd_list[i].session_b == TRUE)))
            {
               sprintf (buff_a, " Command Name: %s\n", cm_cli_default_cmd_list[i].command_name_c);
               cm_cli_puts (cli_session_p, buff_a);
               sprintf (buff_a, "%s\n", cm_cli_default_cmd_list[i].description_p);
               cm_cli_puts (cli_session_p, buff_a);
            }
         }
      }

      cm_cli_puts (cli_session_p, "\n\r");
      sprintf (buff_a,
            "\t* Use Tab key to list commands and to auto-complete the command.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      sprintf (buff_a,
            "\t* Use \'help\' or \'?\' to display standard CLI commands.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      sprintf (buff_a,
            "\t* Use \'ls\' to display child node information of the current directory.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      sprintf (buff_a, "\t* Use [table-name] [record-name] to add a record to the table.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      sprintf (buff_a, "\t* Use \'logout\' to exit from the CLI.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
   }
   else if(param_cnt_ui == 1) // 'help paramname'
   {
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,struct cm_cli_data_ele_node *, list_node);

         if (of_strcmp ((char *) params_p[0].param_value,data_ele_node_p->node_name) == 0)
         {
            if(!data_ele_node_p->mandatory_b && data_ele_node_p->cli_identifier_p)
               sprintf (buff_a, "%s :: %s :: %s",data_ele_node_p->node_name,data_ele_node_p->cli_identifier_p, data_ele_node_p->description_p);
            else
               sprintf (buff_a, "%s :: %s",data_ele_node_p->node_name,data_ele_node_p->description_p);
            cm_cli_puts(cli_session_p,"\n\r");    
            cm_cli_puts(cli_session_p,buff_a);    
            cm_cli_puts(cli_session_p,"\r\n");    
            found_b = TRUE;
            break;
         }
      }
      if(found_b == FALSE)
      {
         CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p,UCMDllQNode_t *)
         {
            data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,struct cm_cli_data_ele_node *, list_node);

            if (of_strcmp ((char *) params_p[0].param_value,data_ele_node_p->node_name) == 0)
            {
               sprintf (buff_a, "%s :: %s",data_ele_node_p->node_name,data_ele_node_p->description_p);
               cm_cli_puts(cli_session_p,"\n\r");    
               cm_cli_puts(cli_session_p,buff_a);    
               cm_cli_puts(cli_session_p,"\r\n");    
               found_b = TRUE;

               if(data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE || 
                     (data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR))
               {
                  of_memset(dmpath_a,0,sizeof(dmpath_a));
                  of_strcpy(dmpath_a,cli_session_p->dmpath_a);
                  of_strcat(dmpath_a,".");
                  of_strcat(dmpath_a,data_ele_node_p->node_name);

                  if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
                           dmpath_a,
                           CM_CLI_MGMT_ENGINE_ID,
                           &cli_session_p->role_info,
                           &node_info_p, &child_info_arr_p) != OF_SUCCESS)
                  {
#ifdef CM_CLI_DEBUG 
                     sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
                     cm_cli_puts (cli_session_p, buff_a);
#endif
                     return OF_FAILURE;
                  }

                  for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
                  {
                     tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
                     if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR)
                     {
                        scalar_var_b = TRUE;
                        break;
                     }
                  }

                  if(scalar_var_b != TRUE)
                  {
                     cm_cli_free_node_info(node_info_p);
                     cm_cli_cleanup_array_of_node_info(child_info_arr_p);
                     break;
                  }

                  if(data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
                  {
                     sprintf (buff_a," Following parameters are used for the \'%s\' command.",
                           data_ele_node_p->node_name);
                  }
                  else 
                  {
                     sprintf (buff_a," Following parameters are under the \'%s\' command.",
                           data_ele_node_p->node_name);
                  }
                  cm_cli_puts(cli_session_p,"\n\r\t");
                  cm_cli_puts(cli_session_p,buff_a);
                  cm_cli_puts(cli_session_p,"\r\n");

                  for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
                  {
                     tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
                     if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR)
                     {
                        sprintf (buff_a, "%-32s :: %s",tmp_node_info_p->name_p,tmp_node_info_p->description_p);
                        cm_cli_puts(cli_session_p,"\n\r\t");
                        cm_cli_puts(cli_session_p,buff_a);
                     }
                  }

                  if(node_info_p->element_attrib.global_trans_b == TRUE)
                  {
                     sprintf (buff_a, " Note: %s is transaction based, need to configure internal commands accordingly.",node_info_p->name_p);
                     cm_cli_puts(cli_session_p,"\n\n\r");
                     cm_cli_puts(cli_session_p,buff_a);
                  }
                  cm_cli_puts(cli_session_p,"\r\n");
                  cm_cli_free_node_info(node_info_p);
                  cm_cli_cleanup_array_of_node_info(child_info_arr_p);
               }
               break;
            }
         }
      }

      if(found_b == FALSE)
      {
         for (i = 0; i < CM_CLI_MAX_CMD; i++)
         {
            if (of_strcmp ((char *) params_p[0].param_value,cm_cli_default_cmd_list[i].command_name_c) == 0)
            {
               sprintf (buff_a, " Command Name: %s\n ", cm_cli_default_cmd_list[i].command_name_c);
               cm_cli_puts (cli_session_p, buff_a);
               sprintf (buff_a, "%s\n", cm_cli_default_cmd_list[i].description_p);
               cm_cli_puts (cli_session_p, buff_a);
               found_b = TRUE;
               break;
            }
         }
      }
      if(found_b == FALSE)
      {
         sprintf (buff_a, " Invalid parameter entered.");
         cm_cli_puts(cli_session_p,buff_a);
      }

   }

   cm_cli_puts(cli_session_p,"\n\r");    
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_child_node_names
 * Description   : This callback API is used to list out all ChildNode names.
 * Input         : cli_session_p - Cli session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_child_node_names (struct cm_cli_session * cli_session_p,
                                     struct cm_cli_params * params_p,
                                     uint32_t param_cnt_ui)
{
   struct cm_cli_data_ele_node *data_ele_node_p;
   UCMDllQNode_t *dll_q_node_p;

   int32_t tmp_cnt_i=0,tmp_i=0,tmp_attrib_cnt_i=0, tmp_mand_cnt_i = 0; 
   char tmp_opt_buff[MAX_A_BUFF_SIZE][MAX_A_BUFF_SIZE];
   char tmp_mand_buff[64][MAX_A_BUFF_SIZE];
   char tmp_str[MAX_A_BUFF_SIZE][MAX_A_BUFF_SIZE];
   unsigned char check_back_list_b = FALSE, config_b  = FALSE;
   char tmp_buff_a[CM_CLI_MAX_PROMPT_LEN];

   of_memset(tmp_opt_buff,0,sizeof(tmp_opt_buff));
   of_memset(tmp_str,0,sizeof(tmp_str));
   of_memset(buff_a,0,sizeof(buff_a));
   of_memset(tmp_buff_a,0,sizeof(tmp_buff_a));

   cm_cli_puts (cli_session_p, "\n\t");

   if (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE)
   {
      if(cli_session_p->cd_table_b == FALSE && cli_session_p->context_b)
      {
         config_b = TRUE;
      }
      else if(cli_session_p->cd_table_b == TRUE && cli_session_p->context_b  && cli_session_p->curr_table_ctx_b)
      {
         config_b = TRUE;
      }
   }
   else if(cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR)
   {
      if(cli_session_p->cd_table_b == FALSE)
      {
         if(cli_session_p->current_node_p->parent_trans_b == TRUE)
         {
            config_b = TRUE;
         }
         else //if use parenttrans is false
         {
            //1. verify if its parent is table - skip
            //2. if parent is not table - allow
            //else
            //1. verify bcontext is false - allow - assuming not inside table
            if(cli_session_p->context_b == FALSE)
            {
               config_b = TRUE;
            }
            else //if bcontext is true
            {
               if(of_strcmp(cli_session_p->dmpath_a, cli_session_p->context_path) == 0)
                  config_b = TRUE;
            }
         }
      }
      else if(cli_session_p->cd_table_b == TRUE && cli_session_p->current_node_p->parent_trans_b == FALSE)// && cli_session_p->current_node_p->scalar_group_b == TRUE)
      {
         config_b = TRUE;
      }
   }

   if(config_b == TRUE)
   {    
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,
               struct cm_cli_data_ele_node *, list_node);

         of_memset(buff_a, 0, sizeof(buff_a));
         of_memset(tmp_buff_a,0,sizeof(tmp_buff_a));
         if (param_cnt_ui == 1)
         {
            if (of_strcmp ((char *) params_p[0].param_value,
                     data_ele_node_p->node_name) == 0)
            {
               check_back_list_b=TRUE; 
               if (data_ele_node_p->mandatory_b && data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
               {
                  sprintf (buff_a, "\t%s*", data_ele_node_p->node_name);
                  of_strcpy(tmp_mand_buff[tmp_mand_cnt_i],buff_a);
                  cm_cli_display_attrib_info (data_ele_node_p,tmp_mand_buff,tmp_mand_cnt_i);
                  if(data_ele_node_p->cli_idenetifier_help_p)
                  {
                     of_strcat(tmp_mand_buff[tmp_mand_cnt_i], "\r\n\tNote:");
                     of_strcat(tmp_mand_buff[tmp_mand_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
                  }
                  tmp_mand_cnt_i++;
               }
               else if(data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
               {
                  of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i],data_ele_node_p->node_name); 
                  if(data_ele_node_p->cli_identifier_p)
                  {    
                     of_strcat(tmp_opt_buff[tmp_attrib_cnt_i],"\t"); 
                     of_strcat(tmp_opt_buff[tmp_attrib_cnt_i],data_ele_node_p->cli_identifier_p); 
                  }
                  cm_cli_display_attrib_info (data_ele_node_p,tmp_opt_buff,tmp_attrib_cnt_i);
                  if(data_ele_node_p->cli_idenetifier_help_p)
                  {
                     of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], "\r\n\tNote:");
                     of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
                  }
                  tmp_attrib_cnt_i++;
               }
               return OF_SUCCESS;
            }
            else
            {
               continue;
            }
         }
         if (data_ele_node_p->key_b == TRUE && data_ele_node_p->visible_b == TRUE)
         {
            if(cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR)
            {
               sprintf (buff_a, "\t%s", data_ele_node_p->node_name);
               of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i],buff_a); 
               check_back_list_b=TRUE; 
            }
            else
               continue;
         }
         else if(data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
         {
            if(data_ele_node_p->cli_identifier_p)
            { 
               /* //VortiQa Requirement
                  sprintf (buff_a, "\t%-20s\t:%-10s\t", data_ele_node_p->node_name,
                  data_ele_node_p->cli_identifier_p);
                  */
               sprintf(tmp_buff_a,"%s(%s)",data_ele_node_p->node_name,
                     data_ele_node_p->cli_identifier_p);   
               sprintf (buff_a, "\t%-32s", tmp_buff_a);
            }
            else
            {
               /*  //VortiQa Requirement
                   sprintf (buff_a, "\t%-20s\t\t", data_ele_node_p->node_name);
                   */
               sprintf (buff_a, "\t%-32s", data_ele_node_p->node_name);
            }
            if(data_ele_node_p->cli_idenetifier_help_p)
            {
               of_strcat(buff_a, "\r\n\tNote:");
               of_strcat(buff_a, data_ele_node_p->cli_idenetifier_help_p);
            }
            of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i],buff_a); 
            check_back_list_b=TRUE; 
         }
         //cm_cli_puts (cli_session_p, buff_a);
         if (data_ele_node_p->mandatory_b && data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
         {
            if(data_ele_node_p->key_b == FALSE)
            {
               //sprintf (buff_a, "\t%s\t\t", data_ele_node_p->node_name);//VortiQa Requirement
               sprintf (buff_a, "\t%-32s", data_ele_node_p->node_name);
               of_strcpy(tmp_mand_buff[tmp_mand_cnt_i],buff_a); 
               cm_cli_display_attrib_info (data_ele_node_p,tmp_mand_buff,tmp_mand_cnt_i);
               if(data_ele_node_p->cli_idenetifier_help_p)
               {
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], "\r\n\tNote:");
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
               }
               tmp_mand_cnt_i++;
            }
            else
               continue;
         }
         else if(data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
         {
            if(data_ele_node_p->cli_identifier_p)
            {
               /*    //VortiQa Requirement
                     sprintf (buff_a, "\t%-20s\t:%-10s\t", data_ele_node_p->node_name,
                     data_ele_node_p->cli_identifier_p);
                     */
               sprintf(tmp_buff_a,"%s(%s)",data_ele_node_p->node_name,
                     data_ele_node_p->cli_identifier_p);   
               sprintf (buff_a, "\t%-32s", tmp_buff_a);
            }
            else
            {
               /*  //VortiQa Requirement
                   sprintf (buff_a, "\t%-20s\t\t", data_ele_node_p->node_name);
                   */
               sprintf (buff_a, "\t%-32s", data_ele_node_p->node_name);
            }
            of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i],buff_a); 
            cm_cli_display_attrib_info (data_ele_node_p,tmp_opt_buff,tmp_attrib_cnt_i);
            if(data_ele_node_p->cli_idenetifier_help_p)
            {
               of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], "\r\n\tNote:");
               of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
            }
            tmp_attrib_cnt_i++;
         }
      }
   }

   if( (tmp_mand_cnt_i > 0) || (tmp_attrib_cnt_i > 0) )
   {
      cm_cli_puts (cli_session_p, " Use \'set\' command to configure parameters: \n\t");
      cm_cli_puts (cli_session_p," set [ParamName1 <value>]...  [ParamNameN <Value>]\n\r");

      cm_cli_puts (cli_session_p, "\n");
   }
   for(tmp_i = 0; tmp_i < tmp_mand_cnt_i; tmp_i++)
   {
      if(tmp_i == 0)
         cm_cli_puts(cli_session_p, " Mandatory Parameter(s):\r\n");
      cm_cli_puts(cli_session_p,tmp_mand_buff[tmp_i]);
      cm_cli_puts(cli_session_p,"\n");
   }
   for(tmp_i = 0; tmp_i < tmp_attrib_cnt_i; tmp_i++)
   {
      if(tmp_i == 0)
         cm_cli_puts(cli_session_p, " Optional Parameter(s):\r\n");
      cm_cli_puts(cli_session_p,tmp_opt_buff[tmp_i]);
      cm_cli_puts(cli_session_p,"\n");
   }

   cm_cli_puts (cli_session_p, "\n\t");
   of_memset(buff_a,0,sizeof(buff_a));
   of_memset(tmp_opt_buff,0,sizeof(tmp_opt_buff));
   tmp_cnt_i = 0;

   //skip display of anchors and tables on "igd/>vsg general; igd/vsg general/>ls"
   if (( of_strcmp(cli_session_p->current_node_p->node_name, "vsg") == 0) && (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) && (cli_session_p->context_b == TRUE))
      goto end;
   CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p, UCMDllQNode_t *)
   {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,
            struct cm_cli_data_ele_node *, list_node);
      if(data_ele_node_p->visible_b == TRUE)
      {
         if (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "%s (Table) \n\t", data_ele_node_p->node_name);
               */
            sprintf (buff_a, "%s%% \n\t", data_ele_node_p->node_name);
         }
         else if ((data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR))
         {
            sprintf (buff_a, "%s/ \n\t", data_ele_node_p->node_name);
         }
         else
         {
            sprintf (buff_a, "%s \n\t", data_ele_node_p->node_name);
         }
         of_strncpy(tmp_opt_buff[tmp_cnt_i],buff_a,of_strlen(buff_a));
         tmp_cnt_i++;
      }
   }

   for(tmp_i = 0; tmp_i < tmp_cnt_i; tmp_i++)
      cm_cli_puts (cli_session_p, tmp_opt_buff[tmp_i]);
   cm_cli_puts (cli_session_p, "\n\r");

   if (cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == FALSE && config_b == FALSE)
   {
      cm_cli_puts(cli_session_p, "\n\rOnly the following commands can be used at this context:\n\t");
#ifdef CM_ROLES_PERM_SUPPORT
      cm_cli_puts(cli_session_p, "setrole\n\tgetrole\n\tcd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\r\n");
#else
      cm_cli_puts(cli_session_p, "cd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\n\tsave\n\tdel\r\n");
#endif
   }

end:
   if(cli_session_p->config_session_p != NULL)
   {
      if ( (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE && cli_session_p->current_node_p->parent_trans_b == TRUE) || 
            ( cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR && cli_session_p->current_node_p->scalar_group_b == TRUE && 
              cli_session_p->current_node_p->parent_trans_b == TRUE && cli_session_p->current_node_p->non_config_leaf_node_b != TRUE ) )
      {
         cm_cli_puts(cli_session_p, " Use below commands to save or cancel the changes:\n\t");
         cm_cli_puts(cli_session_p, "done\n\t");
         cm_cli_puts(cli_session_p, "cancel\n\r");
      }  
      else if ( (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE && cli_session_p->current_node_p->parent_trans_b == FALSE) || 
            ( cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR && cli_session_p->current_node_p->scalar_group_b == TRUE && 
              (cli_session_p->current_node_p->parent_trans_b == FALSE && cli_session_p->context_b && (of_strcmp(cli_session_p->dmpath_a, cli_session_p->context_path) == 0)) && cli_session_p->current_node_p->non_config_leaf_node_b != TRUE ) )
      {
         cm_cli_puts(cli_session_p, " Use below commands to save or cancel the changes:\n\t");
         cm_cli_puts(cli_session_p, "commit\n\t");
         cm_cli_puts(cli_session_p, "revoke\n\r");
      }  

   }
   return OF_SUCCESS;
}

/******************************************************************************
 ** Function Name : cm_sort_command_display 
 ** Description   : This callback API is to sort the provided childnode names 
 ** Input params  : *tmp_sort_buff - Unsorted list of childnodes
 **        tmp_cnt_i - childnode count
 ** Output params :
 ** Return value  :
 ******************************************************************************/

 void  cm_sort_command_display(char (*tmp_sort_buff)[512],int tmp_cnt_i)
{
   int32_t start_i = 0;
   int32_t end_i = 0;
   char *tmp_str=NULL;
   int32_t count_i = 0;
   int32_t buff_len_i = 0;

   for(count_i = 0; count_i<=tmp_cnt_i;count_i++)
   {
      buff_len_i += strlen(tmp_sort_buff[count_i]);
   }

   tmp_str = (char *)of_calloc(1,buff_len_i + 1);

   for(start_i=0;start_i<tmp_cnt_i;start_i++)
   {
      for(end_i=tmp_cnt_i-1;end_i >= start_i;end_i--)
      {
         if(of_strcmp(tmp_sort_buff[end_i],tmp_sort_buff[start_i]) < 1)
         {
            of_strcpy(tmp_str,tmp_sort_buff[end_i]);
            of_strcpy(tmp_sort_buff[end_i],tmp_sort_buff[start_i]);
            of_strcpy(tmp_sort_buff[start_i],tmp_str);
         }
      }                                     
   }
   if(tmp_str != NULL)
      of_free(tmp_str);
   return;  
}
/***************************************************************************
 * Function Name : cm_cli_change_directory
 * Description   : This callback API is invoked when user types the command
 *                 'cd' with some or no paramter. This is used to move from
 *                 one directory to the other.
 * Input         : cli_session_p - Cli Session pointer
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_change_directory (struct cm_cli_session * cli_session_p,
                               struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_cli_session *tmp_cli_session_p;
   unsigned char is_table_b;

   /*
      - Find the Directory
      - Convert to DMPath  
      - Convert the path info into dotted notation
      - Check for the directory path whether exists or not;
      - If exists update the prompt
      - Update child list in the session by freeing old child list
      */

   tmp_cli_session_p = cli_session_p;

   /* If no param is entered, move to Root directory. */
   if (param_cnt_ui == 0)
   {
      if(cli_session_p->config_session_p && cli_session_p->context_b)
      {
        cm_cli_puts (cli_session_p,
                        " Enter \'commit\' or \'revoke\' to close the Session.\n\r");
        return OF_FAILURE;
      }
      if (cm_cli_update_child_list_and_prompt
            (tmp_cli_session_p->root_c, tmp_cli_session_p->root_c, FALSE, &is_table_b) != OF_SUCCESS)
      {
         cm_cli_restore_prompt ();
         return OF_FAILURE;
      }
      if(cli_session_p->cd_table_b == TRUE)
      {
         cli_session_p->no_of_cds = 0;
         cli_session_p->cd_table_b = FALSE;
      }
         cm_cli_update_prompt (NULL);
         cm_cli_restore_prompt ();
      return;
   }

   cm_cli_validate_and_change_dir((char *) (params_p[0].param_value));

   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_validate_and_change_dir
 * Description   : 
 * Input         : path_p - Directory path
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_validate_and_change_dir(char *path_p)
{
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   char dir_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   int32_t return_value, init_pos_i = 0, cur_pos_i = 0;
   char *parent_path_p = NULL;
   unsigned char is_table_b = FALSE, is_dir_back_b = FALSE;

   int32_t i = 0;
   unsigned char ctx_no_update_b = FALSE;
   char dir_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 }, tmp_dmpath_a[CM_DM_MAX_PATH_LEN + 1] = { 0 };
   struct cm_dm_node_info *node_info_p = NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;

   ctx_no_update_b = cli_session_p->current_node_p->parent_trans_b;
   return_value = cm_cli_validate_path (path_p);
   if (return_value != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " Invalid path.\n\r");
      return OF_FAILURE;
   }

   //incase of cd ../../../ etc
   if( (of_strcmp(path_p, "..") != 0) && of_strstr(path_p, ".."))
   {
      if(cli_session_p->config_session_p && cli_session_p->context_b)//&& cli_session_p->index_i == 2)
      {
        if(cli_session_p->current_node_p->parent_trans_b == FALSE)
        {
          cm_cli_puts (cli_session_p,
                        " Enter \'commit\' or \'revoke\' to close the Session.\n\r");
        }
	else
	{
          cm_cli_puts (cli_session_p,
                        "Enter \'done\' or \'cancel\' to save or cancel the current node configuration.\n\r");
        }
        return OF_FAILURE;
      }
      is_dir_back_b = TRUE;
      init_pos_i = cli_session_p->index_i;
   }

   return_value = cm_cli_find_directory (path_p, dir_a, TRUE, 0);
   if (return_value != OF_SUCCESS)
   {
      sprintf (buff_a, " Invalid Directory entered.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
   }

   if(is_dir_back_b == TRUE)
   {
      cur_pos_i = cli_session_p->index_i;
   }

   cm_cli_convert_dir_to_dmpath (dir_a, dmpath_a);
   if(of_strcmp(path_p, "..") == 0)
   {
      if(cli_session_p->config_session_p && cli_session_p->context_b && cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE)
      {
        if(cli_session_p->current_node_p->parent_trans_b == FALSE)
        {
        cm_cli_puts (cli_session_p,
                        " Enter \'commit\' or \'revoke\' to close the Session.\n\r");
        }
	else
	{
          cm_cli_puts (cli_session_p,
                        "Enter \'done\' or \'cancel\' to save or cancel the current node configuration.\n\r");
        }
        return OF_FAILURE;
      }
      parent_path_p = (char *)of_calloc(1,of_strlen(dmpath_a)+1); 
      if(parent_path_p == NULL)
      {
         cm_cli_puts(cli_session_p, " Cannot allocate memory to get parent path.");
         return OF_FAILURE;
      }
      cm_cli_get_parent_path(dmpath_a, parent_path_p);
      return_value = cm_cli_update_child_list_and_prompt (parent_path_p, dir_a, FALSE, &is_table_b);
      if((return_value == OF_SUCCESS) && (cli_session_p->cd_table_b == TRUE))
      {
         cli_session_p->no_of_cds--;
         if(cli_session_p->no_of_cds == 0)
         {
            cli_session_p->cd_table_b = FALSE;
            cli_session_p->curr_table_ctx_b = FALSE;
         }
      }
   }
   else
   {
      return_value = cm_cli_update_child_list_and_prompt (dmpath_a, dir_a, FALSE, &is_table_b);
      if( (return_value == OF_SUCCESS) && (is_dir_back_b == TRUE) && ((is_table_b == TRUE) || (cli_session_p->cd_table_b == TRUE)) )
      {
         if(cli_session_p->no_of_cds <= init_pos_i - cur_pos_i)
         {
            cli_session_p->no_of_cds = 0;
            cli_session_p->cd_table_b = FALSE;
            cli_session_p->curr_table_ctx_b = FALSE;
         }
         else if(cli_session_p->no_of_cds > init_pos_i - cur_pos_i)
         {
            cli_session_p->no_of_cds = cli_session_p->no_of_cds -(init_pos_i - cur_pos_i);
            cli_session_p->cd_table_b = TRUE;
         }
      }
      else if((return_value == OF_SUCCESS) && (is_table_b == TRUE || cli_session_p->cd_table_b == TRUE) && (is_dir_back_b == FALSE))
      {
         cli_session_p->cd_table_b = TRUE;
         cli_session_p->no_of_cds++;
      }

      ctx_no_update_b = FALSE;
      if(is_table_b == FALSE && cli_session_p->current_node_p->scalar_group_b == TRUE) //anchor with grouped scalar
         ctx_no_update_b = cli_session_p->current_node_p->parent_trans_b;
   }

   if(return_value != OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      cm_cli_puts (cli_session_p, " Invalid path entered.\n\r");
      if(parent_path_p)
      {
         of_free(parent_path_p);
         parent_path_p = NULL;
      }
      return OF_FAILURE;
   }

   of_strcpy (cli_session_p->dmpath_a, dmpath_a);
   if(cli_session_p->cd_table_b == TRUE)
   {
      //incase of cd ../../../ etc
      if( is_dir_back_b == TRUE)
      {
         if(init_pos_i - cur_pos_i == 1)
         {
            ctx_no_update_b = cli_session_p->current_node_p->parent_trans_b;
         }
         else
         {
            cli_session_p->index_i = init_pos_i;
            for(i = 0; i < init_pos_i - cur_pos_i; i++)
            {
               cm_cli_get_dir_path (dir_path_a);
               cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);

               if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
                        tmp_dmpath_a, CM_CLI_MGMT_ENGINE_ID,
                        &cli_session_p->role_info,
                        &node_info_p, &child_info_arr_p) != OF_SUCCESS)
               {
#ifdef CM_CLI_DEBUG 
                  sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
                        __FUNCTION__);
                  cm_cli_puts (cli_session_p, buff_a);
#endif
                  //return OF_FAILURE;
               }
               else
               {
                  ctx_no_update_b = node_info_p->element_attrib.parent_trans_b;
               }
               cli_session_p->index_i = cli_session_p->index_i--;
            }
            cli_session_p->index_i = cur_pos_i;
            cm_cli_get_dir_path (dir_path_a);
            cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
         }
      }
      //current context update is required when current table does not depend on parent trans and the bcurtablectx is true
      if(ctx_no_update_b == FALSE || (cli_session_p->curr_table_ctx_b == FALSE && ctx_no_update_b == TRUE)) 
      {
         if(cli_session_p->context_b && (of_strcmp(dmpath_a, cli_session_p->context_path) == 0) )
            cli_session_p->curr_table_ctx_b = TRUE;
         else
            cli_session_p->curr_table_ctx_b = FALSE;
      }
   }
   if(cli_session_p->context_b == TRUE && ctx_no_update_b == TRUE)
   {
      of_strcpy(cli_session_p->context_path,cli_session_p->dmpath_a);
   }
   /*if (cli_session_p->context_b == TRUE) //Deepthi
     {
     cli_session_p->context_b = FALSE;
     of_memset (cli_session_p->context_path, 0, sizeof (cli_session_p->context_path));
     }*/
   if(parent_path_p)
   {
      of_free(parent_path_p);
      parent_path_p = NULL;
   }
}

int32_t cm_cli_get_parent_path(char *dm_path_p, char *parent_path_p)
{
   int32_t path_len_i;

   path_len_i = of_strlen(dm_path_p);
   while( path_len_i > 0 && dm_path_p[path_len_i-1] != '.')
   {
      if(dm_path_p[path_len_i-1] == '}')
      {
         path_len_i--;
         while(dm_path_p[path_len_i-1] != '{')
         {
            path_len_i--;
         }
         break;
      }
      else
      {
         strncpy(parent_path_p, dm_path_p, path_len_i);
         parent_path_p[path_len_i]='\0';
         return OF_SUCCESS;
      }
   }
   if(path_len_i == 0)
      return OF_FAILURE;
   of_strncpy(parent_path_p,dm_path_p,path_len_i-1);
   parent_path_p[path_len_i-1]='\0';
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_move_to_prev_directory
 * Description   : This callback API will get inkoved when the user issues
 *                 '..' on the command prompt. This will move to the parents
 *                 directory.
 * Input         : cli_session_p - Cli Session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_move_to_prev_directory (struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   char dir_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   char dmpath_a[CM_DM_MAX_PATH_LEN + 1] = { 0 };
   char *parent_path_p = NULL;
   unsigned char is_table_b, prev_node_use_parent_trans_b = FALSE;

   if(cli_session_p->config_session_p && cli_session_p->context_b && cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE
      && cli_session_p->current_node_p->scalar_group_b == FALSE)
   {
     if(cli_session_p->current_node_p->parent_trans_b == FALSE)
     {
       cm_cli_puts (cli_session_p,
                        " Enter \'commit\' or \'revoke\' to close the Session.\n\r");
     }
     else
     {
       cm_cli_puts (cli_session_p,
                        "Enter \'done\' or \'cancel\' to save or cancel the current node configuration.\n\r");
     }
     return OF_FAILURE;
   }
   prev_node_use_parent_trans_b = cli_session_p->current_node_p->parent_trans_b;
   if (cli_session_p->index_i)
   {
      cli_session_p->index_i--;
   }
   else
   {
      return OF_SUCCESS;
   }

   /*if (cli_session_p->context_b == TRUE) //Deepthi
     {
     cli_session_p->context_b = FALSE;
     of_memset (cli_session_p->context_path, 0, sizeof (cli_session_p->context_path));
     }*/

   cm_cli_get_dir_path (dir_a);

   cm_cli_convert_dir_to_dmpath (dir_a, dmpath_a);
   if(cli_session_p->context_b == TRUE && prev_node_use_parent_trans_b == TRUE) 
   {
      of_strcpy(cli_session_p->context_path,dmpath_a);
   }

   parent_path_p = (char *)of_calloc(1,of_strlen(dmpath_a)+1); 
   if(parent_path_p == NULL)
   {
      cm_cli_puts(cli_session_p, " Cannot allocate memory to get parent path.");
      return OF_FAILURE;
   }
   cm_cli_get_parent_path(dmpath_a, parent_path_p);
   if (cm_cli_update_child_list_and_prompt (parent_path_p, dir_a, FALSE, &is_table_b) != OF_SUCCESS)
   {
      if(parent_path_p)
      {
         of_free(parent_path_p);
         parent_path_p = NULL;
      }
      cm_cli_restore_prompt ();
      return OF_FAILURE;
   }
   if(cli_session_p->cd_table_b == TRUE)
   {
      cli_session_p->no_of_cds--;
      if(cli_session_p->no_of_cds == 0)
      {
         cli_session_p->cd_table_b = FALSE;
         cli_session_p->curr_table_ctx_b = FALSE;
      }
      else
      {
         if(cli_session_p->curr_table_ctx_b == FALSE || (cli_session_p->curr_table_ctx_b == TRUE && prev_node_use_parent_trans_b == FALSE))
         {
            if(cli_session_p->context_b && (of_strcmp(dmpath_a, cli_session_p->context_path) == 0) )
               cli_session_p->curr_table_ctx_b = TRUE;
            else
               cli_session_p->curr_table_ctx_b = FALSE;
         }
      }
   }
   else
   {
      if(prev_node_use_parent_trans_b == TRUE)
         cli_session_p->curr_table_ctx_b = TRUE;
      else
         cli_session_p->curr_table_ctx_b = FALSE;
   }
   of_strcpy (cli_session_p->dmpath_a, dmpath_a);


   if(parent_path_p)
   {
      of_free(parent_path_p);
      parent_path_p = NULL;
   }
   return OF_SUCCESS;
}

/******************************************************************************
 * Function Name : cm_cli_commit_config_session
 * Description   : This API is used to inform JE to COMMIT all the statements
 *                 exsits in the configuration session.
 * Input params  : cli_session_p - Cli Session
 *                 params_p - input parameters 
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_commit_config_session (struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (cli_session_p->config_session_p == NULL)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   return cm_cli_end_config_session (cli_session_p->config_session_p,
         CM_CMD_CONFIG_SESSION_COMMIT);
}


/******************************************************************************
 * Function Name : cm_cli_end_config_session
 * Description   : This API is used to inform JE to COMMIT / REVOKEall the statements
 *                 exsits in the configuration session.
 * Input params  : config_session_p - Config Session
 *                 op_code_ui - Operation code
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
 int32_t cm_cli_end_config_session (void * config_session_p, uint32_t op_code_ui)
{
   int32_t return_value, node_cnt_i = 0;
   struct cm_result *result_p = NULL;
   char dir_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 }, tmp_dmpath_a[CM_DM_MAX_PATH_LEN + 1] = { 0 };
   unsigned char use_parent_b = FALSE;
   struct cm_dm_node_info *node_info_p = NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   char *parent_path_p = NULL;
   unsigned char is_table_b;

   of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
   of_memset(dir_path_a, 0, sizeof(dir_path_a));
   //Verifying if the current table uses parents transaction
   //for tables/anchors that uses parent transaction
   if (cli_session_p->current_node_p->parent_trans_b == TRUE) 
   {
      node_cnt_i++;
      use_parent_b = TRUE;
      cli_session_p->index_i = cli_session_p->index_i - node_cnt_i;
      cm_cli_get_dir_path (dir_path_a);
      cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
      while(use_parent_b == TRUE)
      {
         use_parent_b = FALSE;

         if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
                  tmp_dmpath_a, CM_CLI_MGMT_ENGINE_ID,
                  &cli_session_p->role_info,
                  &node_info_p, &child_info_arr_p) != OF_SUCCESS)
         {
#ifdef CM_CLI_DEBUG 
            sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
                  __FUNCTION__);
            cm_cli_puts (cli_session_p, buff_a);
#endif
            //return OF_FAILURE;
         }
         else
         {
            if (node_info_p->element_attrib.parent_trans_b == TRUE) 
            {
               use_parent_b = TRUE;
               node_cnt_i++;
               cli_session_p->index_i--;
               cm_cli_get_dir_path (dir_path_a);
               cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
            }
         }
      }
      cli_session_p->index_i--;
      node_cnt_i++;
      cm_cli_get_dir_path (dir_path_a);
      cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
   }

   /*Call Config Session end with OPCode as COMMIT */
   return_value = cm_config_session_end (cli_session_p->config_session_p,
         op_code_ui, &result_p);
   if (return_value == OF_FAILURE)
   {
      /* Free the Result structure */
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
         //putting back the original index incase of failure
         cli_session_p->index_i = cli_session_p->index_i + node_cnt_i;
      }
      return OF_FAILURE;
   }
   cli_session_p->config_session_p = NULL;

   //curr_table_ctx_b is verfied to make sure commit/revoke is issued on successful addition of table.
   //this function will be called if there is any error while adding the table - in that case cd count should not be
   //decremented as it is never incremented.
   if(node_cnt_i > 0 && cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == TRUE) 
   {
      if(cli_session_p->no_of_cds > node_cnt_i)
      {
         cli_session_p->no_of_cds = cli_session_p->no_of_cds - node_cnt_i;
      }
      else
      {
         cli_session_p->no_of_cds = 0;
         cli_session_p->cd_table_b = FALSE;
         cli_session_p->curr_table_ctx_b = FALSE;
      }
   }
   //else
   //  cli_session_p->curr_table_ctx_b = TRUE;

   //for tables/anchors that does not uses parent transaction
   if (cli_session_p->current_node_p->parent_trans_b != TRUE)
   {
      if(cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE && cli_session_p->context_b == TRUE ||
            cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR  && cli_session_p->context_b == TRUE)
      {
         cli_session_p->index_i = cli_session_p->index_i - 1;
         if(cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == TRUE)
         {
            cli_session_p->no_of_cds--;
            if(cli_session_p->no_of_cds == 0)
            {
               cli_session_p->cd_table_b = FALSE;
               cli_session_p->curr_table_ctx_b = FALSE;
            }
         }
      }
      cm_cli_get_dir_path (dir_path_a);
      cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
   }

   if(op_code_ui == CM_CMD_CONFIG_SESSION_COMMIT)
   {     
      cm_cli_display_result (result_p);
   }
   else  
      if(op_code_ui == CM_CMD_CONFIG_SESSION_REVOKE)
      {     
         cm_cli_puts (cli_session_p, " Session revoked successfully.\n\r");
      }

   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   if (cli_session_p->context_b)
   {
      cli_session_p->context_b = FALSE;
      cli_session_p->curr_table_ctx_b = FALSE;
      of_memset (cli_session_p->context_path, 0, sizeof (cli_session_p->context_path));
      //cli_session_p->index_i--;
   }
   if(cli_session_p->cd_table_b == TRUE)
   {
      if(cli_session_p->context_b && (of_strcmp(tmp_dmpath_a, cli_session_p->context_path) == 0) )
         cli_session_p->curr_table_ctx_b = TRUE;
      else
         cli_session_p->curr_table_ctx_b = FALSE;
   }
   //cm_cli_get_dir_path (dir_path_a);
   //cm_cli_convert_dir_to_dmpath (dir_path_a, cli_session_p->dmpath_a);
   if(of_strcmp(tmp_dmpath_a, "") == 0) //due to some failure
   {
      cm_cli_get_dir_path (dir_path_a);
      cm_cli_convert_dir_to_dmpath (dir_path_a, tmp_dmpath_a);
   }
   of_strcpy(cli_session_p->dmpath_a, tmp_dmpath_a);
   if( (cli_session_p->current_node_p->parent_trans_b == FALSE) &&
         (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE ) &&
         (cli_session_p->current_node_p->global_trans_b == FALSE))
   {
      parent_path_p = (char *)of_calloc(1,of_strlen(tmp_dmpath_a)+1); 
      if(parent_path_p == NULL)
      {
         cm_cli_puts(cli_session_p, " Cannot allocate memory to get parent path.");
         return OF_FAILURE;
      }
      cm_cli_get_parent_path(tmp_dmpath_a, parent_path_p);
      return_value = cm_cli_update_child_list_and_prompt (parent_path_p, dir_path_a, FALSE, &is_table_b);
   }
   else
      cm_cli_update_child_list_and_prompt (cli_session_p->dmpath_a, dir_path_a, FALSE, &is_table_b);
   if(return_value !=  OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      if(parent_path_p)
      {
         of_free(parent_path_p);
         parent_path_p = NULL;
      }
      return OF_FAILURE;
   }
   if(parent_path_p)
   {
      of_free(parent_path_p);
      parent_path_p = NULL;
   }

   return OF_SUCCESS;
}

/******************************************************************************
 * Function Name : cm_cli_revoke_config_session
 * Description   : This callback API is used to send a Revocation command to
 *                 JE, to revoke the config session and not to execute the
 *                 commands exists in the config session. 
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_revoke_config_session (struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   return cm_cli_end_config_session (cli_session_p->config_session_p,
         CM_CMD_CONFIG_SESSION_REVOKE);
}

/******************************************************************************
 * Function Name : cm_cli_cancel_command
 * Description   : This callback API is used to send a cancel command to
 *                 JE, to cancel the config session and to delete the
 *                 commands exists in the config session. 
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_cancel_command (struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   struct cm_command command_info;
   char dir_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   struct cm_result *result_p;
   unsigned char is_table_b;

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   of_memset (&command_info, 0, sizeof (command_info));
   if(cli_session_p->context_path[0] != '\0')
   {
      cm_cli_fill_command_info (CM_CMD_CANCEL_TRANS_CMD, cli_session_p->context_path,
            0, NULL,
            &command_info);
   }
   else //incase of context path null
   {
      cm_cli_fill_command_info (CM_CMD_CANCEL_TRANS_CMD, cli_session_p->dmpath_a,
            0, NULL,
            &command_info);
   }

   /* Send to JE using ConfigSessionUpdate */
   if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info, &result_p)
         != OF_SUCCESS)
   {
      if (result_p)
      {    
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }    
      return OF_FAILURE;
   }

   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   cm_cli_puts (cli_session_p, " Command is nullified.\n\r");

   cli_session_p->index_i--; 
   if(cli_session_p->cd_table_b == TRUE)
   {
      cli_session_p->no_of_cds--;
      if(cli_session_p->no_of_cds == 0)
      {
         cli_session_p->cd_table_b = FALSE;
         cli_session_p->curr_table_ctx_b = TRUE;
      }
   }
   cm_cli_get_dir_path (dir_path_a);
   cm_cli_convert_dir_to_dmpath (dir_path_a, cli_session_p->dmpath_a);
   of_strcpy(cli_session_p->context_path,cli_session_p->dmpath_a);
   cli_session_p->context_b = TRUE;
   cli_session_p->curr_table_ctx_b = TRUE;
   if (cm_cli_update_child_list_and_prompt (cli_session_p->dmpath_a, dir_path_a, FALSE, &is_table_b) !=
         OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      return OF_FAILURE;
   }

   return OF_SUCCESS;
}

/******************************************************************************
 * Function Name : cm_cli_set_certificate_command 
 * Description   : This callback API is used to send a set command to
 *                 JE, to upload certificates. 
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/

int32_t cm_cli_set_certificate_command (struct cm_cli_session * cli_session_p,
                       struct cm_cli_params * params_p,
                       uint32_t param_cnt_ui)
{
   unsigned char *cert_buff_a=NULL;
   unsigned char buff_a1[50]="";
   unsigned char   *tmp_p=NULL;
   unsigned char   buff_a2[256]="";
   int32_t    l_length = 0, l_size = PKI_DEFAULT_1024_LENGTH;

   struct cm_array_of_nv_pair nv_pair_array;
   struct cm_nv_pair *tmp_nv_pair_p;
   struct cm_result *result_p;
   struct cm_command command_info;
   UCMDllQNode_t *dll_q_node_p;
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   struct cm_cli_data_ele_node *data_ele_node_p;
   unsigned char found_b;
   int32_t ii, jj, return_value;

   if ((!cli_session_p) || !(params_p) || (param_cnt_ui < 1))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }


   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            cli_session_p->dmpath_a,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }


   found_b = FALSE;
   CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
         UCMDllQNode_t *)
   {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
            list_node);
      if (of_strcmp (data_ele_node_p->node_name, (char *) params_p[0].param_value)
            == 0)
      {
         found_b = TRUE;
      }
   }
   if (found_b == FALSE)
   {
      sprintf (buff_a, " Invalid parameter name (%s) entered.\n\r",
            (char *) params_p[ii].param_value);
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
   }


   cert_buff_a = (unsigned char*)of_calloc(1,l_size);
   cm_cli_puts(cli_session_p,"\r\n Note: Only PEM format can be imported.\r\n\r\n");
   cm_cli_puts(cli_session_p, " Paste the data:\n\r");
   of_strcpy(buff_a1, "-----END ");
   tmp_p = cert_buff_a; 
   while(1)
   {
      of_memset(buff_a2, 0, sizeof(buff_a2));
      cli_fgets(cli_session_p, buff_a2, PKI_GETS_BUFFER_LEN);
      if (of_strlen(buff_a2) <= 0)
      {
         cm_cli_puts(cli_session_p," Invalid Certificate Data.\r\n");
         return OF_FAILURE;
      }

      l_length += of_strlen(buff_a2);
      if(l_length >= PKI_MAX_CERT_SIZE)
      {
         cm_cli_puts(cli_session_p,"\r\n Maximum certificate size allowed is 10240 bytes.\r\n");
         return OF_FAILURE;
      }
      if(l_size < l_length)
      {
         l_size += PKI_DEFAULT_1024_LENGTH;
         cert_buff_a = (unsigned char *)of_realloc(cert_buff_a, l_size);
         if(cert_buff_a == NULL)
         {
            cm_cli_puts(cli_session_p," of_realloc failed\r\n");
            return OF_FAILURE;
         }
         tmp_p = cert_buff_a;
         tmp_p = tmp_p + l_length - of_strlen(buff_a2);
      }

      of_strcpy(tmp_p, buff_a2);

      if(of_strstr(buff_a2, buff_a1) != NULL)
      {
         break;
      }

      tmp_p += of_strlen(tmp_p);
      *tmp_p = '\n';
      tmp_p++;
      l_length++;
   }
   /* Get number of Name-Value pairs */
   nv_pair_array.count_ui = param_cnt_ui ;

   /* Allocate memory for Name-Value pairs */
   nv_pair_array.nv_pairs = (struct cm_nv_pair *) of_calloc (nv_pair_array.count_ui,
         sizeof (struct cm_nv_pair));
   if (nv_pair_array.nv_pairs == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed for nv_pairs\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Fill Name-Value pairs */
   tmp_nv_pair_p = nv_pair_array.nv_pairs;
   for (ii = 0, jj = 0; jj < nv_pair_array.count_ui; jj++)
   {
      /* Copy Name Len */
      tmp_nv_pair_p[jj].name_length = of_strlen ((char *) params_p[ii].param_value);

      /* Copy Name */
      tmp_nv_pair_p[jj].name_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].name_length + 1);
      if (tmp_nv_pair_p[jj].name_p == NULL)
      {
         /* Free all the nv_pairs */

         CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }
      of_memcpy (tmp_nv_pair_p[jj].name_p, (char *) params_p[ii++].param_value,
            tmp_nv_pair_p[jj].name_length);

      /* Copy Value Type  */
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
               list_node);
         if (of_strcmp (data_ele_node_p->node_name, tmp_nv_pair_p[jj].name_p) == 0)
         {
            tmp_nv_pair_p[jj].value_type = data_ele_node_p->data_type;
         }
      }

      /* Copy Value Length  */
      //    tmp_nv_pair_p[jj].value_length = of_strlen ((char *) params_p[ii].param_value);
      tmp_nv_pair_p[jj].value_length = of_strlen (cert_buff_a);

      /* Copy Value */
      tmp_nv_pair_p[jj].value_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].value_length + 1);
      if (tmp_nv_pair_p[jj].value_p == NULL)
      {
         /* Free all the nv_pairs */
         of_free (tmp_nv_pair_p[jj].name_p);
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }
      of_memcpy (tmp_nv_pair_p[jj].value_p, cert_buff_a, tmp_nv_pair_p[jj].value_length);
   }

   for (ii = 0; ii < nv_pair_array.count_ui; ii++)
   {
      return_value = cm_cli_validate_attribute (&nv_pair_array.nv_pairs[ii],NULL);
      if (return_value == OF_FAILURE)
      {
         sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
               (char *)nv_pair_array.nv_pairs[ii].value_p, nv_pair_array.nv_pairs[ii].name_p);
         cm_cli_puts(cli_session_p, buff_a);
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
         return OF_FAILURE;
      }
   }

   /* Fill Command Info structure */
   of_memset (&command_info, 0, sizeof (command_info));
   cm_cli_fill_command_info (CM_CMD_SET_PARAMS, cli_session_p->context_path,
         nv_pair_array.count_ui, nv_pair_array.nv_pairs,
         &command_info);
   /* Send to JE using ConfigSessionUpdate */
   if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info, &result_p)
         != OF_SUCCESS)
   {
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }

      return OF_FAILURE;
   }

   CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   return OF_SUCCESS;

}

/******************************************************************************
 * Function Name : cm_cli_done_command 
 * Description   : This callback API is used to send a done command to
 *                 JE, to execute transaction based commands or table inside table
                   records prior executing parent table records.
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_done_command (struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   struct cm_command command_info;
   char dir_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   struct cm_result *result_p;
   unsigned char is_table_b;

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   if ( (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) &&
         (cli_session_p->current_node_p->parent_trans_b == FALSE) )
   {
      cm_cli_puts (cli_session_p, " Use commit/revoke at this context.\n\r");
      return OF_FAILURE;
   }

   of_memset (&command_info, 0, sizeof (command_info));
   if(cli_session_p->context_path[0] != '\0')
   {
      cm_cli_fill_command_info (CM_CMD_EXEC_TRANS_CMD, cli_session_p->context_path,
            0, NULL,
            &command_info);
   }
   else //if contextpath is null
   {
      cm_cli_fill_command_info (CM_CMD_EXEC_TRANS_CMD, cli_session_p->dmpath_a,
            0, NULL,
            &command_info);
   }

   /* Send to JE using ConfigSessionUpdate */
   if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info, &result_p)
         != OF_SUCCESS)
   {
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }
      return OF_FAILURE;
   }

   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   cm_cli_puts (cli_session_p, " Command executed successfully.\n\r");

   cli_session_p->index_i--;
   if(cli_session_p->cd_table_b == TRUE)
   {
      cli_session_p->no_of_cds--;
      if(cli_session_p->no_of_cds == 0)
      {
         cli_session_p->cd_table_b = FALSE;
         cli_session_p->curr_table_ctx_b = TRUE;
      }
   }
   cm_cli_get_dir_path (dir_path_a);
   cm_cli_convert_dir_to_dmpath (dir_path_a, cli_session_p->dmpath_a);
   of_strcpy(cli_session_p->context_path,cli_session_p->dmpath_a);
   cli_session_p->context_b = TRUE;
   cli_session_p->curr_table_ctx_b = TRUE;

   if (cm_cli_update_child_list_and_prompt (cli_session_p->dmpath_a, dir_path_a, FALSE, &is_table_b) !=
         OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      return OF_FAILURE;
   }

   return OF_SUCCESS;
}

void cm_cli_reboot_device_in_config_session(struct cm_cli_session *cli_session_p)
{
   cm_cli_reboot_device(cli_session_p,NULL,0);
}

/******************************************************************************
 * Function Name : cm_cli_reboot_device 
 * Description   : This callback API is used to send a reboot command to
 *                 JE, to reboot a device or a particular board to reboot this
                   command is used.
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_reboot_device(struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   struct cm_array_of_nv_pair *nv_pair_array_p=NULL;
   char reboot_a;

   printf("Press \'y\' to reboot or any other key to exit.\r\n");
   scanf("%c",&reboot_a);
   if(reboot_a == 'y') 
   {
      if (UCMRebootDevice (CM_CLI_MGMT_ENGINE_ID,&cli_session_p->role_info,  cli_session_p->tnsprt_channel_p, &nv_pair_array_p) != OF_SUCCESS)
      {
         cm_cli_puts (cli_session_p, " Device reboot failed.\n\r");
         return OF_FAILURE;
      }
      cm_cli_puts (cli_session_p, " Rebooting the device...\r\n Please wait for a while and re-login.\n\r");
      exit(1);
   }
   else
      return OF_FAILURE;

}

/******************************************************************************
 * Function Name : cm_cli_get_versions 
 * Description   : This callback API is used to send a get version command to
 *                 JE, to get current confiuration version and saved version this
                   command is used.
 * Input params  : cli_session_p - pointer to config session
 *                 params_p - pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_get_versions(struct cm_cli_session * cli_session_p,
                                   struct cm_cli_params * params_p,
                                   uint32_t param_cnt_ui)
{
   struct cm_array_of_nv_pair *nv_pair_array_p=NULL;
   if ( UCMGetversions (CM_CLI_MGMT_ENGINE_ID,&cli_session_p->role_info,  cli_session_p->tnsprt_channel_p, &nv_pair_array_p) != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, "CM get versions failed.\n\r");
      return OF_FAILURE;
   }
   cm_cli_display_nv_pair(nv_pair_array_p->count_ui, nv_pair_array_p,NULL);
   cm_cli_puts (cli_session_p, "\n");
   CM_FREE_PTR_NVPAIR_ARRAY (nv_pair_array_p,nv_pair_array_p->count_ui);
   return OF_SUCCESS;
}



/******************************************************************************
 * Function Name : cm_cli_cancel_prev_command
 * Description   : This Callback API is used to cancel a command that is
 *                 already issued by the used and should exist in the current
 *                 config session.
 * Input params  : cli_session_p- pointer to the Cli Session
 *                 params_p- pointer to input parameters
 * Output params : NONE
 * Return value  : OF_SUCCESS/ OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_cancel_prev_command (struct cm_cli_session * cli_session_p,
                                 struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   /*TODO: With latest JE updates as per Suren comments */   
   struct cm_result *result_p = NULL;
   struct cm_command command_info;
   char param_a[CM_CLI_MAX_NAME_LEN + 1] = { 0 };
   struct cm_nv_pair nv_pair;
   int32_t return_value;

   if (!(cli_session_p) || !(params_p) || (param_cnt_ui == 0))
   {
      sprintf (buff_a, " Invalid input.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
   }

   if (cli_session_p->config_session_p == NULL)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   /* Frame Name-Value pairs */
   of_memset(&nv_pair, 0, sizeof(nv_pair));
   of_strcpy (param_a, (char *) params_p[0].param_value);
   nv_pair.name_length = of_strlen (param_a);
   nv_pair.name_p = (char *) of_calloc (1, nv_pair.name_length + 1);
   if (nv_pair.name_p == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }
   of_strcpy (nv_pair.name_p, param_a);

   /* Fill Command structure */
   cm_cli_fill_command_info (CM_CMD_CANCEL_PREV_CMD,
         cli_session_p->dmpath_a, 1, &nv_pair, &command_info);

   /* Invoke Update Config Session command */
   return_value = cm_config_session_update_cmd (cli_session_p->config_session_p,
         &command_info, &result_p);
   if (return_value != OF_SUCCESS)
   {
      of_free (nv_pair.name_p);
      /* Based on the input present in the result_p display the error message */
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }
      return OF_FAILURE;
   }

   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   of_free (nv_pair.name_p);
   cm_cli_puts (cli_session_p,
         " Removed the command from Configuration Session.\n\r");
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_compare
 * Description   : This callback API is used to compare a entered data element's
 *                 value, that exists in the configuration session, with the
 *                 value that exists in the Security Application database.
 * Input         : cli_session_p - Cli Session pointer
 *                 params_p - Input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_compare (struct cm_cli_session * cli_session_p,
                       struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_result *result_p = NULL;
   struct cm_command command_info;
   char param_a[CM_CLI_MAX_NAME_LEN + 1] = { 0 };
   struct cm_nv_pair nv_pair;
   struct cm_array_of_nv_pair *nv_pair_array_p = NULL;
   int32_t return_value;

   if (!(cli_session_p) || !(params_p) || (param_cnt_ui == 0))
   {
      sprintf (buff_a, " Invalid input.\n\r");
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
   }

   if (!(cli_session_p->config_session_p))
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   /* Frame Name-Value pairs */
   of_memset(&nv_pair, 0, sizeof(nv_pair));
   of_strcpy (param_a, (char *) params_p[0].param_value);
   nv_pair.name_length = of_strlen (param_a);
   nv_pair.name_p = (char *) of_calloc (1, nv_pair.name_length + 1);
   if (nv_pair.name_p == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }
   of_strcpy (nv_pair.name_p, param_a);

   /* Fill Command Info */
   cm_cli_fill_command_info (CM_CMD_COMPARE_PARAM,
         cli_session_p->dmpath_a, 1, &nv_pair, &command_info);

   /* Invoke Update Config Session */
   return_value = cm_config_session_get_cmd (cli_session_p->config_session_p,
         &command_info, &result_p);
   if (return_value != OF_SUCCESS)
   {
      /* Based on the input present in the result_p display the error message */
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }
      of_free (nv_pair.name_p);
      return OF_FAILURE;
   }

   /* Display the Result */
   nv_pair_array_p = (struct cm_array_of_nv_pair *)result_p->data.je_data_p;

   if(nv_pair_array_p)
   { 
      cm_cli_display_nv_pair_array(nv_pair_array_p, 1,cli_session_p->dmpath_a);
      CM_FREE_PTR_NVPAIR_ARRAY(nv_pair_array_p, nv_pair_array_p->count_ui);
      /* Atmaram - Memory Leak - Friendly names, enum array in nv pair not freed
      */
   }

   /* Free Result structure */
   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   of_free (nv_pair.name_p);

   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_all_tables
 * Description   : This callback API will get invoked when user issues
 *                 'showall' command onthe command line interface. This will
 *                 get the information of the tables and records of each table
 *                 of a particular DM path and will display them. 
 * Input         : cli_session_p - Cli Session pointer
 *                 params_p - pointer to input paramteres
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_all_tables (struct cm_cli_session * cli_session_p,
                                struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   // UCMDllQNode_t *dll_q_node_p;
   //struct cm_cli_data_ele_node *pNode;
   char dmpath_a[CM_CLI_DEFAULT_DIR_LENGTH + 1];
   struct cm_array_of_nv_pair keys_array={0};

   if (!(cli_session_p) || !(params_p))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   of_memset (dmpath_a, 0, sizeof (dmpath_a));
   if(of_strcmp(cli_session_p->context_path,"") == 0)
      of_strcpy (dmpath_a, cli_session_p->dmpath_a);
   else
      of_strcpy (dmpath_a, cli_session_p->context_path);

   if(dmpath_a[of_strlen(dmpath_a)-1] == '}')
   {
      cm_cli_display_records_of_table (dmpath_a, &keys_array, TRUE);
   }
   else
   {
      cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE);
   }
   cm_cli_puts (cli_session_p, "\n\r");

   of_memset(&keys_array,0,sizeof(struct cm_array_of_nv_pair));

   /* For each (child node == TABLE) , call GET_FIRST_N and GET_NEXT_N and
    * display them   */
   /*
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p, UCMDllQNode_t *)
      {
      pNode = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
      if (pNode->node_type == CM_DMNODE_TYPE_TABLE)
      {
   //Fill nv_pair array
   of_memset (dmpath_a, 0, sizeof (dmpath_a));
   of_memset(&keys_array,0,sizeof(struct cm_array_of_nv_pair));
   if(of_strcmp(cli_session_p->context_path,"") == 0)
   of_strcpy (dmpath_a, cli_session_p->dmpath_a);
   else
   of_strcpy (dmpath_a, cli_session_p->context_path);
   of_strcat (dmpath_a, ".");
   of_strcat (dmpath_a, pNode->node_name);

   cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE);
   cm_cli_puts (cli_session_p, "\n\r");
   }
   }
   */
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_delete_record
 * Description   : This callback API is used to delete a Record from the
 *                 Security application Database.
 * Input         : cli_session_p- Pointer to Cli Session
 *                 params_p - Pointer to input params structure
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_delete_record (struct cm_cli_session * cli_session_p,
                         struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_command command_info;
   //  struct cm_nv_pair nv_pair; CID 552
   struct cm_result *result_p = NULL;
   char tmp_str_a[CM_CLI_MAX_PROMPT_LEN + 1],
           temp_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
#ifdef CM_DM_INSTANCE_TREE_DEPENDENCY_ENABLED
   unsigned char instance_exists_b = FALSE;
#endif
   unsigned char this_session_b = FALSE;
   struct cm_array_of_nv_pair *out_array_of_nv_pair_arr = NULL;
   struct cm_array_of_nv_pair *key_nv_pairs_p =NULL;
   int32_t return_value1, return_value;
   int32_t ii;
   unsigned char is_table_b;

   if (param_cnt_ui != 2)
   {
      cm_cli_puts (cli_session_p, " Invalid number of arguments.\n\r");
      return OF_FAILURE;
   }

   /* Start config session if needed */
   if (cli_session_p->config_session_p == NULL)
   {
      cli_session_p->config_session_p =
         (struct cm_je_config_session *) cm_config_session_start (CM_CLI_MGMT_ENGINE_ID,
               &cli_session_p->role_info,
               cli_session_p->tnsprt_channel_p);
      if (cli_session_p->config_session_p == NULL)
      {
         cm_cli_puts (cli_session_p, " Configuration session start failed.\n\r");
         return OF_FAILURE;
      }
      this_session_b = TRUE;
   }

   of_memset (tmp_str_a, 0, sizeof (tmp_str_a));

   cm_cli_get_dir_path (temp_path_a);
   of_strcat (temp_path_a, "/");
   of_strcat (temp_path_a, (char *) params_p[0].param_value);

   of_strcpy (tmp_str_a, temp_path_a);

   of_strcat (temp_path_a, " ");
   //  of_strcat (temp_path_a, (char *) params_p[1].param_value);

   cm_cli_convert_dir_to_dmpath (tmp_str_a, tmp_str_a);

   if (cm_cli_update_child_list_and_prompt (tmp_str_a, tmp_str_a, TRUE,&is_table_b) != OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      if(this_session_b)
      {
         cm_cli_end_config_session (cli_session_p->config_session_p,
               CM_CMD_CONFIG_SESSION_REVOKE);
         cli_session_p->config_session_p = NULL;
      }
      return OF_FAILURE;
   }
   else
   {
      if(cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE && cli_session_p->current_node_p->parent_trans_b == TRUE)
      {
         if(cli_session_p->cd_table_b == TRUE && (cli_session_p->context_b == FALSE || (cli_session_p->context_b && cli_session_p->curr_table_ctx_b == FALSE) ))
         {
            sprintf(buff_a," Cannot delete %s as it depends on its parents transaction; and transaction record is not available.\r\n",(char *) params_p[0].param_value);
            cm_cli_puts(cli_session_p, buff_a);
            cm_cli_restore_prompt ();
            if(this_session_b)
            {
               cm_cli_end_config_session (cli_session_p->config_session_p,
                     CM_CMD_CONFIG_SESSION_REVOKE);
               cli_session_p->config_session_p = NULL;
            }
            return OF_FAILURE;
         }
      }
   }
#if 0
  /* Fill nv_pair structure */
  of_memset (&nv_pair, 0, sizeof (nv_pair));

  nv_pair.name_length = of_strlen (cli_session_p->current_node_p->key_node_info.node_name);
  nv_pair.name_p = (char *) of_calloc (1, nv_pair.name_length + 1);
  if (nv_pair.name_p == NULL)
  {
    cm_cli_restore_prompt ();
    cm_cli_puts (cli_session_p, "Calloc Failed\n\r");
    if(this_session_b)
    {
       cm_cli_end_config_session (cli_session_p->config_session_p,
             CM_CMD_CONFIG_SESSION_REVOKE);
       cli_session_p->config_session_p = NULL;
    }

    return OF_FAILURE;
  }
  of_strncpy (nv_pair.name_p,
             cli_session_p->current_node_p->key_node_info.node_name, nv_pair.name_length);

  nv_pair.value_type = cli_session_p->current_node_p->key_node_info.data_type;
  nv_pair.value_length = of_strlen ((char *) params_p[1].param_value);
  nv_pair.value_p = (char *) of_calloc (1, nv_pair.value_length + 1);
  if (nv_pair.value_p == NULL)
  {
    cm_cli_restore_prompt ();
    of_free (nv_pair.name_p);
    cm_cli_puts (cli_session_p, "Calloc Failed\n\r");
    if(this_session_b)
    {
       cm_cli_end_config_session (cli_session_p->config_session_p,
             CM_CMD_CONFIG_SESSION_REVOKE);
       cli_session_p->config_session_p = NULL;
    }
    return OF_FAILURE;
  }
  of_strcpy (nv_pair.value_p, (char *) params_p[1].param_value);

#endif
  of_strcpy (cli_session_p->context_path, tmp_str_a);

  cli_session_p->context_b = TRUE;

  return_value1=cm_cli_prepare_keys_array_from_token(tmp_str_a,(char *)params_p[1].param_value, &key_nv_pairs_p);

  if (return_value1==OF_SUCCESS)
  {

     for (ii = 0; ii < key_nv_pairs_p->count_ui; ii++)
     {
        if((return_value1 = cm_cli_validate_attribute(&(key_nv_pairs_p->nv_pairs[ii]),NULL) != OF_SUCCESS))
        {
           break;
        }
     }

#ifdef CM_DM_INSTANCE_TREE_DEPENDENCY_ENABLED
     instance_exists_b = cm_dm_is_instance_map_entry_using_key_array_and_name_path (tmp_str_a,
           cli_session_p->tnsprt_channel_p,
           CM_CLI_MGMT_ENGINE_ID,
           &cli_session_p->role_info,
           key_nv_pairs_p);
     if (instance_exists_b == FALSE)
     {
#else
        return_value = cm_get_exact_record (cli_session_p->tnsprt_channel_p,
              CM_CLI_MGMT_ENGINE_ID,
              cli_session_p->role_info.admin_role,
              tmp_str_a,
              key_nv_pairs_p, &out_array_of_nv_pair_arr);
        if (return_value == OF_FAILURE)
        {
           /* Free Outnv_pair_array */
           CM_FREE_PTR_NVPAIR_ARRAY (out_array_of_nv_pair_arr,
                 out_array_of_nv_pair_arr->count_ui);
#endif
           if(this_session_b)
           {
              of_strcat (cli_session_p->context_path, "{");
              of_strcat (cli_session_p->context_path, (char *)params_p[1].param_value);
              of_strcat(temp_path_a,(char *)params_p[1].param_value);
              of_strcat (cli_session_p->context_path, "}");
              of_strcpy (cli_session_p->dmpath_a, tmp_str_a);
              cm_cli_find_directory (temp_path_a, tmp_str_a, FALSE, param_cnt_ui);//This case param_cnt_ui is always 2
              cm_cli_update_prompt (temp_path_a);
              cli_session_p->context_b = TRUE;
           }
           //of_free (NvPair.name_p); CID 552 - NVpair not in use
           cm_cli_puts (cli_session_p, " No instance exists with the entered ID\n\r");
           if(this_session_b)
           {
              cm_cli_end_config_session (cli_session_p->config_session_p,
                    CM_CMD_CONFIG_SESSION_REVOKE);
              cli_session_p->config_session_p = NULL;
           }
           else
              cm_cli_restore_prompt ();

           if(key_nv_pairs_p)
           {
              CM_FREE_PTR_NVPAIR_ARRAY (key_nv_pairs_p, key_nv_pairs_p->count_ui);
           }
           return OF_FAILURE;
        }

        of_strcat (cli_session_p->context_path, "{");
        if(key_nv_pairs_p->count_ui == 1)
        {
           of_strcat (cli_session_p->context_path, key_nv_pairs_p->nv_pairs[0].value_p);
           of_strcat(temp_path_a,key_nv_pairs_p->nv_pairs[0].value_p);
        }
        else
        {
           for(ii=0; ii < key_nv_pairs_p->count_ui ; ii++)
           {
              of_strcat (cli_session_p->context_path, key_nv_pairs_p->nv_pairs[ii].name_p);
              of_strcat(temp_path_a, key_nv_pairs_p->nv_pairs[ii].name_p);

              of_strcat (cli_session_p->context_path, "=");
              of_strcat(temp_path_a, "=");

              of_strcat (cli_session_p->context_path, key_nv_pairs_p->nv_pairs[ii].value_p);
              of_strcat(temp_path_a, key_nv_pairs_p->nv_pairs[ii].value_p);
              if(ii+1 < key_nv_pairs_p->count_ui)
              {
                 of_strcat(temp_path_a, ",");
                 of_strcat (cli_session_p->context_path, ",");
              }
           }
        }

        of_strcat (cli_session_p->context_path, "}");

        if(out_array_of_nv_pair_arr)
        {
           CM_FREE_PTR_NVPAIR_ARRAY (out_array_of_nv_pair_arr,
                 out_array_of_nv_pair_arr->count_ui);
        }
     }
     else
     {
        sprintf (buff_a, " Node does not exist for DMPath(%s)\n\r", tmp_str_a);
        cm_cli_puts (cli_session_p, buff_a);
        return OF_FAILURE;
     }
     cm_cli_fill_command_info (CM_CMD_DEL_PARAMS, cli_session_p->context_path, key_nv_pairs_p->count_ui, key_nv_pairs_p->nv_pairs,
           &command_info);

     /* Fill Command Info structure */
     if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info,
              &result_p) == OF_FAILURE)
     {
        cm_cli_restore_prompt ();
        //   CM_FREE_NVPAIR (nv_pair); CID 552
        if (result_p)
        {
           cm_cli_display_result (result_p);
           UCMFreeUCMResult (result_p);
        }
        if(this_session_b)
        {
           cm_cli_end_config_session (cli_session_p->config_session_p,
                 CM_CMD_CONFIG_SESSION_REVOKE);
           cli_session_p->config_session_p = NULL;
        }
        if(key_nv_pairs_p)
        {
           CM_FREE_PTR_NVPAIR_ARRAY (key_nv_pairs_p, key_nv_pairs_p->count_ui);
        }
        return OF_FAILURE;
     }

     //  CM_FREE_NVPAIR (nv_pair); - CID 552
     if (result_p)
     {
        UCMFreeUCMResult (result_p);
     }

     of_strcpy (cli_session_p->dmpath_a, tmp_str_a);
     cm_cli_find_directory (temp_path_a, tmp_str_a, FALSE, param_cnt_ui);//This case param_cnt_ui is always 2
     cm_cli_update_prompt (temp_path_a);
     cli_session_p->context_b = TRUE;
     if(cli_session_p->cd_table_b == TRUE)
     {
        cli_session_p->no_of_cds++;
     }

     if(key_nv_pairs_p)
     {
        CM_FREE_PTR_NVPAIR_ARRAY (key_nv_pairs_p, key_nv_pairs_p->count_ui);
     }
     cm_cli_puts (cli_session_p, " Enter commit/revoke to complete the session.\n\r");
     return OF_SUCCESS;
  }

/***************************************************************************
 * Function Name : cm_cli_display_session
 * Description   : This Callback API is used to feth the information present
 *                 in the Config Session and Displays it. This will check
 *                 whether config session exists or not, if exists displays
 *                 the Session information.
 * Input         : cli_session_p - Cli Session.
 *                 params_p - Command line parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_session (struct cm_cli_session * cli_session_p,
                              struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_result *result_p = NULL;
   struct cm_command command_info;
   int32_t return_value;

   if (!(cli_session_p))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   /* If config session exists, display config session. */
   if (cli_session_p->config_session_p)
   {
      /* Fill Command structure */
      cm_cli_fill_command_info (CM_CMD_GET_CONFIG_SESSION,
            cli_session_p->dmpath_a, 0, NULL, &command_info);

      /* Invoke Update Config session */
      return_value = cm_config_session_get_cmd (cli_session_p->config_session_p,
            &command_info, &result_p);
      if (return_value == OF_FAILURE)
      {
         /* Based on the input present in the result_p display the error message */
         if (result_p)
         {
            cm_cli_display_result (result_p);
            UCMFreeUCMResult (result_p);
         }
         return OF_FAILURE;
      }

      if (result_p)
      {
         cm_cli_display_config_session ((struct cm_array_of_commands *) result_p->data.je_data_p);
         UCMFreeUCMResult (result_p);
      }
   }
   else
   {
      cm_cli_puts (cli_session_p, "\r No Configuration Session exists.\n\r");
   }

   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_record_with_arguments 
 * Description   : Used to display value set for a particular record based on 
                   requested record key.
 * Input         : dm_path_p - DM path.
 *                 params_p - Name of the Scalar variable whose value should
 *                            be displayed
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_record_with_arguments(char *dm_path_p, struct cm_cli_params * params_p, uint32_t param_cnt_ui,
                                                                             unsigned char is_table_b) 

{
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_dm_node_info *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   struct cm_array_of_nv_pair nv_pair_array;
   struct cm_nv_pair *tmp_nv_pair_p = NULL;
   uint32_t ii = 0, jj = 0;
   uint32_t index_i = 0;
   char param_a1[CM_CLI_MAX_NAME_LEN + 1];
   unsigned char found_b = FALSE;
   char *tmp_dm_path_p = NULL;  
   int32_t return_value=OF_FAILURE;


   of_memset(&nv_pair_array,0,sizeof(struct cm_array_of_nv_pair));
   of_memset(param_a1,0,CM_CLI_MAX_NAME_LEN +1);


   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            dm_path_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   for ( ii = 1 ; ii < param_cnt_ui ; ii = ii + 2)
   {
      if(of_strlen((char *) params_p[ii].param_value) > CM_CLI_MAX_NAME_LEN)
      {
         sprintf (buff_a, " Invalid parameter: %s\r\n",(char *) params_p[ii].param_value);
         cm_cli_puts (cli_session_p, buff_a);
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }

      of_strcpy(param_a1,(char *) params_p[ii].param_value);

      for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
      {
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
         if(of_strcmp(tmp_node_info_p->name_p,param_a1)==0)
         {
            found_b = FALSE;
            if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR)
            {
               found_b = TRUE;
               break;
            }
         }
      }

      if(found_b == FALSE)
      {
         sprintf (buff_a, " Invalid parameter: %s\r\n",param_a1);
         cm_cli_puts (cli_session_p, buff_a);
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }
   }

   cm_cli_free_node_info(node_info_p);
   cm_cli_cleanup_array_of_node_info(child_info_arr_p);

   /* Get number of Name-Value pairs */
   nv_pair_array.count_ui = (param_cnt_ui-1)/2 ;

   /* Allocate memory for Name-Value pairs */
   nv_pair_array.nv_pairs = (struct cm_nv_pair *) of_calloc (nv_pair_array.count_ui,
         sizeof (struct cm_nv_pair));
   if (nv_pair_array.nv_pairs == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed for nv_pairs\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Fill Name-Value pairs */
   tmp_nv_pair_p = nv_pair_array.nv_pairs;
   for (ii = 1, jj = 0; jj < nv_pair_array.count_ui; jj++)
   {
      /* Copy Name Len */
      tmp_nv_pair_p[jj].name_length = of_strlen ((char *) params_p[ii].param_value);

      /* Copy Name */
      tmp_nv_pair_p[jj].name_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].name_length + 1);
      if (tmp_nv_pair_p[jj].name_p == NULL)
      {
         /* Free all the nv_pairs */
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }

      of_memcpy (tmp_nv_pair_p[jj].name_p, (char *) params_p[ii++].param_value,
            tmp_nv_pair_p[jj].name_length);

      /* Copy Value Length  */
      tmp_nv_pair_p[jj].value_length = of_strlen ((char *) params_p[ii].param_value);

      /* Copy Value */
      tmp_nv_pair_p[jj].value_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].value_length + 1);
      if (tmp_nv_pair_p[jj].value_p == NULL)
      {
         /* Free all the nv_pairs */
         of_free (tmp_nv_pair_p[jj].name_p);
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }
      of_memcpy (tmp_nv_pair_p[jj].value_p, (char *) params_p[ii++].param_value,
            tmp_nv_pair_p[jj].value_length);
   }

   tmp_dm_path_p = of_calloc(1, of_strlen(dm_path_p)+CM_CLI_MAX_NAME_LEN+1);  
   of_strcpy(tmp_dm_path_p,dm_path_p);

   for (ii = 0; ii < nv_pair_array.count_ui; ii++)
   {
      of_strcpy(tmp_dm_path_p,dm_path_p);
      of_strcat(tmp_dm_path_p,".");
      of_strcat(tmp_dm_path_p,nv_pair_array.nv_pairs[ii].name_p);
      return_value = cm_cli_validate_attribute (&nv_pair_array.nv_pairs[ii], tmp_dm_path_p);
      if (return_value == OF_FAILURE)
      {
         sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
               (char *)nv_pair_array.nv_pairs[ii].value_p, nv_pair_array.nv_pairs[ii].name_p);
         cm_cli_puts(cli_session_p, buff_a);
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
         of_free(tmp_dm_path_p);
         return OF_FAILURE;
      }
   } 

   of_free(tmp_dm_path_p);

   if(is_table_b == TRUE)
   {
      if (cm_cli_display_records_of_table (dm_path_p, &nv_pair_array, FALSE) != OF_SUCCESS)
      {
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
         return OF_FAILURE;
      }
   }
   else
   {
      if (cm_cli_display_records_of_scalar(dm_path_p,NULL, FALSE, NULL, is_table_b, &nv_pair_array) == OF_SUCCESS)
      {
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
         return OF_FAILURE;
      }
   }

   CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_scalar_param_value
 * Description   : Used to display value set for a scalar variable when used
 *        with show command. ex: show sharedsecret
 * Input         : dm_path_p - DM path.
 *                 param_name_p - Name of the Scalar variable whose value should
 *                            be displayed
 *                 keys_array_p - NV Pair array
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_scalar_param_value (char * dm_path_p, char *param_name_p,
      struct cm_array_of_nv_pair *keys_array_p)
{
   struct cm_cli_session *tmp_cli_session_p = cli_session_p;
   struct cm_array_of_nv_pair *out_nv_pair_array_p = NULL, *temp_keys_array_p = NULL;
   struct cm_array_of_nv_pair prev_rec_key_arr={};
   struct cm_dm_node_info *node_info_p = NULL, *tmp_node_info_p;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   uint32_t count_ui = 1;
   char tmp_dmpath_a[CM_DM_MAX_PATH_LEN + 1];
   int32_t return_value, ii, nv_cnt_i;
   unsigned char param_found_b = FALSE;

   /* Get Node and Child info */
   if (cm_dm_get_node_and_child_info (tmp_cli_session_p->tnsprt_channel_p,
            dm_path_p, CM_CLI_MGMT_ENGINE_ID,
            &tmp_cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Call GetFirstNrecords */
   return_value = cm_get_first_n_records (cli_session_p->tnsprt_channel_p,
         CM_CLI_MGMT_ENGINE_ID,
         cli_session_p->role_info.admin_role,
         dm_path_p,
         keys_array_p, &count_ui, &out_nv_pair_array_p);
   if ((return_value == OF_FAILURE) || (count_ui == 0))
   {
      cm_cli_puts (cli_session_p, " No records exist.\n\r");
      return OF_SUCCESS;
   }

   for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
      if(tmp_node_info_p->element_attrib.key_b == TRUE)
      {
         of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
         of_strcpy(tmp_dmpath_a, dm_path_p);
         of_strcat(tmp_dmpath_a, "{");
         for (nv_cnt_i=0; nv_cnt_i < out_nv_pair_array_p->count_ui; nv_cnt_i++)
         {
            if (of_strcmp (out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p, tmp_node_info_p->name_p) == 0)
            {
               of_strcat(tmp_dmpath_a, (char *)out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_p);
               param_found_b = TRUE;
               break;
            }
         }
         if(param_found_b == TRUE)
         {
            param_found_b = FALSE;
            of_strcat(tmp_dmpath_a, "}");
            if(of_strcmp(tmp_dmpath_a, tmp_cli_session_p->context_path) == 0 )
            {
               param_found_b = TRUE;
               break;
            }
         }
         else
         {
            of_memset(buff_a, 0, sizeof(buff_a));
            sprintf(buff_a, " Could not find the record with \"%s\"\n\r",
                  cli_session_p->context_path);
            cm_cli_puts (cli_session_p, buff_a);
            break;
         }
         if(param_found_b == FALSE) //Get the next record
         {
            cm_cli_get_prev_record_key_array (&out_nv_pair_array_p[count_ui - 1], &prev_rec_key_arr, dm_path_p, FALSE);
            CM_FREE_PTR_ARRAY_OF_NVPAIR_ARRAY (out_nv_pair_array_p, count_ui);
            out_nv_pair_array_p = NULL;

            return_value = cm_get_next_n_records (cli_session_p->tnsprt_channel_p,
                  CM_CLI_MGMT_ENGINE_ID, cli_session_p->role_info.admin_role,
                  dm_path_p, &prev_rec_key_arr, keys_array_p,
                  &count_ui, &out_nv_pair_array_p);
            if ((return_value != OF_SUCCESS))
            {
               of_memset(buff_a, 0, sizeof(buff_a));
               sprintf(buff_a, " Could not find the record \"%s\"\n\r",
                     cli_session_p->context_path);
               cm_cli_puts (cli_session_p, buff_a);
               return OF_FAILURE;
            }
            else
            {
               ii = 0;
            }
         }
      }
   }
   param_found_b = FALSE;
   for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
      if((of_strcmp(tmp_node_info_p->name_p, param_name_p) == 0) ||
            ((tmp_node_info_p->element_attrib.cli_identifier_p) &&
             (of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, param_name_p)==0)) )
      {
         param_found_b = TRUE;
         break;
      }
   }
   if(param_found_b == FALSE)
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a, " Could not find the parameter \"%s\"\n\r",
            param_name_p);
      cm_cli_puts (cli_session_p, buff_a);
      if(out_nv_pair_array_p)
      {
         CM_FREE_PTR_ARRAY_OF_NVPAIR_ARRAY (out_nv_pair_array_p, count_ui);
         out_nv_pair_array_p = NULL;
      }
      return OF_FAILURE;
   }

   param_found_b = FALSE;
   for (nv_cnt_i=0; nv_cnt_i < out_nv_pair_array_p->count_ui; nv_cnt_i++)
   {
      if (of_strcmp (out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p, tmp_node_info_p->name_p)==0)
         //param_name_p) == 0)
      {
         param_found_b = TRUE;
         break;
      }
   }
   if(param_found_b == FALSE)
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a, " Could not find value for the parameter \"%s\"\n\r",
            param_name_p);
      cm_cli_puts (cli_session_p, buff_a);
      if(out_nv_pair_array_p)
      {
         CM_FREE_PTR_ARRAY_OF_NVPAIR_ARRAY (out_nv_pair_array_p, count_ui);
         out_nv_pair_array_p = NULL;
      }
      return OF_FAILURE;
   }

   temp_keys_array_p=(struct cm_array_of_nv_pair *)of_calloc(1,sizeof(struct cm_array_of_nv_pair));
   temp_keys_array_p->count_ui = 1;
   temp_keys_array_p->nv_pairs=(struct cm_nv_pair *) of_calloc(temp_keys_array_p->count_ui,
         sizeof(struct cm_nv_pair));
   temp_keys_array_p->nv_pairs[0].name_length = out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_length;
   temp_keys_array_p->nv_pairs[0].value_length = out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_length;
   temp_keys_array_p->nv_pairs[0].identifier_len_ui = out_nv_pair_array_p->nv_pairs[nv_cnt_i].identifier_len_ui;
   if(temp_keys_array_p->nv_pairs[0].name_length > 0)
   {
      temp_keys_array_p->nv_pairs[0].name_p = (char *) of_calloc (1,out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_length + 1);
      if(temp_keys_array_p->nv_pairs[0].name_p)
      {
         of_strcpy (temp_keys_array_p->nv_pairs[0].name_p,  out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p);
      }
   }

   if(temp_keys_array_p->nv_pairs[0].value_length > 0)
   {
      temp_keys_array_p->nv_pairs[0].value_p = (char *) of_calloc (1,out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_length + 1);
      if(temp_keys_array_p->nv_pairs[0].value_p)
      {
         of_strcpy (temp_keys_array_p->nv_pairs[0].value_p,  out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_p);
      }
   }

   if(temp_keys_array_p->nv_pairs[0].identifier_len_ui > 0)
   {
      temp_keys_array_p->nv_pairs[0].cli_identifier_p = (char *) of_calloc (1,out_nv_pair_array_p->nv_pairs[nv_cnt_i].identifier_len_ui + 1);
      if(temp_keys_array_p->nv_pairs[0].cli_identifier_p)
      {
         of_strcpy (temp_keys_array_p->nv_pairs[0].cli_identifier_p,  out_nv_pair_array_p->nv_pairs[nv_cnt_i].cli_identifier_p);
      }
   }

   // Display the received information 
   //cm_cli_puts (cli_session_p, "\t{");
   cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_START_DELIMITER );
   cm_cli_display_nv_pair(temp_keys_array_p->count_ui, temp_keys_array_p,dm_path_p);
//   cm_cli_puts (cli_session_p, CM_CLI_SHOW_RECORD_DELIMITER);
   cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_END_DELIMITER );
   //cm_cli_puts (cli_session_p, "\n\r");
   if(temp_keys_array_p)
   {
      count_ui = temp_keys_array_p->count_ui; 
      CM_FREE_PTR_ARRAY_OF_NVPAIR_ARRAY (temp_keys_array_p, count_ui);
      temp_keys_array_p = NULL;
   }
   return OF_SUCCESS;
}
/***************************************************************************
 * Function Name : cm_cli_display_records
 * Description   : This callback API is invoked when user enters 'show'
 *                 command on the command line interface.Based on the DM path
 *                 this will get all the records of a particular Security
 *                 Application. 
 * Input         : cli_session_p - Cli Session pointer
 *                 params_p - pointer to input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ===========================================================================
 Show ?              Show all the variable names at current path
 Show <name>         Show the value of the entered variable name
 Show <table_anchor> Show the table
 Show <table_anchor{key}>  Show the entered row in detail
 show <name>        Show only immediate values
 showall  <name>    Show all children nodes, values
 ***************************************************************************/
int32_t cm_cli_display_records (struct cm_cli_session * cli_session_p,
                              struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   int32_t return_value;
   UCMDllQNode_t *dll_q_node_p;
   struct cm_cli_data_ele_node *data_ele_node_p, *child_node_p;
   struct cm_cli_session *tmp_cli_session_p;
   struct cm_array_of_nv_pair keys_array = {0};
   struct cm_array_of_nv_pair *keys_array_p = NULL;
   char param_a1[CM_CLI_MAX_NAME_LEN + 1],param_a2[CM_CLI_MAX_NAME_LEN + 1];
   char dir_path_a[CM_CLI_MAX_PROMPT_LEN + 1], dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];
   char tmp_dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];
   uint32_t len_ui = 0;
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_dm_node_info *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   unsigned char sca_grp_b=FALSE;
   unsigned char found_b = FALSE;
   int32_t  index_i;
   int32_t  ii;
   char *tmp_dm_path_p = NULL;
   unsigned char parent_is_table_p = FALSE;

   /* Validate input */
   if (!(cli_session_p) || !(params_p))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   tmp_cli_session_p = cli_session_p;
   of_memset (param_a1, 0, sizeof (param_a1));
   of_memset (param_a2, 0, sizeof (param_a2));

   if (param_cnt_ui == 1)
   {
      of_strcpy (param_a1, (char *) params_p[0].param_value);
   }
   else if (param_cnt_ui >= 2)
   {
      of_strcpy (param_a1, (char *) params_p[0].param_value);
      of_strcpy (param_a2, (char *) params_p[1].param_value);
   }

   of_memset (dmpath_a, 0, sizeof(dmpath_a));
   of_memset (tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
   of_memset (dir_path_a, 0, sizeof(dir_path_a));
   of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);

   if (cm_dm_get_node_and_child_info (tmp_cli_session_p->tnsprt_channel_p,
            tmp_cli_session_p->dmpath_a,
            CM_CLI_MGMT_ENGINE_ID,
            &tmp_cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   if(node_info_p->element_attrib.element_type  == CM_DMNODE_TYPE_TABLE )
      parent_is_table_p = TRUE;
   else
      parent_is_table_p = FALSE;
   if(param_cnt_ui != 0)
   {
      for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
      {
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
         if((of_strcmp(tmp_node_info_p->name_p,param_a1)==0) || 
               ((tmp_node_info_p->element_attrib.cli_identifier_p)
                && (of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, param_a1) == 0)) )
         {
            found_b = TRUE;
            if ((node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE) && 
                  (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR))
            {
               of_strcpy(tmp_dmpath_a, tmp_cli_session_p->context_path);
               if ((tmp_node_info_p->element_attrib.cli_identifier_p)
                     && (of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, param_a1) == 0))
               {
                  if(cm_cli_display_records_of_scalar(tmp_dmpath_a,params_p,TRUE,
                           tmp_node_info_p->name_p, parent_is_table_p,NULL)==OF_SUCCESS)
                  {
                     return OF_SUCCESS;
                  }
                  else
                  {
                     return OF_FAILURE;
                  }
               }
               else
               {
                  if(cm_cli_display_records_of_scalar(tmp_dmpath_a,params_p,FALSE,NULL,parent_is_table_p,NULL)==OF_SUCCESS)
                  {
                     return OF_SUCCESS;
                  }
                  else
                  {
                     return OF_FAILURE;
                  }
               }
            }
            if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR)
            {
               if(tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
               {
                  if(param_cnt_ui == 1 || param_cnt_ui%2 == 1)
                  {
                     if(tmp_cli_session_p->context_b)
                     {
                        cm_cli_get_dir_path (dir_path_a);
                        cm_cli_convert_dir_to_dmpath (dir_path_a, dmpath_a);
                     }

                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, param_a1);

                     if (param_cnt_ui != 1)
                     {
                        if(cm_cli_display_record_with_arguments(dmpath_a,params_p,param_cnt_ui,FALSE) != OF_SUCCESS)
                        {
                           return OF_FAILURE;
                        }
                     }
                     else
                     {
                        if (cm_cli_display_records_of_scalar(dmpath_a,NULL, FALSE, NULL, parent_is_table_p,NULL) == OF_SUCCESS)
                        {
                           return OF_SUCCESS;
                        }
                        else
                        {
                           return OF_FAILURE;
                        }
                     }
                     break;
                  }
                  else
                  {
                     cm_cli_puts (cli_session_p, " Invalid command.\n\r");
                     return OF_FAILURE;
                  }
               }
               else
               {
                  cm_cli_puts (cli_session_p, " This anchor do not have any scalar group.\n\r");
                  return OF_FAILURE;
               }
            }
            break;
         }
      }
   } 

   if(found_b != TRUE && of_strlen(param_a1) > 0)
   {
      cm_cli_puts (cli_session_p, " Invalid command.\n\r");
      return OF_FAILURE; 
   }

   switch (tmp_cli_session_p->current_node_p->node_type_ui)
   {
      case CM_DMNODE_TYPE_ANCHOR:
         {
            if (!(param_cnt_ui))
            {
               /* Display all the Instances of All the Tables for this Anchor */
               if (cm_cli_display_instances_and_key_params (NULL,FALSE) == OF_FAILURE)
               {
                  cm_cli_puts (cli_session_p, " No instances exist.\n\r");
               }
               return OF_SUCCESS;
            }
            else if (param_cnt_ui == 1)
            {
               /* If some name is entered display the row(s) of that Particular table */
               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     if (data_ele_node_p->node_type == CM_DMNODE_TYPE_SCALAR_VAR)
                     {
                        if (tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
                        {
                           sca_grp_b = TRUE;
                        }
                     }
                     if(sca_grp_b !=TRUE)
                     {
                        of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
                        of_strcat (dmpath_a, ".");
                        of_strcat (dmpath_a, data_ele_node_p->node_name);
                        cm_cli_display_records_of_scalar(dmpath_a,NULL, FALSE, NULL, parent_is_table_p,NULL);
                        break;
                     }
                     else
                     {
                        of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
                        return_value = cm_cli_display_records_of_scalar(dmpath_a,params_p,FALSE,NULL,parent_is_table_p,NULL);
                        break;
                     }
                  }
               }
               found_b = FALSE;
               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     found_b = TRUE;    
                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, param_a1);
                     if (cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE) == OF_SUCCESS)
                     {
                        return OF_SUCCESS;
                     }
                     else
                     {
                        return_value = OF_FAILURE;
                     }
                     break;
                  }
               }
               if(found_b = FALSE)
                  return_value = OF_FAILURE;
               if(return_value == OF_FAILURE)
               {
                  cm_cli_puts (cli_session_p, " Failed to display the records.\n\r");
                  return OF_FAILURE;
               }
               else
                  return OF_SUCCESS;
            }
            else if (param_cnt_ui == 2)
            {
               /* This case is we had 2 params, the Table Name and RecordName */
               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     /* Frame DMPath  */
                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, param_a1);

                     return_value=cm_cli_prepare_keys_array_from_token(dmpath_a,(char *)params_p[1].param_value, &keys_array_p);

                     if (return_value ==OF_SUCCESS)
                     {
                        tmp_dm_path_p = of_calloc(1, of_strlen(dmpath_a)+CM_CLI_MAX_NAME_LEN+1);
                        of_strcpy(tmp_dm_path_p,dmpath_a);

                        for (ii = 0; ii < keys_array_p->count_ui; ii++)
                        {
                           of_strcpy(tmp_dm_path_p,dmpath_a);
                           of_strcat(tmp_dm_path_p,".");
                           of_strcat(tmp_dm_path_p,keys_array_p->nv_pairs[ii].name_p);

                           if((return_value = cm_cli_validate_attribute(&(keys_array_p->nv_pairs[ii]),tmp_dm_path_p) != OF_SUCCESS))
                           {
                              sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
                                    (char *)keys_array_p->nv_pairs[ii].value_p, keys_array_p->nv_pairs[ii].name_p);
                              cm_cli_puts(cli_session_p, buff_a);
                              of_free(tmp_dm_path_p);
                              return OF_FAILURE;
                           }
                        } 
                        of_free(tmp_dm_path_p);
                        tmp_dm_path_p = NULL;


                        of_strcat (dmpath_a, "{");
                        if(keys_array_p->count_ui == 1)
                        {
                           of_strcat(dmpath_a,keys_array_p->nv_pairs[0].value_p);
                        }
                        else
                        {
                           for(ii=0; ii < keys_array_p->count_ui ; ii++)
                           {
                              of_strcat(dmpath_a, keys_array_p->nv_pairs[ii].name_p);
                              of_strcat(dmpath_a, "=");
                              of_strcat(dmpath_a, keys_array_p->nv_pairs[ii].value_p);
                              if(ii+1 < keys_array_p->count_ui)
                              {
                                 of_strcat(dmpath_a, ",");
                              }
                           }
                        }
                     }
                     else
                     {
                        return OF_FAILURE;
                     }

                     /*              of_strcat (dmpath_a, param_a2);*/
                     of_strcat (dmpath_a, "}");

                     if (cm_cli_display_records_of_table (dmpath_a, keys_array_p, TRUE) == OF_SUCCESS)
                     {
                        return OF_SUCCESS;
                     }
                     break;
                  }
               }
               cm_cli_puts (cli_session_p, " No matching record with the entered key value.\n\r");
               return OF_FAILURE;
            }
            else
            {
               if(param_cnt_ui%2 == 0)
               {
                  sprintf (buff_a, " Invalid number of parameters.\r\n");
                  cm_cli_puts (cli_session_p, buff_a);
                  return OF_FAILURE;
               }

               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     if (data_ele_node_p->node_type != CM_DMNODE_TYPE_TABLE)
                     {
                        sprintf (buff_a, " Invalid Command.");
                        cm_cli_puts (cli_session_p, buff_a);
                        return OF_FAILURE;
                     }
                     /* Frame DMPath  */
                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, param_a1);
                     if(cm_cli_display_record_with_arguments(dmpath_a,params_p,param_cnt_ui,TRUE) != OF_SUCCESS)
                     {
                        return OF_FAILURE;
                     }

                  }
               }
            }
         }
         break;

      case CM_DMNODE_TYPE_TABLE:
         {
            len_ui = of_strlen(dmpath_a);
            if (!(param_cnt_ui))
            {
               /* Display all the records of this Table */

               if(len_ui > 0 && dmpath_a[len_ui - 1] == '}')
               {
                  if (cm_cli_display_records_of_table (dmpath_a, &keys_array, TRUE) == OF_SUCCESS)
                  {
                     return OF_SUCCESS;
                  }
               }
               else
               {
                  //if (cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE) == OF_SUCCESS)
                  len_ui = of_strlen(tmp_cli_session_p->context_path);
                  if(len_ui > 0 && tmp_cli_session_p->context_path[len_ui-1] == '}')
                  {
                     if (cm_cli_display_records_of_table (tmp_cli_session_p->context_path, &keys_array, TRUE) == OF_SUCCESS)
                     {
                        return OF_SUCCESS;
                     }
                  }
                  else
                  {
                     if (cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE) == OF_SUCCESS)
                     {
                        return OF_SUCCESS;
                     }
                  }
               }
               return OF_FAILURE;
            }
            else if (param_cnt_ui == 1)
            {
               if (tmp_cli_session_p->context_b)
               {
                  CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
                        UCMDllQNode_t *)
                  {
                     data_ele_node_p =
                        CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                              list_node);
                     if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                     {
                        return_value = cm_cli_display_param_value (param_a1);
                        if (return_value == OF_FAILURE)
                        {
                           sprintf (buff_a, " Failed to fetch parameter (%s)\'s value.\r\n",
                                 param_a1);
                           cm_cli_puts (cli_session_p, buff_a);
                           return OF_FAILURE;
                        }
                        return OF_SUCCESS;
                     }
                  }

                  CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                        UCMDllQNode_t *)
                  {
                     child_node_p =
                        CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                              list_node);
                     if (of_strcmp (param_a1, child_node_p->node_name) == 0)
                     {
                        cm_cli_get_dir_path (dir_path_a);
                        cm_cli_convert_dir_to_dmpath (dir_path_a, dmpath_a);
                        of_strcat(dmpath_a, ".");
                        of_strcat(dmpath_a, child_node_p->node_name);

                        if (cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE) == OF_SUCCESS)
                        {
                           return OF_SUCCESS;
                        }
                     }
                  }
                  cm_cli_puts (cli_session_p, " No parameter exists with the entered name.\n\r");
               }
               else
               {
                  /* Record name is entered. Frame DM path and get the record and
                   * display it.*/
                  if(dmpath_a[len_ui - 1] == '}')
                  {
#if 0
                     keys_array.count_ui = 1;
                     return_value = cm_cli_get_keys_array(dmpath_a, &keys_array, NULL);
                     if(return_value == OF_FAILURE)
                     {
                        CM_FREE_NVPAIR_ARRAY(keys_array, 1);
                        return OF_FAILURE;
                     }
#endif
                     CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                           UCMDllQNode_t *)
                     {
                        child_node_p =
                           CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                                 list_node);
                        if (of_strcmp (param_a1, child_node_p->node_name) == 0)
                        {
                           of_strcat(dmpath_a, ".");
                           of_strcat(dmpath_a, child_node_p->node_name);

                           if (cm_cli_display_records_of_table (dmpath_a, &keys_array, FALSE) == OF_SUCCESS)
                           {
                              return OF_SUCCESS;
                           }
                        }
                     }

                  }
                  else
                  {
                     cm_cli_puts (cli_session_p, " To display records of a table, have to get into one of its instance.\n\r");
                     return OF_SUCCESS;
#if 0
                     Rawoof
                        keys_array.count_ui = 1;
                     return_value = cm_cli_get_keys_array(dmpath_a, &keys_array, param_a1);
                     if(return_value == OF_FAILURE)
                     {
                        CM_FREE_NVPAIR_ARRAY(keys_array, 1);
                        return OF_FAILURE;
                     }
                     of_strcat (dmpath_a, "{");
                     of_strcat (dmpath_a, param_a1);
                     of_strcat (dmpath_a, "}");
                     if (cm_cli_display_records_of_table (dmpath_a, &keys_array, TRUE) == OF_SUCCESS)
                     {
                        return OF_SUCCESS;
                     }
#endif 
                  }

                  cm_cli_puts (cli_session_p, " Failed to fetch the record.\n\r");
                  return OF_FAILURE;
               }
            }
            else if (param_cnt_ui == 2)
            {
               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                           list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     cm_cli_puts (cli_session_p, " Invalid number of parameters.\n\r");
                     return OF_SUCCESS;
                  }
               }           

               if (tmp_cli_session_p->context_b)
               {
                  CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                        UCMDllQNode_t *)
                  {
                     child_node_p =
                        CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                              list_node);
                     if (of_strcmp (param_a1, child_node_p->node_name) == 0)
                     {
                        if(data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR)
                        {
                           cm_cli_puts (cli_session_p, " Invalid number of parameters.\n\r");
                           return OF_SUCCESS;
                        }
                        cm_cli_get_dir_path (dir_path_a);
                        cm_cli_convert_dir_to_dmpath (dir_path_a, dmpath_a);
                        of_strcat(dmpath_a, ".");
                        of_strcat(dmpath_a, child_node_p->node_name);
                        //This will contain the DM Path as "igd.vsg{general}.tcm.toolset{ts1}.tools"

                     }
                  }
               }
               else 
               {
                  if(dmpath_a[len_ui - 1] == '}')
                  {
                     CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                           UCMDllQNode_t *)
                     {
                        data_ele_node_p =
                           CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                        if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                        {
                           if(data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR)
                           {
                              cm_cli_puts (cli_session_p, " Invalid number of parameters.\n\r");
                              return OF_SUCCESS;
                           }
                           /* Frame DMPath  */
                           of_strcat (dmpath_a, ".");
                           of_strcat (dmpath_a, param_a1);
                           //This will contain the DM Path as "igd.vsg{general}.tcm.toolset.tools"
                           break;
                        }
                     }
                  }
                  else
                  {
                     cm_cli_puts (cli_session_p, " To display records of a table, have to get into one of its instance.\n\r");
                     return OF_SUCCESS;
                  }
               }
               return_value =cm_cli_prepare_keys_array_from_token(dmpath_a,(char *)params_p[1].param_value, &keys_array_p);

               if (return_value ==OF_SUCCESS)
               {
                  tmp_dm_path_p = of_calloc(1, of_strlen(dmpath_a)+CM_CLI_MAX_NAME_LEN+1);
                  of_strcpy(tmp_dm_path_p,dmpath_a);

                  for (ii = 0; ii < keys_array_p->count_ui; ii++)
                  {
                     of_strcpy(tmp_dm_path_p,dmpath_a);
                     of_strcat(tmp_dm_path_p,".");
                     of_strcat(tmp_dm_path_p,keys_array_p->nv_pairs[ii].name_p);

                     if((return_value = cm_cli_validate_attribute(&(keys_array_p->nv_pairs[ii]),tmp_dm_path_p) != OF_SUCCESS))
                     {
                        sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
                              (char *)keys_array_p->nv_pairs[ii].value_p, keys_array_p->nv_pairs[ii].name_p);
                        cm_cli_puts(cli_session_p, buff_a);
                        of_free(tmp_dm_path_p);
                        return OF_FAILURE;
                     }
                  }
                  of_free(tmp_dm_path_p);
                  tmp_dm_path_p = NULL;

                  of_strcat (dmpath_a, "{");
                  if(keys_array_p->count_ui == 1)
                  {
                     of_strcat(dmpath_a,keys_array_p->nv_pairs[0].value_p);
                  }
                  else
                  {
                     for(ii=0; ii < keys_array_p->count_ui ; ii++)
                     {
                        of_strcat(dmpath_a, keys_array_p->nv_pairs[ii].name_p);
                        of_strcat(dmpath_a, "=");
                        of_strcat(dmpath_a, keys_array_p->nv_pairs[ii].value_p);
                        if(ii+1 < keys_array_p->count_ui)
                        {
                           of_strcat(dmpath_a, ",");
                        }
                     }
                  }
               }
               else
               {
                  return OF_FAILURE;
               }

               of_strcat (dmpath_a, "}");

               if (cm_cli_display_records_of_table (dmpath_a, keys_array_p, TRUE) == OF_SUCCESS)
               {
                  return OF_SUCCESS;
               }
               return OF_SUCCESS;
            }
            else
            {
               if(param_cnt_ui%2 == 0)
               {
                  sprintf (buff_a, " Invalid number of parameters.\r\n");
                  cm_cli_puts (cli_session_p, buff_a);
                  return OF_FAILURE;
               }

               CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
                     UCMDllQNode_t *)
               {
                  data_ele_node_p =
                     CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *, list_node);
                  if (of_strcmp (param_a1, data_ele_node_p->node_name) == 0)
                  {
                     if (data_ele_node_p->node_type != CM_DMNODE_TYPE_TABLE)
                     {
                        sprintf (buff_a, " Invalid Command.");
                        cm_cli_puts (cli_session_p, buff_a);
                        return OF_FAILURE;
                     }
                     /* Frame DMPath  */
                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, param_a1);
                     if(cm_cli_display_record_with_arguments(dmpath_a,params_p,param_cnt_ui,TRUE) != OF_SUCCESS)
                     {
                        return OF_FAILURE;
                     }
                  }
               }
            }
         }
   }

   return OF_SUCCESS;
}

#ifdef CM_STATS_COLLECTOR_SUPPORT
/***************************************************************************
 * Function Name : cm_cli_display_statistics
 * Description   : This callback API is invoked when user enters 'show'
 *                 command on the command line interface for statistics.Based on the DM path
 *                 this will get all the records of a particular statistics 
                   of a Security Application. 
 * Input         : cli_session_p - Cli Session pointer
 *                 params_p - pointer to input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
***************************************************************************/
int32_t cm_cli_display_statistics (struct cm_cli_session * cli_session_p,
                            struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   char param_a1[CM_CLI_MAX_NAME_LEN + 1];
   char stats_type_a[CM_CLI_MAX_NAME_LEN + 1];
   char node_a[CM_CLI_MAX_NAME_LEN + 1];
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];
   int32_t return_value = OF_FAILURE;
   uint32_t rec_count_ui =0,sub_command_id,index_i;
   unsigned char found_b = FALSE;
   struct cm_array_of_nv_pair *out_array_of_nv_pair_arr=NULL;
   struct cm_array_of_nv_pair key_nv_pairs;
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   struct cm_dm_node_info *tmp_node_info_p = NULL;

   of_memset (&key_nv_pairs,0,sizeof(struct cm_array_of_nv_pair));
   of_memset (dmpath_a, 0, sizeof(dmpath_a));
   of_memset(param_a1,0,sizeof(param_a1));
   of_memset(node_a,0,sizeof(node_a));
   of_memset(stats_type_a,0,sizeof(stats_type_a));

   of_strcpy(stats_type_a,CM_CLI_AGGRREGATE_STATS);

   if(param_cnt_ui == 1)
   {
      of_strcpy (param_a1,(char *) params_p[0].param_value);
      if(of_strcmp(param_a1,CM_CLI_AGGRREGATE_STATS)== 0 ||
            of_strcmp(param_a1,CM_CLI_AVERAGE_STATS)== 0 ||
            of_strcmp(param_a1,CM_CLI_PER_DEVICE_STATS)== 0)
      {
         of_strcpy (stats_type_a,param_a1);
      }
      else
      {
         of_strcpy (node_a,param_a1);
      }
   }
   if (param_cnt_ui == 2)
   {
      of_strcpy (stats_type_a,(char *) params_p[0].param_value);
      of_strcpy (node_a, (char *) params_p[1].param_value);
   }

   of_strcpy (dmpath_a, cli_session_p->dmpath_a);

   if(of_strlen(node_a) > 0)
   {
      of_strcat (dmpath_a,".");
      of_strcat (dmpath_a,node_a);
   }

   if(of_strcmp(stats_type_a,CM_CLI_PER_DEVICE_STATS) == 0)
   {
      sub_command_id = CM_CMD_GET_PER_DEVICE_STATS;
   }
   else if(of_strcmp(stats_type_a,CM_CLI_AVERAGE_STATS) == 0)
   {
      sub_command_id = CM_CMD_GET_AVERAGE_STATS; 
   }
   else if(of_strcmp(stats_type_a,CM_CLI_AGGRREGATE_STATS) == 0)
   {
      sub_command_id = CM_CMD_GET_AGGREGATE_STATS;
   }
   else
   {
      cm_cli_puts (cli_session_p, " Invalid statistics type, specify as aggr/avg/perdev\n\r");
      return OF_SUCCESS;
   }

   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            cli_session_p->dmpath_a,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   if(of_strlen(node_a) > 0)
   {
      for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
      {
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
         if((of_strcmp(tmp_node_info_p->name_p,node_a)==0) ||
               ((tmp_node_info_p->element_attrib.cli_identifier_p)
                && (of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, node_a) == 0)) )
         {  
            found_b = TRUE;
            if(tmp_node_info_p->element_attrib.stats_command_b != TRUE)
            {
               cm_cli_puts (cli_session_p," Entered StatsAppl does not support statistics feature.\n\r");
               cm_cli_free_node_info(node_info_p);
               cm_cli_cleanup_array_of_node_info(child_info_arr_p);
               return OF_FAILURE;
            }
            break;
         }
      }

      if(found_b != TRUE)
      {
         cm_cli_puts (cli_session_p, " Invalid Statistics application name entered.\n\r");
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }
   }
   else
   {
      if(node_info_p->element_attrib.stats_command_b != TRUE)
      {
         cm_cli_puts (cli_session_p," Entered StatsAppl does not support statistics feature.\n\r");
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }
   }

   return_value = cm_get_stats_records ( cli_session_p->tnsprt_channel_p,
         CM_CLI_MGMT_ENGINE_ID,
         cli_session_p->role_info.admin_role,
         dmpath_a,
         sub_command_id,
         &key_nv_pairs,
         &rec_count_ui,
         &out_array_of_nv_pair_arr);
   if(return_value == OF_SUCCESS)
   {
      cm_cli_display_nv_pair_array (out_array_of_nv_pair_arr, rec_count_ui,dmpath_a);
      cm_cli_free_node_info(node_info_p);
      cm_cli_cleanup_array_of_node_info(child_info_arr_p);
      return OF_SUCCESS;
   }
   cm_cli_free_node_info(node_info_p);
   cm_cli_cleanup_array_of_node_info(child_info_arr_p);
   cm_cli_puts (cli_session_p," Statistics command failed.\n\r");
   return OF_FAILURE;
}
#endif

/***************************************************************************
 * Function Name : cm_cli_get_keys_array
 * Description   : This API is used to get the keys array
 * Input         : dm_path_p - DMPath
 *                 param_val_p - Parameter value
 * Output        : keys_array_p - extracted Keys array
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_get_keys_array(char *dm_path_p,  
                struct cm_array_of_nv_pair *keys_array_p, 
              char *param_val_p)
{
   int32_t return_value,ii;
   struct cm_dm_node_info *node_info_p = NULL;
   char param_a[CM_CLI_MAX_NAME_LEN + 1] ="";

   ii = of_strlen(dm_path_p);

   if((!param_val_p) && (dm_path_p[ii -1 ] =='}'))
   {
      return OF_SUCCESS;
   }
   else
   {
      of_strcpy(param_a, param_val_p);
   }

   return_value = cm_dm_get_key_child_info (cli_session_p->tnsprt_channel_p,
         dm_path_p, CM_CLI_MGMT_ENGINE_ID,
         &cli_session_p->role_info, &node_info_p);
   if ((return_value != OF_SUCCESS) || (!node_info_p))
   {
      cm_cli_puts (cli_session_p, " Failed to get Key Child information.\n\r");
      return OF_FAILURE;
   }
   keys_array_p->count_ui = 1;
   keys_array_p->nv_pairs = (struct cm_nv_pair*)of_calloc(1, sizeof(struct cm_nv_pair));
   if(keys_array_p->nv_pairs == NULL)
   {
      cm_cli_puts(cli_session_p, " Memory allocation failed.\n\r");
      return OF_FAILURE;
   }

   keys_array_p->nv_pairs->name_length = of_strlen(node_info_p->name_p);
   keys_array_p->nv_pairs->name_p = (char*)of_calloc(1, keys_array_p->nv_pairs->name_length+1);
   if(keys_array_p->nv_pairs->name_p == NULL)
   {
      cm_cli_puts(cli_session_p, " Memory allocation failed.\n\r");
      return OF_FAILURE;
   }

   of_strcpy(keys_array_p->nv_pairs->name_p, node_info_p->name_p);
   keys_array_p->nv_pairs->value_type = node_info_p->data_attrib.data_type;
   keys_array_p->nv_pairs->value_length = of_strlen(param_a);
   keys_array_p->nv_pairs->value_p = (char*)of_calloc(1, keys_array_p->nv_pairs->value_length+1);
   if(keys_array_p->nv_pairs->value_p == NULL)
   {
      cm_cli_puts(cli_session_p, " Memory allocation failed.\n\r");
      return OF_FAILURE;
   }
   of_strcpy(keys_array_p->nv_pairs->value_p, param_a);


   if(node_info_p->element_attrib.cli_identifier_p)
   {
      keys_array_p->nv_pairs->identifier_len_ui = of_strlen(node_info_p->element_attrib.cli_identifier_p);
      keys_array_p->nv_pairs->cli_identifier_p = (char*)of_calloc(1, keys_array_p->nv_pairs->identifier_len_ui+1);
      if(keys_array_p->nv_pairs->cli_identifier_p == NULL)
      {
         cm_cli_puts(cli_session_p, " Memory allocation failed\n\r");
         return OF_FAILURE;
      }

      of_strcpy(keys_array_p->nv_pairs->cli_identifier_p, node_info_p->element_attrib.cli_identifier_p);
   }
   else
   {
      keys_array_p->nv_pairs->identifier_len_ui = 0;
      keys_array_p->nv_pairs->cli_identifier_p = NULL;
   }
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_set_default_parameters
 * Description   : This API is used to set the value of a Parameter to it's
 *                 default value.
 * Input         : cli_session_p - Cli Session pointer.
 *                 params_p - Input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_set_default_parameters (struct cm_cli_session * cli_session_p,
                                struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_result *result_p = NULL;
   struct cm_command command_info;
   struct cm_nv_pair nv_pair;
   char param_a[CM_CLI_MAX_NAME_LEN + 1] = { 0 };
   int32_t return_value;

   if (!(cli_session_p) || !(params_p) || (param_cnt_ui == 0))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   /* Frame Name-Value pairs */
   of_memset(&nv_pair, 0, sizeof(nv_pair));
   of_strcpy (param_a, (char *) params_p->param_value);
   nv_pair.name_length = of_strlen (param_a);
   nv_pair.name_p = (char *) of_calloc (1, nv_pair.name_length + 1);
   if (nv_pair.name_p == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed.\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }
   of_strcpy (nv_pair.name_p, param_a);

   cm_cli_fill_command_info (CM_CMD_SET_PARAM_TO_DEFAULT,
         cli_session_p->dmpath_a, 1, &nv_pair, &command_info);

   return_value = cm_config_session_update_cmd (cli_session_p->config_session_p,
         &command_info, &result_p);
   if (return_value == OF_FAILURE)
   {
      /* Based on the input present in the result_p display the error message */
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }
      of_free (nv_pair.name_p);
      return OF_FAILURE;
   }
   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }
   of_free (nv_pair.name_p);
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_flush_command 
 * Description   : This API is used to invoke flush command.
 * Input         : cli_session_p - Cli Session pointer.
 *                 params_p - Input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/

int32_t cm_cli_flush_command(struct cm_cli_session * cli_session_p,struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{

   struct cm_result *result_p = NULL;
   struct cm_command command_info;

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   of_memset (&command_info, 0, sizeof (command_info));
   command_info.command_id = CM_CMD_FLUSH_CONFIG;
   command_info.dm_path_p = cli_session_p->dmpath_a;
#ifdef CM_LDSV_SUPPORT
   if (cm_ldsv_factory_reset (cli_session_p->tnsprt_channel_p, &command_info, &result_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info) != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " LDSV factory reset failed.\n\r");
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
         return OF_FAILURE;
      }
   }
#endif

   if (result_p)
   {
      UCMFreeUCMResult ( result_p);
   }

   cm_cli_puts (cli_session_p,
         "\n Successfully flushed / erased the entire configuration.\n\r");

   return OF_SUCCESS;

}



/***************************************************************************
 * Function Name : cm_cli_set_factory_defaults
 * Description   : This callback API is used to reset the Box to Factory
 *                 defaults.
 * Input         : cli_session_p - Cli Session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_set_factory_defaults (struct cm_cli_session * cli_session_p,
                                  struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_result *result_p = NULL;
   struct cm_command command_info;

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   of_memset (&command_info, 0, sizeof (command_info));
   command_info.command_id = CM_CMD_RESET_TO_FACTORY_DEFAULTS;
   command_info.dm_path_p = cli_session_p->dmpath_a;
#ifdef CM_LDSV_SUPPORT
   if (cm_ldsv_factory_reset (cli_session_p->tnsprt_channel_p, &command_info, &result_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info) != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " LDSV factory reset failed.\n\r");
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
         return OF_FAILURE;
      }
   }
#endif
   if (result_p)
   {
      UCMFreeUCMResult ( result_p);
   }

   cm_cli_puts (cli_session_p,
         " Successfully reset to factory default configuration.\n\r");
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_save_config
 * Description   : this API is used to save configuration in a parsistent store 
 * Input         : cli_session_p - Cli session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_save_config (struct cm_cli_session * cli_session_p,
                          struct cm_cli_params * params_p, uint32_t param_cnt_ui)
{
   struct cm_result *result_p = NULL;
   struct cm_command command_info;

   if (!cli_session_p)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   of_memset (&command_info, 0, sizeof (command_info));
   command_info.command_id = CM_CMD_SAVE_CONFIG;
   //  command_info.dm_path_p = cli_session_p->dmpath_a; //VortiQa Requirement
   command_info.dm_path_p = cli_session_p->root_c; //VortiQa Requirement

   cm_cli_puts (cli_session_p, " Save is in progress...\n\r");
#ifdef CM_LDSV_SUPPORT
   if (cm_ldsv_save_config (cli_session_p->tnsprt_channel_p, &command_info, &result_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info) != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " Save failed due to the following:\n\r");
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
         return OF_FAILURE;
      }
      return OF_FAILURE;
   }
#endif
   if (result_p)
   {
      UCMFreeUCMResult ( result_p);
   }

   cm_cli_puts (cli_session_p, " Successfully saved the configuration.\n\r");
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_system_command 
 * Description   : this API is used to invoke system commands like ping
 * Input         : cli_session_p - Cli session pointer.
 *                 params_p - pointer to input parameters
 * Output        : NONE 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_system_command (struct cm_cli_params * params_p,
                                    int32_t param_cnt_i)
{
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1]; 
   struct cm_array_of_nv_pair nv_pair_array;

   of_memset(&nv_pair_array,0,sizeof(nv_pair_array));
   of_memset(dmpath_a,'\0',sizeof(dmpath_a));  
   of_strcpy (dmpath_a, cli_session_p->dmpath_a); 
   of_strcat (dmpath_a, ".");
   of_strcat (dmpath_a,(char *) params_p[0].param_value);

   if(param_cnt_i == 1)
   {
      cm_cli_display_records_of_table (dmpath_a, &nv_pair_array, FALSE);
   }
   else
   {
      if(cm_cli_get_nv_pairs_from_command(dmpath_a,params_p,param_cnt_i,&nv_pair_array,TRUE)
            == OF_SUCCESS)
      {
         cm_cli_display_records_of_table (dmpath_a, &nv_pair_array, FALSE);
      }
   }
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_get_nv_pairs_from_command 
 * Description   : this API is used to extract name value pairs from a command
 * Input         : dm_path_p - Data model template path
 *                 params_p - pointer to input parameters
 * Output        : nv_pair_array_p - array of Name value pairs 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_get_nv_pairs_from_command(char *dm_path_p, struct cm_cli_params  *params_p,
        int32_t param_cnt_i,struct cm_array_of_nv_pair *nv_pair_array_p, unsigned char mand_req_b)
{
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_dm_node_info *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   struct cm_nv_pair *tmp_nv_pair_p = NULL;
   char *tmp_dm_path_p = NULL;
   char param_a1[CM_CLI_MAX_NAME_LEN + 1];
   int32_t ii,jj,index_i,mand_cnt_ui=0,opt_cnt_ui=0,key_cnt_ui=0;
   int32_t return_value=OF_FAILURE,key_index_i;
   unsigned char found_b = FALSE;

   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            dm_path_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;

      if(tmp_node_info_p->element_attrib.mandatory_b == TRUE)
      {
         mand_cnt_ui++;
         if(tmp_node_info_p->element_attrib.key_b == TRUE)
            key_cnt_ui++;
      }
   }

   if(param_cnt_i -(key_cnt_ui + 1) < 0)
   {
      cm_cli_puts (cli_session_p, " Invalid command. Key parameter(s) required.\r\n");    
   }
   else if((mand_req_b == FALSE) && (param_cnt_i -(mand_cnt_ui + 1)) <= 0)
   {
      mand_cnt_ui =  param_cnt_i - 1;
      opt_cnt_ui = 0;
   }
   else
   {
      opt_cnt_ui = (param_cnt_i -(mand_cnt_ui + 1))/2;
   }

   if((param_cnt_i -(mand_cnt_ui + 1)) < 0)
   {
      cm_cli_puts (cli_session_p, " Invalid command. Check the mandatory parameters.\r\n");
      cm_cli_free_node_info(node_info_p);
      cm_cli_cleanup_array_of_node_info(child_info_arr_p);
      return OF_FAILURE;
   }
   else if(((param_cnt_i -(mand_cnt_ui + 1))%2) != 0)
   {
      cm_cli_puts (cli_session_p, " Invalid command. For optional parameters both name and value are required.\r\n");
      cm_cli_free_node_info(node_info_p);
      cm_cli_cleanup_array_of_node_info(child_info_arr_p);
      return OF_FAILURE;
   }

   /*Optional params name verification */
   of_memset(param_a1,0,CM_CLI_MAX_NAME_LEN +1);
   for (ii = 1 + mand_cnt_ui; ii < param_cnt_i ; ii = ii+2)
   {
      if(of_strlen((char *) params_p[ii].param_value) > CM_CLI_MAX_NAME_LEN)
      {
         sprintf (buff_a, "Invalid parameter: %s\r\n",(char *) params_p[ii].param_value);
         cm_cli_puts (cli_session_p, buff_a);
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }

      of_strcpy(param_a1,(char *) params_p[ii].param_value);

      for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
      {
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
         if(of_strcmp(tmp_node_info_p->name_p,param_a1)==0 || 
               (tmp_node_info_p->element_attrib.cli_identifier_p && of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, param_a1)==0) )
         {
            found_b = FALSE;
            if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR)
            {
               found_b = TRUE;
               break;
            }
         }
      }

      if(found_b == FALSE)
      {
         sprintf (buff_a, " Invalid parameter: %s\r\n",param_a1);
         cm_cli_puts (cli_session_p, buff_a);
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }
   }/* End of Optional params name verification */

   nv_pair_array_p->count_ui = mand_cnt_ui + opt_cnt_ui ;

   nv_pair_array_p->nv_pairs = (struct cm_nv_pair *) of_calloc (nv_pair_array_p->count_ui,
         sizeof (struct cm_nv_pair));
   if (nv_pair_array_p->nv_pairs == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed for nv pairs.\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Filling nv_pairs */
   tmp_nv_pair_p = nv_pair_array_p->nv_pairs;
   index_i = 0;
   key_index_i = 0;

   for (ii = 1, jj = 0 ; jj < nv_pair_array_p->count_ui; jj++)
   {
      /* Copy Name Len */
      if(ii < 1 + key_cnt_ui)
      {
         for ( ; key_index_i < child_info_arr_p->count_ui; key_index_i++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + key_index_i;
            if(tmp_node_info_p->element_attrib.key_b == TRUE)
            {
               tmp_nv_pair_p[jj].name_length = of_strlen(tmp_node_info_p->name_p);
               key_index_i++;
               break;
            }
         }

      }
      else if(ii < 1 + mand_cnt_ui)
      {
         for ( ; index_i < child_info_arr_p->count_ui; index_i++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
            if(tmp_node_info_p->element_attrib.mandatory_b == TRUE &&
                  tmp_node_info_p->element_attrib.key_b != TRUE)
            {
               tmp_nv_pair_p[jj].name_length = of_strlen(tmp_node_info_p->name_p);
               index_i++;
               break;
            }
         }
      }
      else
      {
         for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
            if(of_strcmp(tmp_node_info_p->name_p,(char *) params_p[ii].param_value)==0 || 
                  (tmp_node_info_p->element_attrib.cli_identifier_p && of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, (char *) params_p[ii].param_value)==0))
            {
               if(tmp_node_info_p->element_attrib.mandatory_b == FALSE)
               {
                  tmp_nv_pair_p[jj].name_length = of_strlen(tmp_node_info_p->name_p);
                  break;
               }
            }
         }
      }


      /* Copy Name */
      tmp_nv_pair_p[jj].name_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].name_length + 1);
      if (tmp_nv_pair_p[jj].name_p == NULL)
      {
         /* Free all the nv_pairs */
         CM_FREE_NVPAIR_ARRAY ((*nv_pair_array_p), jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }

      if(ii < 1 + mand_cnt_ui)
      {
         of_memcpy (tmp_nv_pair_p[jj].name_p, (char *) tmp_node_info_p->name_p,
               tmp_nv_pair_p[jj].name_length);
      }
      else
      {
         of_memcpy (tmp_nv_pair_p[jj].name_p, (char *) tmp_node_info_p->name_p,
               tmp_nv_pair_p[jj].name_length);
         ii++;
      }

      /* Copy Value Length  */
      tmp_nv_pair_p[jj].value_length = of_strlen ((char *) params_p[ii].param_value);

      /* Copy Value */
      tmp_nv_pair_p[jj].value_p =
         (char *) of_calloc (1, tmp_nv_pair_p[jj].value_length + 1);
      if (tmp_nv_pair_p[jj].value_p == NULL)
      {
         /* Free all the nv_pairs */
         of_free (tmp_nv_pair_p[jj].name_p);
         CM_FREE_NVPAIR_ARRAY ((*nv_pair_array_p), jj);
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         cm_cli_free_node_info(node_info_p);
         cm_cli_cleanup_array_of_node_info(child_info_arr_p);
         return OF_FAILURE;
      }
      of_memcpy (tmp_nv_pair_p[jj].value_p, (char *) params_p[ii++].param_value,
            tmp_nv_pair_p[jj].value_length);
   }
   /* End of Filling nv_pairs */

   cm_cli_free_node_info(node_info_p);
   cm_cli_cleanup_array_of_node_info(child_info_arr_p);

   /*Validation of param values */
   tmp_dm_path_p = of_calloc(1, of_strlen(dm_path_p)+CM_CLI_MAX_NAME_LEN+1);
   of_strcpy(tmp_dm_path_p,dm_path_p);

   for (ii = 0; ii < nv_pair_array_p->count_ui; ii++)
   {
      of_strcpy(tmp_dm_path_p,dm_path_p);
      of_strcat(tmp_dm_path_p,".");
      of_strcat(tmp_dm_path_p,nv_pair_array_p->nv_pairs[ii].name_p);
      return_value = cm_cli_validate_attribute (&(nv_pair_array_p->nv_pairs[ii]), tmp_dm_path_p);
      if (return_value == OF_FAILURE)
      {
         CM_FREE_NVPAIR_ARRAY ((*nv_pair_array_p), nv_pair_array_p->count_ui);
         of_free(tmp_dm_path_p);
         return OF_FAILURE;
      }
   }
   of_free(tmp_dm_path_p); /* End of Validation of param values */
   return OF_SUCCESS;
}


/******************************************************************************
 * Function Name : cm_cli_frame_and_send_add_params_to_je
 * Description   : This API is used to send the Add record request to JE. This
 *                 API will frame Name-Value pairs,checks for the Config
 *                 Session, If not exists, Starts a config session at JE and
 *                 will push the Name-Value pairs for the Add request to JE.
 * Input params  : params_p -  Array of tokens (strings)
 *                 param_cnt_i - tokens count 
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/

int32_t cm_cli_frame_and_send_add_params_to_je (struct cm_cli_params *params_p,
                                         int32_t param_cnt_i)
{
   struct cm_command command_info;
   struct cm_result *result_p = NULL;
   char tmp_str_a[CM_CLI_MAX_PROMPT_LEN + 1],
           temp_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   uint32_t command_id = CM_CMD_ADD_PARAMS;
   uint32_t prompt_len_ui=0;
   int32_t return_value1;
#ifdef CM_DM_INSTANCE_TREE_DEPENDENCY_ENABLED
   unsigned char instance_exists_b = FALSE;
#else
   int32_t return_value;
#endif
   unsigned char  this_session_b = FALSE;
   unsigned char  is_modify_rec_b = FALSE;
   struct cm_array_of_nv_pair *out_array_of_nv_pair_arr = NULL;
   struct cm_array_of_nv_pair key_nv_pairs;
   struct cm_array_of_nv_pair nv_pair_array;
   uint32_t ii=0;
   unsigned char is_table_b;

   /* Start config session if needed */
   if (cli_session_p->config_session_p == NULL)
   {
      cli_session_p->config_session_p =
         (struct cm_je_config_session *) cm_config_session_start (CM_CLI_MGMT_ENGINE_ID,
               &cli_session_p->role_info,
               cli_session_p->tnsprt_channel_p);
      if (cli_session_p->config_session_p == NULL)
      {
         cm_cli_puts (cli_session_p, " Configuration session start failed.\n\r");
         return OF_FAILURE;
      }
      this_session_b = TRUE;
   }

   of_memset (tmp_str_a, 0, sizeof (tmp_str_a));
   of_memset (&nv_pair_array,0,sizeof (struct cm_array_of_nv_pair));
   of_memset (&key_nv_pairs,0,sizeof (struct cm_array_of_nv_pair));

   cm_cli_get_dir_path (temp_path_a);
   of_strcat (temp_path_a, "/");

   prompt_len_ui = of_strlen(temp_path_a)+of_strlen((char *) params_p[0].param_value);

   if(prompt_len_ui > sizeof(temp_path_a))
   {
      sprintf(buff_a," Invalid input. Total length of the input should be less than %d\r\n", (sizeof(temp_path_a) - of_strlen(temp_path_a)) );
      cm_cli_puts(cli_session_p, buff_a);
      return OF_FAILURE;
   }
   of_strcat (temp_path_a,(char *) params_p[0].param_value);

   of_strcpy (tmp_str_a, temp_path_a);

   of_strcat (temp_path_a, " ");

   cm_cli_convert_dir_to_dmpath (tmp_str_a, tmp_str_a);

   if (cm_cli_update_child_list_and_prompt (tmp_str_a, tmp_str_a, TRUE, &is_table_b) != OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      if(this_session_b)
      {
         cli_session_p->index_i++;
         cm_cli_end_config_session (cli_session_p->config_session_p,
               CM_CMD_CONFIG_SESSION_REVOKE);
         cli_session_p->config_session_p = NULL;
      }

      return OF_FAILURE;
   }

   of_strcpy (cli_session_p->context_path, tmp_str_a);
   cli_session_p->context_b = TRUE;

   if(cm_cli_get_nv_pairs_from_command(tmp_str_a, params_p,
            param_cnt_i,&nv_pair_array,FALSE)!= OF_SUCCESS)
   {
      cm_cli_restore_prompt ();
      if(this_session_b)
      {
         cli_session_p->index_i++;
         cm_cli_end_config_session (cli_session_p->config_session_p,
               CM_CMD_CONFIG_SESSION_REVOKE);
         cli_session_p->config_session_p = NULL;
      }
      return OF_FAILURE;
   }

   return_value1 = cm_cli_get_prev_record_key_array (&nv_pair_array , &key_nv_pairs, tmp_str_a, FALSE);

   if (return_value1==OF_SUCCESS)
   {

      for (ii = 0; ii < key_nv_pairs.count_ui; ii++)
      {
         if((return_value1 = cm_cli_validate_attribute(&(key_nv_pairs.nv_pairs[ii]),NULL) != OF_SUCCESS))
         {
            break;
         }
         if(key_nv_pairs.count_ui == 1)
         {
            prompt_len_ui += key_nv_pairs.nv_pairs[ii].value_length ;
         }
         else
         {
            prompt_len_ui += key_nv_pairs.nv_pairs[ii].value_length
               + key_nv_pairs.nv_pairs[ii].name_length;
         }
      }

      if(prompt_len_ui > sizeof(temp_path_a))
      {
         sprintf(buff_a," Invalid input. Total length of key value parameters should be less than %d\r\n", (sizeof(temp_path_a) - of_strlen(temp_path_a)) );
         cm_cli_puts(cli_session_p, buff_a);

         cm_cli_restore_prompt ();
         if(this_session_b)
         {
            cli_session_p->index_i++;
            cm_cli_end_config_session (cli_session_p->config_session_p,
                  CM_CMD_CONFIG_SESSION_REVOKE);
            cli_session_p->config_session_p = NULL;
         }

         return OF_FAILURE;
      }



#ifdef CM_DM_INSTANCE_TREE_DEPENDENCY_ENABLED
      instance_exists_b = cm_dm_is_instance_map_entry_using_key_and_name_path (tmp_str_a,
            cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            key_nv_pairs_p->NvPair[0].value_p,                                                                                                             key_nv_pairs_p->NvPair[0].value_type);
      if (instance_exists_b == TRUE)
      {
#else
         return_value = cm_get_exact_record (cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID,
               cli_session_p->role_info.admin_role,
               tmp_str_a,
               &key_nv_pairs, &out_array_of_nv_pair_arr);
         if (return_value == OF_SUCCESS)
         {
            /* Free Outnv_pair_array */
            if(out_array_of_nv_pair_arr)
               CM_FREE_PTR_NVPAIR_ARRAY (out_array_of_nv_pair_arr,
                     out_array_of_nv_pair_arr->count_ui);
            is_modify_rec_b = TRUE;
#endif
            /* Frame context Path */
            command_id = CM_CMD_SET_PARAMS;
         }

         /* Updating context path and directory path depending on key values */

         of_strcat (cli_session_p->context_path, "{");
         if(key_nv_pairs.count_ui == 1)
         {
            of_strcat (cli_session_p->context_path, key_nv_pairs.nv_pairs[0].value_p);
            of_strcat(temp_path_a,key_nv_pairs.nv_pairs[0].value_p);
         }
         else
         {
            for(ii=0; ii < key_nv_pairs.count_ui ; ii++)
            {
               of_strcat (cli_session_p->context_path, key_nv_pairs.nv_pairs[ii].name_p);
               of_strcat(temp_path_a, key_nv_pairs.nv_pairs[ii].name_p);

               of_strcat (cli_session_p->context_path, "=");
               of_strcat(temp_path_a, "=");

               of_strcat (cli_session_p->context_path, key_nv_pairs.nv_pairs[ii].value_p);
               of_strcat(temp_path_a, key_nv_pairs.nv_pairs[ii].value_p);
               if(ii+1 < key_nv_pairs.count_ui)
               {
                  of_strcat(temp_path_a, ",");
                  of_strcat (cli_session_p->context_path, ",");
               }
            }
         }

         of_strcat (cli_session_p->context_path, "}");
      }
      else
      {
         cm_cli_restore_prompt ();
         if(this_session_b)
         {
            cli_session_p->index_i++;
            cm_cli_end_config_session (cli_session_p->config_session_p,
                  CM_CMD_CONFIG_SESSION_REVOKE);
            cli_session_p->config_session_p = NULL;
         }

         return OF_FAILURE;
      }
      cm_cli_fill_command_info (command_id, cli_session_p->context_path,nv_pair_array.count_ui, nv_pair_array.nv_pairs,
            &command_info);


      /* Fill Command Info structure */
      if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info,
               &result_p) == OF_FAILURE)
      {
         cm_cli_restore_prompt ();
         if (result_p)
         {
            cm_cli_display_result (result_p);
            UCMFreeUCMResult (result_p);
         }
         if(this_session_b)
         {
            cli_session_p->index_i++;
            cm_cli_end_config_session (cli_session_p->config_session_p,
                  CM_CMD_CONFIG_SESSION_REVOKE);
            cli_session_p->config_session_p = NULL;
         }
         CM_FREE_NVPAIR_ARRAY(key_nv_pairs, key_nv_pairs.count_ui);
         CM_FREE_NVPAIR_ARRAY(nv_pair_array, nv_pair_array.count_ui);
         return OF_FAILURE;
      }

      CM_FREE_NVPAIR_ARRAY(key_nv_pairs, key_nv_pairs.count_ui);
      CM_FREE_NVPAIR_ARRAY(nv_pair_array, nv_pair_array.count_ui);

      if (result_p)
      {
         UCMFreeUCMResult (result_p);
      }

      of_strcpy (cli_session_p->dmpath_a, tmp_str_a);
      cm_cli_find_directory (temp_path_a, tmp_str_a, FALSE, 2); //psess index is incremented here on successful case
      cm_cli_update_prompt (temp_path_a);
      cli_session_p->context_b = TRUE;

      if(is_modify_rec_b == TRUE) 
         cm_cli_puts(cli_session_p,"\n\tEntered into Edit context.\r\n");
      else
         cm_cli_puts(cli_session_p,"\n\tEntered into Add context.\r\n");

      return OF_SUCCESS;
   }

/***************************************************************************
 * Function Name : cm_cli_get_mandatory_param_name 
 * Description   : this API is used to get mandatory parameter name using position
 * Input         : pos_ui - Mandatory parameter position 
 * Output        : out_name_p - Mandatory parameter name
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_get_mandatory_param_name(uint32_t pos_ui, char **out_name_p,uint8_t *data_type_ui)
{
   struct cm_cli_data_ele_node *data_ele_node_p;
   UCMDllQNode_t *dll_q_node_p;
   uint32_t param_pos_ui = 0, param_len_ui = 0;
   char *name_p = NULL;
   unsigned char found_b = FALSE;

   //Scan and get the mandatory param name with its position.
   CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p, UCMDllQNode_t *)
   {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,struct cm_cli_data_ele_node *, list_node);
      {
         if((data_ele_node_p->mandatory_b == TRUE) && (data_ele_node_p->key_b == FALSE))
         {
            param_pos_ui++;
            //Mandatory param postion matched
            if(param_pos_ui == pos_ui)
            {
               found_b = TRUE;
               param_len_ui = of_strlen(data_ele_node_p->node_name);
               name_p = (char *)of_calloc(1, param_len_ui+1);
               if(name_p == NULL)
               {
#ifdef CM_CLI_DEBUG 
                  sprintf (buff_a,
                        "%s :: Failed to allocate memory for parameter name\n\r",
                        __FUNCTION__);
                  cm_cli_puts (cli_session_p, buff_a);
#endif
                  *out_name_p = NULL;
                  data_type_ui = 0;
                  return OF_FAILURE;
               }
               of_strcpy(name_p, data_ele_node_p->node_name);
               *data_type_ui =  data_ele_node_p->data_type;
               break;
            }//Postion
         }//Check if Mandatory
      }//Data element node
   }//scan
   if(found_b == FALSE)
   {
      *out_name_p = NULL;
      data_type_ui = 0;
      return OF_FAILURE;
   }
   else
   {
      *out_name_p = name_p;
      return OF_SUCCESS;
   }
}

/******************************************************************************
 * Function Name : cm_cli_frame_and_send_set_params_to_je
 * Description   : This API is used frame the Name-Value pairs of a particular
 *                 record and will push the information to JE.
 * Input params  : aTokens -  Array of tokens (strings)
 *                 param_cnt_i - tokens count 
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
#if 0
int32_t cm_cli_frame_and_send_set_params_to_je (struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui)
{
  struct cm_array_of_nv_pair nv_pair_array;
  struct cm_nv_pair *tmp_nv_pair_p;
  struct cm_result *result_p;
  struct cm_command command_info;
  UCMDllQNode_t *dll_q_node_p;
  struct cm_cli_data_ele_node *data_ele_node_p;
  unsigned char found_b, bScalSession = FALSE;
  int32_t ii, jj, return_value;

  if ((!cli_session_p) || !(params_p) || (param_cnt_ui < 2))
  {
    cm_cli_puts (cli_session_p, " Invalid input. \n\r");
    return OF_FAILURE;
  }

  if ((!cli_session_p->config_session_p) && 
        (cli_session_p->current_node_p->node_type_ui != CM_DMNODE_TYPE_ANCHOR))
  {
    cm_cli_puts (cli_session_p, "No Config Session exists \n\r");
    return OF_FAILURE;
  }

  for (ii = 0; ii < param_cnt_ui; ii += 2)
  {
    found_b = FALSE;
    CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
                   UCMDllQNode_t *)
    {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                                           list_node);
      if (of_strcmp (data_ele_node_p->node_name, (char *) params_p[ii].param_value)
          == 0)
      {
        found_b = TRUE;
      }
    }
    if (found_b == FALSE)
    {
      sprintf (buff_a, "Invalid Child node name (%s) entered \n\r",
                 (char *) params_p[ii].param_value);
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
    }
  }
  /* Get number of Name-Value pairs */
  nv_pair_array.count_ui = (param_cnt_ui / 2);

  /* Allocate memory for Name-Value pairs */
  nv_pair_array.nv_pairs = (struct cm_nv_pair *) of_calloc (nv_pair_array.count_ui,
                                                  sizeof (struct cm_nv_pair));
  if (nv_pair_array.nv_pairs == NULL)
  {
    sprintf (buff_a, "%s :: Memory allocation failed for nv_pairs\n\r",
               __FUNCTION__);
    cm_cli_puts (cli_session_p, buff_a);
    return OF_FAILURE;
  }

  /* Fill Name-Value pairs */
  tmp_nv_pair_p = nv_pair_array.nv_pairs;
  for (ii = 0, jj = 0; jj < nv_pair_array.count_ui; jj++)
  {
    /* Copy Name Len */
    tmp_nv_pair_p[jj].name_length = of_strlen ((char *) params_p[ii].param_value);

    /* Copy Name */
    tmp_nv_pair_p[jj].name_p =
      (char *) of_calloc (1, tmp_nv_pair_p[jj].name_length + 1);
    if (tmp_nv_pair_p[jj].name_p == NULL)
    {
      /* Free all the nv_pairs */
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
      sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
    }
    of_memcpy (tmp_nv_pair_p[jj].name_p, (char *) params_p[ii++].param_value,
              tmp_nv_pair_p[jj].name_length);

    /* Copy Value Type  */
    CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
                   UCMDllQNode_t *)
    {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                                           list_node);
      if (of_strcmp (data_ele_node_p->node_name, tmp_nv_pair_p[jj].name_p) == 0)
      {
        tmp_nv_pair_p[jj].value_type = data_ele_node_p->data_type;
      }
    }

    /* Copy Value Length  */
    tmp_nv_pair_p[jj].value_length = of_strlen ((char *) params_p[ii].param_value);

    /* Copy Value */
    tmp_nv_pair_p[jj].value_p =
      (char *) of_calloc (1, tmp_nv_pair_p[jj].value_length + 1);
    if (tmp_nv_pair_p[jj].value_p == NULL)
    {
      /* Free all the nv_pairs */
      of_free (tmp_nv_pair_p[jj].name_p);
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
      sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
      return OF_FAILURE;
    }
    of_memcpy (tmp_nv_pair_p[jj].value_p, (char *) params_p[ii++].param_value,
              tmp_nv_pair_p[jj].value_length);
  }

  for (ii = 0; ii < nv_pair_array.count_ui; ii++)
  {
    return_value = cm_cli_validate_attribute (&nv_pair_array.nv_pairs[ii], NULL);
    if (return_value == OF_FAILURE)
    {
      sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
         (char *)nv_pair_array.nv_pairs[ii].value_p, nv_pair_array.nv_pairs[ii].name_p);
      cm_cli_puts(cli_session_p, buff_a);
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
      return OF_FAILURE;
    }
  }

  /* Fill Command Info structure */
  of_memset (&command_info, 0, sizeof (command_info));
  cm_cli_fill_command_info (CM_CMD_SET_PARAMS, cli_session_p->context_path,
                         nv_pair_array.count_ui, nv_pair_array.nv_pairs,
                         &command_info);

  /* if no ConfigSession and Nodetype is ANCHOR start Config Session*/
  if((cli_session_p->config_session_p == NULL)  &&
     (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR))
  {
    cli_session_p->config_session_p =
      (struct cm_je_config_session *) cm_config_session_start (CM_CLI_MGMT_ENGINE_ID,
                                                      &cli_session_p->role_info,
                                                      cli_session_p->tnsprt_channel_p);
    if (cli_session_p->config_session_p == NULL)
    {
      cm_cli_puts (cli_session_p, "cm_config_session_start failed\n\r");
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
      return OF_FAILURE;
    }

    of_strcat(cli_session_p->dmpath_a, ".");
    of_strcat(cli_session_p->dmpath_a, (char *) params_p[0].ParamName);
    bScalSession = TRUE;
  }

  /* Send to JE using ConfigSessionUpdate */
  if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info, &result_p)
      != OF_SUCCESS)
  {
    CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
    if (result_p)
    {
      cm_cli_display_result (result_p);
      UCMFreeUCMResult (result_p);
    }

    return OF_FAILURE;
  }

  if(bScalSession)
  {
     cm_cli_end_config_session (cli_session_p->config_session_p,
                                 CM_CMD_CONFIG_SESSION_COMMIT);
  }

  CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
  if (result_p)
  {
    UCMFreeUCMResult (result_p);
  }

  return OF_SUCCESS;
}
#endif

/******************************************************************************
 * Function Name : cm_cli_frame_and_send_set_params_to_je
 * Description   : This API is used frame the Name-Value pairs of a particular
 *                 record and will push the information to JE.
 * Input params  : params_p -  Array of tokens (strings)
                   cli_session_p - cli session
 *                 param_cnt_i - tokens count 
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_frame_and_send_set_params_to_je (struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui)
{
   struct cm_array_of_nv_pair nv_pair_array;
   struct cm_nv_pair *tmp_nv_pair_p;
   struct cm_result *result_p = NULL;
   struct cm_command command_info;
   UCMDllQNode_t *dll_q_node_p;
   struct cm_cli_data_ele_node *data_ele_node_p;
   unsigned char found_b;
   int32_t ii, jj, return_value;

   if ((!cli_session_p) || !(params_p) || (param_cnt_ui < 2))
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   if (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR)
   {
      if(cli_session_p->cd_table_b == FALSE)
      {
         if(cli_session_p->current_node_p->parent_trans_b == TRUE || (cli_session_p->current_node_p->parent_trans_b == FALSE && cli_session_p->context_b == FALSE))
         {
            //allow set
         }
         else if(cli_session_p->current_node_p->parent_trans_b == FALSE && cli_session_p->context_b == TRUE && 
               of_strcmp(cli_session_p->dmpath_a, cli_session_p->context_path) == 0 )
         {
            //allow set
         }
         else
         {
            cm_cli_puts(cli_session_p, " Cannot set value at this place.\r\n");
            return OF_FAILURE;
         }
      }
      else //cd table is true
      {
         if(cli_session_p->current_node_p->parent_trans_b == FALSE)
         {
            //allow set
         }
         else
         {
            cm_cli_puts(cli_session_p, " Cannot set value at this place.\r\n");
            return OF_FAILURE;
         }
      }
      if ( cm_cli_frame_and_send_set_scalar_params_to_je (cli_session_p,params_p,param_cnt_ui) != OF_SUCCESS)
      {
         cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
         return OF_FAILURE;
      }
      return OF_SUCCESS;
   }

   if (!cli_session_p->config_session_p)
   {
      cm_cli_puts (cli_session_p, " No Configuration Session exists.\n\r");
      return OF_FAILURE;
   }

   /* Get number of Name-Value pairs */
   nv_pair_array.count_ui = (param_cnt_ui / 2);

   /* Allocate memory for Name-Value pairs */
   nv_pair_array.nv_pairs = (struct cm_nv_pair *) of_calloc (nv_pair_array.count_ui,
         sizeof (struct cm_nv_pair));
   if (nv_pair_array.nv_pairs == NULL)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: Memory allocation failed for nv_pairs\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Fill Name-Value pairs */
   tmp_nv_pair_p = nv_pair_array.nv_pairs;
   for (ii = 0, jj = 0; jj < nv_pair_array.count_ui; jj++)
   {
      found_b = FALSE;
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
               list_node);
         if (of_strcmp (data_ele_node_p->node_name, (char *) params_p[ii].param_value) == 0)
         {      
            found_b = TRUE;
         }
         else if ((data_ele_node_p->cli_identifier_p) && (of_strcmp (data_ele_node_p->cli_identifier_p, (char *) params_p[ii].param_value) == 0))
         {
            found_b = TRUE;
         }
         if(found_b == TRUE)
         {
            /* Copy Name Len */
            tmp_nv_pair_p[jj].name_length = of_strlen (data_ele_node_p->node_name);

            /* Copy Name */
            tmp_nv_pair_p[jj].name_p =
               (char *) of_calloc (1, tmp_nv_pair_p[jj].name_length + 1);
            if (tmp_nv_pair_p[jj].name_p == NULL)
            {
               /* Free all the nv_pairs */
               CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
               sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
               cm_cli_puts (cli_session_p, buff_a);
#endif
               return OF_FAILURE;
            }
            of_memcpy (tmp_nv_pair_p[jj].name_p, data_ele_node_p->node_name, tmp_nv_pair_p[jj].name_length);
            ii++;

            tmp_nv_pair_p[jj].value_type = data_ele_node_p->data_type;
            /* Copy Value Length  */
            tmp_nv_pair_p[jj].value_length = of_strlen ((char *) params_p[ii].param_value);

            /* Copy Value */
            tmp_nv_pair_p[jj].value_p =
               (char *) of_calloc (1, tmp_nv_pair_p[jj].value_length + 1);
            if (tmp_nv_pair_p[jj].value_p == NULL)
            {
               /* Free all the nv_pairs */
               of_free (tmp_nv_pair_p[jj].name_p);
               CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
#ifdef CM_CLI_DEBUG 
               sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
               cm_cli_puts (cli_session_p, buff_a);
#endif
               return OF_FAILURE;
            }
            of_memcpy (tmp_nv_pair_p[jj].value_p, (char *) params_p[ii++].param_value,
                  tmp_nv_pair_p[jj].value_length);
            break;
         }
      }
      if (found_b == FALSE)
      {
         /* Free all the nv_pairs */
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, jj);
         sprintf (buff_a, " Invalid parameter name (%s) entered.\n\r",
               (char *) params_p[ii].param_value);
         cm_cli_puts (cli_session_p, buff_a);
         return OF_FAILURE;
      }
   }

   for (ii = 0; ii < nv_pair_array.count_ui; ii++)
   {
      return_value = cm_cli_validate_attribute (&nv_pair_array.nv_pairs[ii],NULL);
      if (return_value == OF_FAILURE)
      {
         sprintf (buff_a, " Entered value \'%s\' is invalid for the parameter \'%s\'.\n\r",
               (char *)nv_pair_array.nv_pairs[ii].value_p, nv_pair_array.nv_pairs[ii].name_p);
         cm_cli_puts(cli_session_p, buff_a);
         CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
         return OF_FAILURE;
      }
   }

   /* Fill Command Info structure */
   of_memset (&command_info, 0, sizeof (command_info));
   cm_cli_fill_command_info (CM_CMD_SET_PARAMS, cli_session_p->context_path,
         nv_pair_array.count_ui, nv_pair_array.nv_pairs,
         &command_info);

   /* Send to JE using ConfigSessionUpdate */
   if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info, &result_p)
         != OF_SUCCESS)
   {
      CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
      if (result_p)
      {
         cm_cli_display_result (result_p);
         UCMFreeUCMResult (result_p);
      }

      return OF_FAILURE;
   }

   CM_FREE_NVPAIR_ARRAY (nv_pair_array, nv_pair_array.count_ui);
   if (result_p)
   {
      UCMFreeUCMResult (result_p);
   }

   return OF_SUCCESS;
}

/******************************************************************************
 * Function Name : cm_cli_frame_and_send_set_scalar_params_to_je
 * Description   : This API is used frame the Name-Value pairs of a particular
 *                 record and will push the information to JE.
 * Input params  : params_p -  Array of tokens (strings)
                   cli_session_p - cli session
 *                 param_cnt_i - tokens count 
 * Output params : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 *****************************************************************************/
int32_t cm_cli_frame_and_send_set_scalar_params_to_je (struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui)
{
   struct cm_command command_info;
   struct cm_nv_pair nv_pair;
   struct cm_result *result_p = NULL;
   char tmp_str_a[CM_CLI_MAX_PROMPT_LEN + 1],
           temp_path_a[CM_CLI_MAX_PROMPT_LEN + 1] = { 0 };
   uint32_t command_id = CM_CMD_SET_PARAMS;
   unsigned char sess_already_exists_b=FALSE;
   UCMDllQNode_t *dll_q_node_p;
   struct cm_cli_data_ele_node *data_ele_node_p;
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_dm_node_info *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   unsigned char found_b;
   unsigned char sca_grp_b=FALSE;
   int32_t ii;
   int32_t  index_i;

   /* Start config session if needed */
   if (cli_session_p->config_session_p == NULL)
   {
      cli_session_p->config_session_p =
         (struct cm_je_config_session *) cm_config_session_start (CM_CLI_MGMT_ENGINE_ID,
               &cli_session_p->role_info,
               cli_session_p->tnsprt_channel_p);
      if (cli_session_p->config_session_p == NULL)
      {
         cm_cli_puts (cli_session_p, " Configuration session start failed.\n\r");
         return OF_FAILURE;
      }
   }
   else
   {
      sess_already_exists_b=TRUE;
   }

   for (ii = 0; ii < param_cnt_ui; ii += 2)
   {
      found_b = FALSE;
      of_memset (&nv_pair, 0, sizeof (nv_pair));
      of_memset (temp_path_a, 0,CM_CLI_MAX_PROMPT_LEN);

      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
               list_node);
         if( (of_strcmp (data_ele_node_p->node_name, (char *) params_p[ii].param_value) == 0) || (data_ele_node_p->cli_identifier_p != NULL &&  (of_strcmp (data_ele_node_p->cli_identifier_p, (char *) params_p[ii].param_value) == 0)) )
         {
            nv_pair.value_type = data_ele_node_p->data_type;
            found_b = TRUE;
            break;
         }
      }
      if (found_b == FALSE)
      {
         sprintf (buff_a, " Invalid parameter name (%s) entered.\n\r",
               (char *) params_p[ii].param_value);
         cm_cli_puts (cli_session_p, buff_a);
         return OF_FAILURE;
      }

      if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
               cli_session_p->dmpath_a,
               CM_CLI_MGMT_ENGINE_ID,
               &cli_session_p->role_info,
               &node_info_p, &child_info_arr_p) != OF_SUCCESS)
      {
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }

      for (index_i = 0; index_i < child_info_arr_p->count_ui; index_i++)
      {    
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + index_i;
         if( (of_strcmp(tmp_node_info_p->name_p,(char *) params_p[ii].param_value)==0)
               || ((tmp_node_info_p->element_attrib.cli_identifier_p) && (of_strcmp(tmp_node_info_p->element_attrib.cli_identifier_p, (char*) params_p[ii].param_value) == 0)) )
         {
            found_b = TRUE;
            if (tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
            {
               sca_grp_b = TRUE;
               break;
            }
            break;
         }
      }

      if(sca_grp_b != TRUE)
      {
         of_strcat (temp_path_a,cli_session_p->dmpath_a);
         of_strcat (temp_path_a,".");
         of_strcat (temp_path_a, data_ele_node_p->node_name);

         //    cm_cli_puts (cli_session_p, temp_path_a);
      }
      else
      {
         of_strcat (temp_path_a,cli_session_p->dmpath_a);
         //cm_cli_puts (cli_session_p, temp_path_a);
      }

      cm_cli_convert_dir_to_dmpath (temp_path_a, tmp_str_a);
      /* Fill nv_pair structure */

      nv_pair.name_length = of_strlen (data_ele_node_p->node_name);
      nv_pair.name_p = (char *) of_calloc (1, nv_pair.name_length + 1);
      if (nv_pair.name_p == NULL)
      {
         cm_cli_puts (cli_session_p, " Calloc failed.\n\r");
         return OF_FAILURE;
      }
      of_strncpy (nv_pair.name_p, (char *) data_ele_node_p->node_name, nv_pair.name_length);

      nv_pair.value_length = of_strlen ((char *) params_p[ii+1].param_value) ;
      nv_pair.value_p = (char *) of_calloc (1, nv_pair.value_length + 1);
      if (nv_pair.value_p == NULL)
      {
         cm_cli_restore_prompt ();
         of_free (nv_pair.name_p);
         cm_cli_puts (cli_session_p, " Calloc failed.\n\r");
         return OF_FAILURE;
      }

      of_memcpy (nv_pair.value_p, (char *) params_p[ii+1].param_value,
            nv_pair.value_length);
      cm_cli_fill_command_info (command_id,temp_path_a, 1, &nv_pair,
            &command_info);

      /* Fill Command Info structure */
      if (cm_config_session_update_cmd (cli_session_p->config_session_p, &command_info,
               &result_p) == OF_FAILURE)
      {
         CM_FREE_NVPAIR (nv_pair);
         if (result_p)
         {
            cm_cli_display_result (result_p);
            UCMFreeUCMResult (result_p);
         }
         if (sess_already_exists_b == FALSE)
         {
            cm_cli_end_config_session (cli_session_p->config_session_p,
                  CM_CMD_CONFIG_SESSION_REVOKE);
         }
         return OF_FAILURE;
      }

      CM_FREE_NVPAIR (nv_pair);
      if (result_p)
      {
         UCMFreeUCMResult (result_p);
      }
   }
/*
   if (sess_already_exists_b == FALSE)
   {
     if( (cm_cli_end_config_session (cli_session_p->config_session_p,
                     CM_CMD_CONFIG_SESSION_COMMIT)) != OF_SUCCESS)
     {
       cm_cli_end_config_session (cli_session_p->config_session_p,
                       CM_CMD_CONFIG_SESSION_REVOKE);
     }
   }
   else 
   {

   Removing implicit commit for scalars 
*/
   of_strcpy(cli_session_p->context_path,cli_session_p->dmpath_a);
   cli_session_p->context_b = TRUE;
   cli_session_p->curr_table_ctx_b = TRUE; 
   return OF_SUCCESS;
}

#ifdef CM_ROLES_PERM_SUPPORT
/******************************************************************************
 * Function Name : cm_cli_set_role_and_permissions
 * Description   : This API is used frame the Name-Value pairs of a particular
 *                 record and will push the information to JE.
 * Input params  : params_p -  Array of tokens (strings)
		   cli_session_p - cli session
 *                 param_cnt_i - tokens count 
 * Output params : None
 * Return value  : OF_FAILURE/OF_SUCCESS
 *****************************************************************************/
int32_t cm_cli_set_role_and_permissions(struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui)
{
   struct cm_dm_role_permission role_perm = {};
   uint32_t len_ui = 0;

   if((!params_p) || (param_cnt_ui != UCMCLI_SETROLECMD_PARAMCNT))
   {
      cm_cli_puts(cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }
   if (of_strlen((char*)params_p[0].param_value) > UCMDM_ADMIN_ROLE_MAX_LEN)
   {
      cm_cli_puts(cli_session_p, " Invalid input. Role length is maximum of 32 characters.\n\r");
      return OF_FAILURE;
   }
   of_strcpy(role_perm.role, (char*)params_p[0].param_value);
   role_perm.permissions = params_p[1].param_value;

   len_ui = of_strlen(cli_session_p->dmpath_a);

   if(cli_session_p->dmpath_a[len_ui - 1] == '}')
   {
      if(cm_dm_set_instance_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID,
               cli_session_p->dmpath_a,
               cli_session_p->role_info.admin_role,
               &role_perm) != OF_SUCCESS)
      {
         cm_cli_puts(cli_session_p," Set role permissions failed.\n\r");
         return OF_FAILURE;
      }
   }
   else
   {
      if(cm_dm_set_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID, cli_session_p->dmpath_a,
               cli_session_p->role_info.admin_role, &role_perm,NULL) != OF_SUCCESS)
      {
         cm_cli_puts(cli_session_p," Set role permissions failed.\n\r");
         return OF_FAILURE;
      }
   }
   cm_cli_puts(cli_session_p," Successfully set the Roles and Permissions.\n\r");
   return OF_SUCCESS;

}

/******************************************************************************
 * Function Name : cm_cli_delete_role_and_permissions 
 * Description   : This API is used frame the Name-Value pairs of a particular
 *                 record and will push the information to JE.
 * Input params  : params_p -  Array of tokens (strings)
		   cli_session_p - cli session
 *                 param_cnt_i - tokens count 
 * Output params : None
 * Return value  : OF_FAILURE/OF_SUCCESS
 *****************************************************************************/
int32_t cm_cli_delete_role_and_permissions(struct cm_cli_session * cli_session_p,
                                         struct cm_cli_params * params_p,
                                         uint32_t param_cnt_ui)
{
   struct cm_dm_role_permission role_perm = {};
   uint32_t len_ui = 0;

   if((!params_p) || (param_cnt_ui != UCMCLI_DELROLECMD_PARAMCNT))
   {
      cm_cli_puts(cli_session_p, " Invalid input.\n\r");
      return OF_FAILURE;
   }

   of_strcpy(role_perm.role, (char*)params_p[0].param_value);

   len_ui = of_strlen(cli_session_p->dmpath_a);

   if(cli_session_p->dmpath_a[len_ui - 1] == '}')
   {
      if(cm_dm_delete_instance_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID,
               cli_session_p->dmpath_a,
               cli_session_p->role_info.admin_role,
               &role_perm) != OF_SUCCESS)
      {
         cm_cli_puts(cli_session_p," Delete role permissions failed.\n\r");
         return OF_FAILURE;
      }
   }
   else
   {
      if(cm_dm_delete_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID, cli_session_p->dmpath_a,
               cli_session_p->role_info.admin_role, &role_perm) != OF_SUCCESS)
      {
         cm_cli_puts(cli_session_p," Delete role permissions failed.\n\r");
         return OF_FAILURE;
      }
   }
   cm_cli_puts(cli_session_p," Successfully deleted the Role.\n\r");
   return OF_SUCCESS;
}
/******************************************************************************
 * Function Name : cm_cli_get_role_and_permissions
 * Description   : This API is used to get ROles and permissions
 * Input params  : params_p -  Array of tokens (strings)
		   cli_session_p - cli session
 *                 param_cnt_i - tokens count 
 * Output params : None
 * Return value  : OF_FAILURE/OF_SUCCESS
 *****************************************************************************/
int32_t cm_cli_get_role_and_permissions(struct cm_cli_session * cli_session_p,
      struct cm_cli_params * params_p,
      uint32_t param_cnt_ui)
{
   if(param_cnt_ui)
   {
      cm_cli_display_role_settings_by_role((char*)params_p[0].param_value);
   }
   else
   {
      cm_cli_display_all_role_settings();
   }
   return OF_SUCCESS;
}


/******************************************************************************
 * Function Name : cm_cli_display_role_settings_by_role 
 * Description   : This API is used to display permissions using a role
 * Input params  : role_p -  Role name to display permissions
 * Output params : None
 * Return value  : OF_FAILURE/OF_SUCCESS
 *****************************************************************************/
 int32_t cm_cli_display_role_settings_by_role(char* role_p)
{
   int32_t return_value;
   uint32_t len_ui = 0;
   struct cm_dm_role_permission role_perm = {};

   len_ui = of_strlen(cli_session_p->dmpath_a);
   of_strcpy(role_perm.role, role_p);
   if(cli_session_p->dmpath_a[len_ui - 1] == '}')
   {
      return_value = cm_dm_get_instance_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            cli_session_p->dmpath_a,
            cli_session_p->role_info.admin_role,
            &role_perm);

   }
   else
   {
      return_value =  cm_dm_get_role_permissions_by_role (cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            cli_session_p->dmpath_a,
            cli_session_p->role_info.admin_role,
            &role_perm);

   }
   if(return_value == OF_FAILURE)
   {
      cm_cli_puts(cli_session_p," No records exist.\n\r");
      return OF_FAILURE;
   }
   cm_cli_display_role_info(&role_perm);
   return OF_SUCCESS;
}


/******************************************************************************
 * Function Name : cm_cli_display_all_role_settings 
 * Description   : This API is used to display all roles and permissions
 * Input params  : none
 * Output params : None
 * Return value  : OF_FAILURE/OF_SUCCESS
 *****************************************************************************/
 int32_t cm_cli_display_all_role_settings(void)
{
   struct cm_dm_array_of_role_permissions *role_perm_array_p = NULL;
   int32_t  return_value;

   uint32_t len_ui = 0;

   len_ui = of_strlen(cli_session_p->dmpath_a);

   if(cli_session_p->dmpath_a[len_ui - 1] == '}')
   {
      return_value = cm_dm_get_instance_role_permissions (cli_session_p->tnsprt_channel_p,
            CM_HTTP_MGMT_ENGINE_ID, cli_session_p->dmpath_a,
            cli_session_p->role_info.admin_role,
            &role_perm_array_p);
   }
   else
   {
      return_value = cm_dm_get_role_permissions (cli_session_p->tnsprt_channel_p,
            CM_HTTP_MGMT_ENGINE_ID, cli_session_p->dmpath_a,
            cli_session_p->role_info.admin_role,
            &role_perm_array_p);
   }
   if((return_value == OF_FAILURE) || !(role_perm_array_p))
   {
      cm_cli_puts(cli_session_p," No records exist.\n\r");
      return OF_FAILURE;
   }
   cm_cli_display_role_permissions_info(role_perm_array_p);
   return OF_SUCCESS;

}

/******************************************************************************
 * Function Name : cm_cli_display_role_permissions_info
 * Description   : this API is used to display roles and permissions 
 * Input params  : role_perm_array_p - array of roles and permissions
 * Output params : none
 * Return value  : none
 *****************************************************************************/
 void cm_cli_display_role_permissions_info(struct cm_dm_array_of_role_permissions *role_perm_array_p)
{
   int32_t ii;
   char perm_a[32]={};

   cm_cli_puts(cli_session_p, "\n\t Role\t\t\t\t Permission\n\t");
   for(ii = 0; ii < role_perm_array_p->count_ui; ii++)
   {
      sprintf(buff_a, "%-32s", role_perm_array_p->role_permissions[ii].role);
      cm_cli_puts(cli_session_p, buff_a);
      cm_cli_get_permission_string(role_perm_array_p->role_permissions[ii].permissions, perm_a);
      cm_cli_puts(cli_session_p, perm_a);
      cm_cli_puts(cli_session_p, "\n\t");
   }
   cm_cli_puts(cli_session_p, "\n\r");
}

/******************************************************************************
 * Function Name : cm_cli_display_role_info 
 * Description   : this API is used to display roles and permissions 
 * Input params  : role_perm_p - array of roles and permissions
 * Output params : none
 * Return value  : none
 *****************************************************************************/
 void cm_cli_display_role_info(struct cm_dm_role_permission *role_perm_p)
{
   char perm_a[32]={};

   cm_cli_puts(cli_session_p, "\n\t Role\t\t\t\t Permission\n\t");
   sprintf(buff_a, "%-32s", role_perm_p->role);
   cm_cli_puts(cli_session_p, buff_a);
   cm_cli_get_permission_string(role_perm_p->permissions, perm_a);
   cm_cli_puts(cli_session_p, perm_a);
   cm_cli_puts(cli_session_p, "\n");
}
/******************************************************************************
 * Function Name : cm_cli_get_permission_string
 * Description   : this API is used to get an end user understandable permission string 
                   using permission enum 
 * Input params  : perm_ui - enumerator of a permission 
 * Output params : perm_p - permission string
 * Return value  : none 
 *****************************************************************************/
 void cm_cli_get_permission_string(uint32_t perm_ui, char* perm_p)
{
   switch(perm_ui)
   {
      case   CM_PERMISSION_NOACCESS:
         of_strcpy(perm_p, "CM_PERMISSION_NOACCESS");
         break;
      case   CM_PERMISSION_READ_ONLY:
         of_strcpy(perm_p, "CM_PERMISSION_READ_ONLY");
         break;
      case   CM_PERMISSION_READ_WRITE:
         of_strcpy(perm_p, "CM_PERMISSION_READ_WRITE");
         break;
      case   CM_PERMISSION_READ_ROLEPERM:
         of_strcpy(perm_p, "CM_PERMISSION_READ_ROLEPERM");
         break;
      case   CM_PERMISSION_READ_WRITE_ROLEPERM:
         of_strcpy(perm_p, "CM_PERMISSION_READ_WRITE_ROLEPERM");
         break;
   }
}

#endif /* CM_ROLES_PERM_SUPPORT*/

/***************************************************************************
 * Function Name : cm_cli_context_help 
 * Description   : Displays the help depending on the context in which it is
 *        currently in.
 * Input         : NONE
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_context_help (void)
{
   struct cm_cli_data_ele_node *data_ele_node_p;
   UCMDllQNode_t *dll_q_node_p;

   int32_t tmp_cnt_i=0,tmp_i=0,tmp_attrib_cnt_i=0, tmp_mand_cnt_i = 0; 
   char tmp_opt_buff[MAX_A_BUFF_SIZE][MAX_A_BUFF_SIZE];
   char tmp_mand_buff[64][MAX_A_BUFF_SIZE];
   unsigned char check_back_list_b = FALSE, opt_param_b = FALSE, mand_param_b = FALSE, config_b = FALSE;
   char tmp_buff_a[CM_CLI_MAX_PROMPT_LEN];

   of_memset(tmp_opt_buff,0,sizeof(tmp_opt_buff));
   of_memset(tmp_mand_buff,0,sizeof(tmp_mand_buff));
   of_memset(buff_a,0,sizeof(buff_a));
   of_memset(tmp_buff_a,0,sizeof(tmp_buff_a));

   if (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE)
   {
      if(cli_session_p->cd_table_b == FALSE && cli_session_p->context_b)
      {
         config_b = TRUE;
      }
      else if(cli_session_p->cd_table_b == TRUE && cli_session_p->context_b  && cli_session_p->curr_table_ctx_b)
      {
         config_b = TRUE;
      }
   }
   else if(cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR)
   {
      if(cli_session_p->cd_table_b == FALSE)
      {
         if(cli_session_p->current_node_p->parent_trans_b == TRUE)
         {
            config_b = TRUE;
         }
         else //if use parenttrans is false
         {
            //1. verify if its parent is table - skip
            //2. if parent is not table - allow
            //else
            //1. verify bcontext is false - allow - assuming not inside table
            if(cli_session_p->context_b == FALSE)
            {
               config_b = TRUE;
            }
            else //if bcontext is true
            {
               if(of_strcmp(cli_session_p->dmpath_a, cli_session_p->context_path) == 0)
                  config_b = TRUE;
            }
         }
      }
      else if(cli_session_p->cd_table_b == TRUE && cli_session_p->current_node_p->parent_trans_b == FALSE)// && cli_session_p->current_node_p->scalar_group_b == TRUE)
      {
         config_b = TRUE;
      }
   }


   if(config_b ==TRUE)
   {
      CM_DLLQ_SCAN (&cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,
               struct cm_cli_data_ele_node *, list_node);

         {
            mand_param_b = FALSE;
            opt_param_b = FALSE;
            if (data_ele_node_p->mandatory_b && data_ele_node_p->visible_b == TRUE)
            {
               if(data_ele_node_p->key_b == FALSE && data_ele_node_p->non_config_leaf_node_b != TRUE)
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "\t%-20s\t\t", data_ele_node_p->node_name);
                     */
                  sprintf (buff_a, "\t%-32s", data_ele_node_p->node_name);
                  of_strcpy(tmp_mand_buff[tmp_mand_cnt_i],buff_a); 
                  mand_param_b = TRUE;
               }
               else
                  continue;
            }
            else if(data_ele_node_p->non_config_leaf_node_b != TRUE && data_ele_node_p->visible_b == TRUE)
            {
               if(data_ele_node_p->cli_identifier_p)
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "\t%-20s\t:%-10s\t", data_ele_node_p->node_name,
                     data_ele_node_p->cli_identifier_p);
                     */
                  sprintf (tmp_buff_a, "%s(%s)", data_ele_node_p->node_name,
                        data_ele_node_p->cli_identifier_p);
                  sprintf (buff_a, "\t%-32s", tmp_buff_a);

               }
               else
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "\t%-20s\t\t", data_ele_node_p->node_name);
                     */
                  sprintf (buff_a, "\t%-32s", data_ele_node_p->node_name);
               }
               of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i],buff_a);
               opt_param_b = TRUE;
            }
            check_back_list_b=TRUE; 
            if(opt_param_b == TRUE)
            {
               cm_cli_display_attrib_info (data_ele_node_p,tmp_opt_buff,tmp_attrib_cnt_i);
               if(data_ele_node_p->cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], "\r\n\tNote:");
                  of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
               }        
               tmp_attrib_cnt_i++;
            }
            if(mand_param_b == TRUE)
            {
               cm_cli_display_attrib_info (data_ele_node_p,tmp_mand_buff,tmp_mand_cnt_i);
               if(data_ele_node_p->cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], "\r\n\tNote:");
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], data_ele_node_p->cli_idenetifier_help_p);
               }        
               tmp_mand_cnt_i++;
            }
         }
      }
   }

   if( (tmp_mand_cnt_i > 0) || (tmp_attrib_cnt_i > 0) )
   {
      cm_cli_puts (cli_session_p, "\n\tUse \'set\' command to configure parameters: \n\t");
      cm_cli_puts (cli_session_p,"set [ParamName1 <value>]...  [ParamNameN <value>]\n\r");
      cm_cli_puts (cli_session_p, "\n");
   }
   for(tmp_i = 0; tmp_i < tmp_mand_cnt_i; tmp_i++)
   {
      if(tmp_i == 0)
         cm_cli_puts(cli_session_p," Mandatory Parameter(s):\r\n");
      cm_cli_puts (cli_session_p, tmp_mand_buff[tmp_i]);
      cm_cli_puts(cli_session_p,"\n");
   }
   for(tmp_i = 0; tmp_i < tmp_attrib_cnt_i; tmp_i++)
   {
      if(tmp_i == 0)
         cm_cli_puts(cli_session_p," Optional Parameter(s):\r\n");
      cm_cli_puts (cli_session_p, tmp_opt_buff[tmp_i]);
      cm_cli_puts(cli_session_p,"\n");
   }
   cm_cli_puts (cli_session_p, "\n\t");

   //Not to display anchors and tables when user entered "igd/>vsg general","igd/vsg general/><tab>"
   if ((of_strcmp(cli_session_p->current_node_p->node_name, "vsg") == 0) && (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) && (cli_session_p->context_b))
   {
      return OF_SUCCESS;
   }
   //////////////////Avoided only for vsg table and bcontext = true////////////////////////

   of_memset(buff_a,0,sizeof(buff_a));
   of_memset(tmp_opt_buff,0,sizeof(tmp_opt_buff));
   CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p, UCMDllQNode_t *)
   {
      data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p,
            struct cm_cli_data_ele_node *, list_node);
      if(data_ele_node_p->visible_b == TRUE)
      {
         if (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "%s (Table) \n\t", data_ele_node_p->node_name);
               */
            sprintf (buff_a, "%s\n\t", data_ele_node_p->node_name);
         }
         else if ((data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR))
         {
            sprintf (buff_a, "%s / \n\t", data_ele_node_p->node_name);
         }
         else
         {
            sprintf (buff_a, "%s \n\t", data_ele_node_p->node_name);
         }
         if (data_ele_node_p->mandatory_b)
         {
            sprintf (buff_a, "\t%s*", buff_a);
         }
         of_strncpy(tmp_opt_buff[tmp_cnt_i],buff_a,of_strlen(buff_a));
         tmp_cnt_i++;
      }
   }

   for(tmp_i = 0; tmp_i < tmp_cnt_i; tmp_i++)
      cm_cli_puts (cli_session_p, tmp_opt_buff[tmp_i]);
   cm_cli_puts (cli_session_p, "\n\r");

   if (cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == FALSE && config_b == FALSE)
   {
      cm_cli_puts(cli_session_p,"\n\rOnly the following commands can be used at this context:\n\t");
#ifdef CM_ROLES_PERM_SUPPORT
      cm_cli_puts(cli_session_p,"setrole\n\tgetrole\n\tcd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\r\n");
#else
      cm_cli_puts(cli_session_p,"cd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\n\tsave\n\tdel\r\n");
#endif
   }
   return OF_SUCCESS;
}

//Display child info table, used when not in context
//ex: radiusconf test/>acctsrvr 1.1.1.1 <tab>
/***************************************************************************
 * Function Name : cm_cli_display_child_node_info 
 * Description   : Displays the child nodes in the current context
 * Input         : NONE
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_child_node_info(void)
{
   struct cm_dm_node_info *tmp_node_info_p;
   unsigned char mand_param_b = FALSE, opt_param_b = FALSE, key_param_b = FALSE;
   char tmp_key_buff[16][MAX_A_BUFF_SIZE];
   char tmp_mand_buff[64][MAX_A_BUFF_SIZE];
   char tmp_opt_buff[MAX_A_BUFF_SIZE][MAX_A_BUFF_SIZE];
   char tmp_buff_a[CM_CLI_MAX_PROMPT_LEN];
   uint32_t ii = 0, cnt_ui = 0, tmp_attrib_cnt_i = 0, tmp_mand_cnt_i = 0, tmp_key_cnt_i = 0;

   if(table_info_arr_p_g == NULL)
   {
      return OF_FAILURE;
   }

   for (ii = 0; ii < table_info_arr_p_g->count_ui; ii++)
   {
      mand_param_b = FALSE;
      opt_param_b = FALSE;
      key_param_b = FALSE;
      tmp_node_info_p = (struct cm_dm_node_info *) (table_info_arr_p_g->struct_arr_p) + ii;
      if(tmp_node_info_p != NULL)
      {
         of_memset(buff_a, 0, sizeof(buff_a));
         //if(tmp_node_info_p->element_attrib.element_type != CM_DMNODE_TYPE_TABLE )
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR  && tmp_node_info_p->element_attrib.visible_b == TRUE)
         {
            if (tmp_node_info_p->element_attrib.mandatory_b == TRUE && tmp_node_info_p->element_attrib.non_config_leaf_node_b != TRUE)
            {
               /* //VortiQa Requirement
                  sprintf (buff_a, "%-20s\t::\t\t", tmp_node_info_p->name_p);
                  */
               sprintf (buff_a, "%-32s: ", tmp_node_info_p->name_p);
               of_strcpy(tmp_buff_a,buff_a); 
               if (tmp_node_info_p->element_attrib.key_b == TRUE )
                  key_param_b = TRUE;
               else
                  mand_param_b = TRUE;
            }
            else if(tmp_node_info_p->element_attrib.non_config_leaf_node_b != TRUE)
            {
               if(tmp_node_info_p->element_attrib.cli_identifier_p)
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "%-20s\t::\t%s\t", tmp_node_info_p->name_p                                 ,tmp_node_info_p->element_attrib.cli_identifier_p);  
                     */
                  sprintf (tmp_buff_a, "%s(%s)", tmp_node_info_p->name_p                                 ,tmp_node_info_p->element_attrib.cli_identifier_p);  
                  sprintf (buff_a, "%-32s: ", tmp_buff_a);  
               }
               else
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "%-20s\t::\t\t", tmp_node_info_p->name_p);
                     */
                  sprintf (buff_a, "%-32s: ", tmp_node_info_p->name_p);
               }
               of_strcpy(tmp_buff_a,buff_a); 
               opt_param_b = TRUE;
            }

            switch (tmp_node_info_p->data_attrib.data_type)
            {
               case CM_DATA_TYPE_STRING:
               case CM_DATA_TYPE_STRING_SPECIAL_CHARS:
                  of_strcat(tmp_buff_a," String"); 
                  break;
               case CM_DATA_TYPE_INT:
                  of_strcat(tmp_buff_a, " Integer ");
                  break;
               case CM_DATA_TYPE_UINT:
                  of_strcat(tmp_buff_a, " Unsigned Integer ");
                  break;
               case CM_DATA_TYPE_INT64:
                  of_strcat(tmp_buff_a, " Long Integer ");
                  break;
               case CM_DATA_TYPE_UINT64:
                  of_strcat(tmp_buff_a, " Unsigned Long Integer ");
                  break;
               case CM_DATA_TYPE_BOOLEAN:
                  of_strcat(tmp_buff_a, " Boolean ");
                  break;
               case CM_DATA_TYPE_DATETIME:
                  of_strcat(tmp_buff_a, " Date and Time ");
                  break;
               case CM_DATA_TYPE_BASE64:
                  of_strcat(tmp_buff_a, " Base64 ");
                  break;
               case CM_DATA_TYPE_IPADDR:
                  of_strcat(tmp_buff_a, " IPv4 Address ");
                  break;
               case CM_DATA_TYPE_UNKNOWN:
                  of_strcat(tmp_buff_a, " - ");
                  break;
            }
            switch (tmp_node_info_p->data_attrib.attrib_type)
            {
               case CM_DATA_ATTRIB_NONE:
                  break;
               case CM_DATA_ATTRIB_INT_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.int_range.start_value,
                        tmp_node_info_p->data_attrib.attr.int_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_UINT_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.uint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.uint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_INT_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.int_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%d",
                           tmp_node_info_p->data_attrib.attr.int_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a, buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_UINT_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.uint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%u",
                           tmp_node_info_p->data_attrib.attr.uint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_INT64_RANGE:
                  sprintf (buff_a, " [ %ld to %ld ]",
                        tmp_node_info_p->data_attrib.attr.longint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.longint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_UINT64_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.ulongint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.ulongint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_INT64_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.longint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%ld",
                           tmp_node_info_p->data_attrib.attr.longint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a, buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_UINT64_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.ulongint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%u",
                           tmp_node_info_p->data_attrib.attr.ulongint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_STR_ENUM:
                  of_strcat(tmp_buff_a, " { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.string_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%s",
                           tmp_node_info_p->data_attrib.attr.string_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;

               case CM_DATA_ATTRIB_STR_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.string_range.min_length,
                        tmp_node_info_p->data_attrib.attr.string_range.max_length);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_IPADDR_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.ip_enum.count_ui;cnt_ui++)
                  {
                     sprintf (buff_a, "%s",
                           tmp_node_info_p->data_attrib.attr.ip_enum.ip_arr_a[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_IPADDR_RANGE:
                  sprintf (buff_a, " Start IP: (%s) ",
                        tmp_node_info_p->data_attrib.attr.ip_range.start_ip);
                  of_strcat(tmp_buff_a,buff_a);
                  sprintf (buff_a, " End IP: (%s)",
                        tmp_node_info_p->data_attrib.attr.ip_range.end_ip);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               default:
                  cm_cli_puts (cli_session_p, " Unknown type: default");
                  break;
            }  
            if(key_param_b == TRUE)
            {
               of_strcpy(tmp_key_buff[tmp_key_cnt_i], tmp_buff_a);
               tmp_key_cnt_i++;
            }  
            if(mand_param_b == TRUE)
            {
               of_strcpy(tmp_mand_buff[tmp_mand_cnt_i], tmp_buff_a);
               if(tmp_node_info_p->element_attrib.cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], "\r\n\tNote:");
                  of_strcat(tmp_mand_buff[tmp_mand_cnt_i], tmp_node_info_p->element_attrib.cli_idenetifier_help_p);
               }        
               tmp_mand_cnt_i++;
            }  
            if(opt_param_b == TRUE)
            {
               of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i], tmp_buff_a);
               if(tmp_node_info_p->element_attrib.cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], "\r\n\tNote:");
                  of_strcat(tmp_opt_buff[tmp_attrib_cnt_i], tmp_node_info_p->element_attrib.cli_idenetifier_help_p);
               }        
               tmp_attrib_cnt_i++;    
            }  
         }  
      }
   }
   if(tmp_key_cnt_i > 1)
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a,"\n%s <Keyparam_value1 Keyparam_value2 ... Keyparam_valueN> <Mandparam_value1 Mandparam_value2 ... Mandparam_valueN> [OptParamName1 <value>] ... [OptParamNameN <value>]\n\n",table_name_a_g);
      cm_cli_puts(cli_session_p, buff_a);
   }
   else
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a, "\n%s <Keyparam_value> <Mandparam_value1 Mandparam_value2 ... Mandparam_valueN> [OptParamName1 <value>] ... [OptParamNameN <value>]\n\n", table_name_a_g);
      cm_cli_puts(cli_session_p, buff_a);
   }
   //Display scalars
   for(cnt_ui = 0; cnt_ui < tmp_key_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, " Key Parameter(s):\n\t");
      cm_cli_puts(cli_session_p, tmp_key_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }
   for(cnt_ui = 0; cnt_ui < tmp_mand_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, "\n Mandatory Parameter(s) (in the order):\n\t");
      cm_cli_puts(cli_session_p, tmp_mand_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }
   for(cnt_ui = 0; cnt_ui < tmp_attrib_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, "\n Optional Parameter(s):\n\t");
      cm_cli_puts(cli_session_p, tmp_opt_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }

   //Should not display anchors and tables on igd/>vsg general <tab>
   if(of_strcmp(table_name_a_g, "vsg") == 0)
      return;

   tmp_attrib_cnt_i = 0;
   for (ii = 0; ii < table_info_arr_p_g->count_ui; ii++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (table_info_arr_p_g->struct_arr_p) + ii;
      if(tmp_node_info_p != NULL && tmp_node_info_p->element_attrib.visible_b == TRUE)
      {
         //Display Anchors
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR )
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "\n\t%-20s", tmp_node_info_p->name_p);  
               */
            sprintf (buff_a, "\n\t%s/", tmp_node_info_p->name_p);  
            cm_cli_puts(cli_session_p, buff_a);
         }
         //Display tables
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE )
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "\n\t%-20s (table)", tmp_node_info_p->name_p);  
               */
            sprintf (buff_a, "\n\t%s", tmp_node_info_p->name_p);  
            of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i], buff_a);
            tmp_attrib_cnt_i++;
            //  cm_cli_puts(cli_session_p, buff_a);
         }
      }
   }
   for(cnt_ui = 0; cnt_ui < tmp_attrib_cnt_i; cnt_ui++)
   {
      cm_cli_puts(cli_session_p, tmp_opt_buff[cnt_ui]);
   }
   cm_cli_puts(cli_session_p, "\r\n");
}

/***************************************************************************
 * Function Name : cm_cli_auto_complete
 * Description   : This callback API is used to provide the AutoComplete
 *                 facility for the CLI engine. When the user press TAB key,
 *                 this API will get invoked and will display any uncompleted
 *                 string. If user has not entered any characters, it will
 *                 list out all the available commands.
 * Input         : el - pointer to line editor
 *                 ch - is the keyboard key which caused the invocation of
 *                 this function.
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE / appropriate error.
 ***************************************************************************/
unsigned char cm_cli_auto_complete (edit_line * el, int ch)
{
   uint16_t ii, jj, kk, token_len_ui, len_ui = 0, match_count_ui = 0, temp_tok_len_ui = 0,
            match_index_ui = 0, min_length = 0, min_index_ui = 0, cmd_len_ui = 0, start_i = 0, glb_end_pos_ui = 0;
   const line_info *line_p;
   char token_a[CM_CLI_MAX_NAME_LEN + 1] = { 0 }, *p, *partial_p, temp_str1_a[CM_CLI_MAX_NAME_LEN + 1] = {0},  temp_str2_a[CM_CLI_MAX_NAME_LEN + 1] ={0}, *cmd_p, cmd_token_a[CM_CLI_MAX_NAME_LEN +1] = { 0 },  value_a[CM_CLI_MAX_NAME_LEN + 1] = { 0 };
   unsigned char done_b = 0, name_found_b = FALSE, identifier_found_b = FALSE, found_b = FALSE , is_tab_pressed_b = TRUE;
   struct cm_cli_session *tmp_cli_session_p;
   struct cm_array_of_strings *string_arr_p = NULL;
   struct cm_dm_node_info *node_info_p = NULL, *tmp_node_info_p = NULL, *tmp_node_info_arr_p = NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];
   UCMDllQNode_t *dll_q_node_p;
   struct cm_cli_data_ele_node* data_ele_node_p;
   unsigned char tab_b = FALSE, glb_cmd_b = FALSE, cmd_b = FALSE, partial_b = FALSE;
   uint32_t tab_cnt_ui = 0, i = 0, str_len_ui = 0, ary_strs_cnt_ui = 0;
   char *tok_name_p = NULL, *tok_identifier_p = NULL; //*value_p = NULL;
   uint32_t match_index_array_ui[MAX_A_BUFF_SIZE] = {0};
   uint32_t index_ui = 0;
   unsigned char parent_trans_b = FALSE;

   if (el == NULL)
   {
      cm_cli_puts (cli_session_p, " Invalid input.\n\r");
      return (CC_ERROR);
   }

   /* Initialize line_p */
   line_p = of_el_line (el);
   /* Traverse the command line from last character and point to the begining
    * of the un-completed word*/
   for (p = (char *) line_p->cursor - 1; (*p != ' ') && (p >= line_p->buffer);
         p--)
   {
      continue;
   }

   /* Get the length of the un-complete word */
   token_len_ui = line_p->cursor - (p+1);
   if(token_len_ui > 0)
      partial_b = TRUE;

   //Reading command name when "command sh<tab>", where command can be global or nonglobal
   if((*p == ' '))
   {
      cmd_len_ui = 0;
      glb_cmd_b = FALSE;
      for(cmd_p = (char *)line_p->buffer; (*cmd_p != ' '); cmd_p++)
      {
         cmd_len_ui++;
         continue;
      }
      of_strncpy (cmd_token_a, (char *)line_p->buffer, cmd_len_ui);
      //Verify if the command is global ex:set, cd, show etc
      for (i = 0; i < CM_CLI_MAX_CMD; i++)
      {
         if (of_strcmp ((char*)cmd_token_a, cm_cli_default_cmd_list[i].command_name_c) == 0)
         {
            glb_cmd_b = TRUE;
         }
      }
      if((token_len_ui > 0) && (glb_cmd_b == FALSE))
      {
         cmd_b = TRUE;
         tab_b = FALSE;
      }
      else if((token_len_ui == 0) && (glb_cmd_b == FALSE))
      {
         cmd_b = FALSE;
         tab_b = TRUE;
         of_strncpy (token_a, cmd_token_a, cmd_len_ui);
         token_len_ui = 0;
         temp_tok_len_ui = 0;
         tab_cnt_ui = 0;
      }

   }
   p++;

   if(token_len_ui == 0) //verifying if the command is "non-global<space><tab>"
   {
      //verifying if user entered some value before space. ex:acctsvr <tab>
      for (p = (char *) line_p->cursor - 1; (p >= line_p->buffer); p--)
      {
         if(*p == ' ') 
         {
            if( (p+1) == line_p->cursor) //if space is found only at the end
            {
               tab_b = TRUE;
            }
            else // if space is found in the middle exit. ex: set xxx <tab>
            {
               tab_cnt_ui++;
               p = (char *) line_p->cursor - 1;
               break;
            }
         }        
         continue;
      }
   }
   if ((cmd_b == FALSE) && token_len_ui) //ex: rad<tab> or acctsrvr <tab>
   {
      /* Copy last word from the Command line into token_a */
      of_strncpy (token_a, p, token_len_ui);
   }
   else if(cmd_b == TRUE)//if it is a non global command and ex: acctsrvr 1.1.1.1 sh<tab>
   {
      of_strncpy (temp_str1_a, p, token_len_ui);
      of_strcpy(token_a, cmd_token_a);
      tab_b = TRUE;
   }
   else if(tab_b == TRUE && token_len_ui == 0 && glb_cmd_b == FALSE)
   {
      token_len_ui = cmd_len_ui;
   }

   tmp_cli_session_p = cli_session_p;

   /* If only TAB is pressed without typing anything, list all the available
    * commands. */
   if (token_len_ui == 0)
   {
      //if the command is not show
      if((of_strcmp(cmd_token_a , "show") != 0)) 
      {
         /* if (((cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) && (cli_session_p->context_b))   || (cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR))
            {
            cm_cli_puts (cli_session_p, "\n\tUse \'set\' command to configure parameters :: \n\t");
            cm_cli_puts (cli_session_p,"set [ParamName1 <value>] ... [ParamNameN <value>]\n\r");
            cm_cli_puts (cli_session_p, "\n");
            }*/
      }
      else
      {
         cm_cli_puts(cli_session_p,"\n");
      }
      if(cm_cli_context_help() == OF_SUCCESS)
      {
         if((of_strcmp(cmd_token_a, "") == 0) && (cli_session_p->config_session_p != NULL) && 
               (cli_session_p->cd_table_b == FALSE || (cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == TRUE)) )
         {
            if( ((cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) && (cli_session_p->current_node_p->parent_trans_b == TRUE))
                  || ((cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR) && (cli_session_p->current_node_p->scalar_group_b == TRUE) && 
                     (cli_session_p->current_node_p->parent_trans_b == TRUE) && (cli_session_p->current_node_p->non_config_leaf_node_b != TRUE)) )
            {
               cm_cli_puts(cli_session_p, " Use below commands to save or cancel the changes:\n\t");
               cm_cli_puts(cli_session_p, "done\n\t");
               cm_cli_puts(cli_session_p, "cancel\n\r\n\r");
            }  
            if ( ((cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_TABLE) && (cli_session_p->current_node_p->parent_trans_b == FALSE))
                  || ((cli_session_p->current_node_p->node_type_ui == CM_DMNODE_TYPE_ANCHOR) && (cli_session_p->current_node_p->scalar_group_b == TRUE) && 
                     (cli_session_p->current_node_p->parent_trans_b == FALSE && cli_session_p->context_b && (of_strcmp(cli_session_p->dmpath_a, cli_session_p->context_path) == 0)) && (cli_session_p->current_node_p->non_config_leaf_node_b != TRUE)) ) //ANCHOR REQUIRED -DEEPTHI
            {
               cm_cli_puts(cli_session_p, " Use below commands to save or cancel the changes:\n\t");
               cm_cli_puts(cli_session_p, "commit\n\t");
               cm_cli_puts(cli_session_p, "revoke\n\r\n\r");
            }  
         }
         return CC_REDISPLAY;
      }

      cm_cli_puts (tmp_cli_session_p, "\n\r");
      cm_cli_puts (tmp_cli_session_p, "\t");
      for (ii = 0; ii < string_arr_p->count_ui; ii++)
      {
         sprintf (buff_a, "%s", string_arr_p->string_arr_p[ii]);
         cm_cli_puts (cli_session_p, buff_a);
         cm_cli_puts (cli_session_p, "\n\t");
      }

      cm_cli_puts (cli_session_p, "\n\r");
      return (CC_REDISPLAY);
   }

   //If the command is of format "non-global<space><tab>"
   if((token_len_ui > 0) && (tab_b == TRUE)) //Auto completion, Ex: acctsrvr 1.1.1.1 sh<tab>
   {
      if(cmd_b == TRUE)
      {
         CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,UCMDllQNode_t *)
         {
            data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,list_node);

            if (of_strcmp (token_a, data_ele_node_p->node_name) == 0)
            {
               if (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
               {
                  parent_trans_b = data_ele_node_p->parent_trans_b;
                  if( (of_strncmp(table_name_a_g, token_a, of_strlen(token_a)) == 0) && 
                        (table_info_arr_p_g != NULL && table_info_arr_p_g->count_ui > 0))
                  {
                     if(child_info_arr_p)
                     {
                        of_free(child_info_arr_p);
                        child_info_arr_p = NULL;
                     }
                     child_info_arr_p = (struct cm_array_of_structs *)of_calloc(1, sizeof(struct cm_array_of_structs));
                     if(child_info_arr_p != NULL)
                     {
                        child_info_arr_p->count_ui = table_info_arr_p_g->count_ui;  
                        child_info_arr_p->struct_arr_p = (void*) table_info_arr_p_g->struct_arr_p;
                     }
                  }
                  else
                  {
                     of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
                     of_strcat (dmpath_a, ".");
                     of_strcat (dmpath_a, token_a);
                     if (cm_dm_get_node_and_child_info (tmp_cli_session_p->tnsprt_channel_p,
                              dmpath_a, CM_CLI_MGMT_ENGINE_ID,
                              &tmp_cli_session_p->role_info,
                              &node_info_p, &child_info_arr_p) != OF_SUCCESS)
                     {
#ifdef CM_CLI_DEBUG 
                        sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
                              __FUNCTION__);
                        cm_cli_puts (cli_session_p, buff_a);
#endif
                        return (CC_ERROR);
                     }
                     //caching table details
                     of_memset(table_name_a_g, 0, sizeof(table_name_a_g));
                     of_strncpy(table_name_a_g, token_a, of_strlen(token_a));
                     table_info_arr_p_g = (struct cm_array_of_structs*)of_calloc(1,
                           sizeof(struct cm_array_of_structs));
                     if((table_info_arr_p_g != NULL) && (child_info_arr_p->count_ui > 0))
                     {
                        table_info_arr_p_g->count_ui = child_info_arr_p->count_ui;
                        tmp_node_info_arr_p = (struct cm_dm_node_info*)of_calloc(child_info_arr_p->count_ui, 
                              sizeof(struct cm_dm_node_info));
                        for (ii = 0, jj = 0; ii < child_info_arr_p->count_ui; ii++)
                        {
                           tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
                           if(tmp_node_info_p != NULL)
                           {
                              cm_cli_copy_node_info_into_array(tmp_node_info_p, tmp_node_info_arr_p, ii);
                           }
                        }
                        table_info_arr_p_g->struct_arr_p = (void*)tmp_node_info_arr_p;
                     }
                  }
                  strcpy(token_a, temp_str1_a);
                  token_len_ui = of_strlen(temp_str1_a);  
                  string_arr_p =
                     (struct cm_array_of_strings *) of_calloc (1, sizeof (struct cm_array_of_strings));
                  if (string_arr_p == NULL)
                  {
#ifdef CM_CLI_DEBUG 
                     sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
                     cm_cli_puts (cli_session_p, buff_a);
#endif
                     return (CC_ERROR);
                  }
                  string_arr_p->count_ui = 1;

                  string_arr_p->string_arr_p = (char **) of_calloc (string_arr_p->count_ui,
                        sizeof (unsigned char *));
                  if (string_arr_p->string_arr_p == NULL)
                  {
#ifdef CM_CLI_DEBUG 
                     sprintf (buff_a, "%s :: Memory allocation failed\n\r", __FUNCTION__);
                     cm_cli_puts (cli_session_p, buff_a);
#endif
                     of_free (string_arr_p);
                     return (CC_ERROR);
                  }
                  match_count_ui = 0;
                  for (ii = 0, jj = 0; ii < child_info_arr_p->count_ui; ii++)
                  {
                     found_b =FALSE;
                     tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
                     if(tmp_node_info_p != NULL)
                     {
                        if( (of_strncmp (token_a, tmp_node_info_p->name_p, token_len_ui) == 0) || 
                              ( (tmp_node_info_p->element_attrib.cli_identifier_p) &&
                                (of_strncmp (token_a, tmp_node_info_p->element_attrib.cli_identifier_p, token_len_ui) == 0)) )
                        {
                           match_count_ui++;
                           if(match_count_ui > string_arr_p->count_ui)
                           {
                              string_arr_p->count_ui++;
                              ary_strs_cnt_ui = string_arr_p->count_ui;
                              string_arr_p->string_arr_p = (char **) of_realloc (string_arr_p->string_arr_p,(ary_strs_cnt_ui * sizeof (unsigned char *)) );
                           }
                           if(string_arr_p->string_arr_p == NULL)
                           {
                              return (CC_REDISPLAY);
                           }
                           found_b = TRUE;

                        }        
                        if(found_b == TRUE)
                        {
                           str_len_ui = of_strlen (tmp_node_info_p->name_p);
                           if(tmp_node_info_p->element_attrib.cli_identifier_p)
                           {
                              str_len_ui += of_strlen (tmp_node_info_p->element_attrib.cli_identifier_p);
                              str_len_ui += 2; //to add "(" and ")" in between name and identifier.
                           }
                           string_arr_p->string_arr_p[jj] = (char *) of_calloc (1, str_len_ui + 1);
                           if (string_arr_p->string_arr_p[jj] != NULL)
                           {
                              of_strncpy (string_arr_p->string_arr_p[jj],tmp_node_info_p->name_p, str_len_ui);
                              if(tmp_node_info_p->element_attrib.cli_identifier_p)
                              {
                                 of_strcat(string_arr_p->string_arr_p[jj], "(");
                                 of_strncat (string_arr_p->string_arr_p[jj],tmp_node_info_p->element_attrib.cli_identifier_p, str_len_ui);
                                 of_strcat(string_arr_p->string_arr_p[jj], ")");
                              }
                              jj++;
                           }
                        }
                     }
                  }
                  if(match_count_ui == 0)
                  {
                     of_free(string_arr_p);
                     string_arr_p = NULL;
                     return (CC_REDISPLAY);
                  }
               }
            }
         }
      }
      else if(tab_cnt_ui > 0)  //Ex: acctsrvr 1.1.1.1 <tab>
      {
         CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p,UCMDllQNode_t *)
         {
            data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,list_node);

            if (of_strcmp (data_ele_node_p->node_name, (char *)token_a) == 0)
            {
               if (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
               {
                  parent_trans_b = data_ele_node_p->parent_trans_b;
                  if(of_strcmp(table_name_a_g, token_a) == 0)
                  {
                     cm_cli_display_child_node_info();
                  }
                  else
                  {
                     /* Display all the Instances and KeyParameter Name for that
                      * Table */
                     if(data_ele_node_p->system_command_b == FALSE)
                     {
                        cm_cli_display_instances_and_key_params (data_ele_node_p->node_name,FALSE);
                     }
                     else
                     {
                        cm_cli_display_instances_and_key_params (data_ele_node_p->node_name,TRUE);
                     }
                  }
               }
            }
         }
         return (CC_REDISPLAY);
      }
      else //Ex: acctsrvr <tab>
      {
         //verifying if the entered command is anchor. if anchor need not interpret cmd.
         //Ex: igd/vsg{general}/>fir<tab>
         //igd/vsg{general}/>firewall
         //igd/vsg{general}/>firewall <tab>
         //should not do anything. must wait for "enter".
         CM_DLLQ_SCAN (&cli_session_p->current_node_p->child_list, dll_q_node_p,UCMDllQNode_t *)
         {
            data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,list_node);

            if (of_strcmp (data_ele_node_p->node_name, (char *)token_a) == 0)
            {
               if(data_ele_node_p->node_type == CM_DMNODE_TYPE_ANCHOR)
               {
                  return (CC_REDISPLAY);
               }
               else if(data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
               {
                  parent_trans_b = data_ele_node_p->parent_trans_b;
               }
               else
                  break;
            }
         }
         if( (cli_session_p->cd_table_b == TRUE && (cli_session_p->curr_table_ctx_b == FALSE && parent_trans_b == TRUE)) || 
               (cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == FALSE && parent_trans_b == FALSE && 
                cli_session_p->dmpath_a[of_strlen(cli_session_p->dmpath_a)-1] != '}') )
         {
            cm_cli_puts(cli_session_p,"\n\rOnly the following commands can be used at this context:\n\t");
#ifdef CM_ROLES_PERM_SUPPORT
            cm_cli_puts(cli_session_p,"setrole\n\tgetrole\n\tcd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\r\n");
#else
            cm_cli_puts(cli_session_p,"cd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\n\tsave\n\tdel\r\n");
#endif
            return CC_REDISPLAY;
         }
         cm_cli_interpret_command(tmp_cli_session_p, token_a, is_tab_pressed_b);
         return (CC_REDISPLAY);
      }
   }
   else
   {
      if (tmp_cli_session_p->string_arr_p == NULL)
      {
         return CC_ERROR;
      }
      string_arr_p = tmp_cli_session_p->string_arr_p;
   }

   /* Scan through the Cli Default command list */
   match_count_ui = 0;
   if(glb_cmd_b == TRUE)
   {
      //for global command like "set r<tab>" should not display global commands like revoke in the list.
      found_b = FALSE;
      glb_end_pos_ui = 0;
      for(ii = 0; ii < string_arr_p->count_ui; ii++)
      {
         if(ii > 0 && found_b == FALSE)
         {
            start_i = glb_end_pos_ui+1;
            found_b = TRUE;
            break;
         }
         found_b = FALSE;  
         for (jj = 0; jj < CM_CLI_MAX_CMD; jj++)
         {
            if(strncmp(string_arr_p->string_arr_p[ii], cm_cli_default_cmd_list[jj].command_name_c, of_strlen(string_arr_p->string_arr_p[ii])) == 0)
            {
               glb_end_pos_ui = ii;
               found_b = TRUE;
               break;
            }
         }
      }
      if(found_b == FALSE)
         start_i = 0; 
      //  start_i =  CM_CLI_MAX_CMD; 
   }
   else
   {
      start_i = 0;
   }
   if(string_arr_p == NULL)
   {
      return (CC_ERROR);
   }
   of_memset(value_a, 0, sizeof(value_a));
   for (ii = start_i; ii < string_arr_p->count_ui; ii++)
   {
      of_strcpy(temp_str1_a, string_arr_p->string_arr_p[ii]);
      //splitting "/" from the string//
      tok_name_p = of_strtok(temp_str1_a, "(");
      tok_identifier_p = of_strtok(NULL, "(");
      name_found_b = FALSE;
      identifier_found_b = FALSE;
      //////////////////
      if (of_strncmp (token_a, string_arr_p->string_arr_p[ii], token_len_ui) == 0)
      {
         name_found_b = TRUE;
         of_strcpy(value_a, tok_name_p);
      }
      else if(tok_identifier_p && (of_strncmp (token_a, tok_identifier_p, token_len_ui) == 0) )
      {
         identifier_found_b = TRUE;
         of_strncpy(value_a, tok_identifier_p, (of_strlen(tok_identifier_p)-1) );
      }
      if(name_found_b == TRUE || identifier_found_b == TRUE)
      {
         match_index_array_ui[match_count_ui] = ii; //Deepthi
         match_count_ui++;
         match_index_ui = ii;

         if(name_found_b == TRUE)
            len_ui = of_strlen (string_arr_p->string_arr_p[ii]);
         else
            len_ui = of_strlen (tok_identifier_p);
         if ((min_length == 0) || (len_ui < min_length))
         {
            min_index_ui = ii;
            min_length = len_ui;
         }
      }
   }
   if (match_count_ui == 1)
   {
      /* Display the string */
      partial_p = of_calloc (1, (len_ui - token_len_ui) + 2);
      if (!partial_p)
      {
         return CC_ERROR;
      }

      of_strcpy(temp_str1_a, value_a);
      of_strncpy (partial_p, &temp_str1_a[token_len_ui], len_ui - token_len_ui);
      of_strcat (partial_p, " ");
      if (of_el_insertstr (el, partial_p) == -1)
      {
         of_free (partial_p);
         if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
         {
            of_free(string_arr_p);
            string_arr_p = NULL;
         }
         return (CC_ERROR);
      }
      of_free (partial_p);
      if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui == 0))
      {
         of_free(string_arr_p);
         string_arr_p = NULL;
      }
      return (CC_REDISPLAY);
   }
   else if(match_count_ui > 1)//if match count is greater than 1
   {
      of_strcpy (temp_str2_a, string_arr_p->string_arr_p[min_index_ui]);
      for (kk = token_len_ui; kk < min_length; kk++)
      {
         for(ii = 0; ii < match_count_ui; ii++)
         {
            index_ui = match_index_array_ui[ii];
            of_strcpy (temp_str1_a, string_arr_p->string_arr_p[index_ui]);
            //splitting "/" from the string//
            tok_name_p = of_strtok(temp_str1_a, "(");
            tok_identifier_p = of_strtok(NULL, "(");
            //////////////////
            if (of_strncmp (token_a, temp_str1_a, token_len_ui) == 0)
            {
               if ((ii != min_index_ui) && (temp_str1_a[kk] != temp_str2_a[kk]))
               {
                  done_b = 1;
                  break;
               }
            }
            if(tok_identifier_p && (of_strncmp (token_a, tok_identifier_p, token_len_ui) == 0))
            {
               of_strcpy (temp_str1_a, tok_identifier_p);
               if ((ii != min_index_ui) && (temp_str1_a[kk] != temp_str2_a[kk]))
               {
                  done_b = 1;
                  break;
               }
            }
         }
         if ((done_b == 1) || (kk >= min_length))
         {
            break;
         }
      }

      if ((kk < min_length) && (kk != token_len_ui))
      {
         partial_p = (char *) of_calloc (1, of_strlen (temp_str2_a) + 1);
         if (partial_p)
         {
            of_strncpy (partial_p, &temp_str2_a[token_len_ui], kk - token_len_ui);
            if (of_el_insertstr (el, partial_p) == -1)
            {
               sprintf (buff_a, " Error(%d)\n\r", __LINE__);
               cm_cli_puts (cli_session_p, buff_a);
               of_free (partial_p);
               if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
               {
                  of_free(string_arr_p);
                  string_arr_p = NULL;
               }
               return (CC_ERROR);
            }
            else
            {
               of_free (partial_p);
               if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
               {
                  of_free(string_arr_p);
                  string_arr_p = NULL;
               }
               return (CC_REDISPLAY);
            }
         }
      }
      else if (kk == min_length)
      {
         partial_p = (char *) of_calloc (1, of_strlen (temp_str2_a) + 2);
         if (partial_p)
         {
            of_strncpy (partial_p, &temp_str2_a[token_len_ui], kk - token_len_ui);
            of_strcat (partial_p, " ");
            if (of_el_insertstr (el, partial_p) == -1)
            {
               sprintf (buff_a, " Error(%d)\n\r", __LINE__);
               cm_cli_puts (cli_session_p, buff_a);
               of_free (partial_p);
               if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
               {
                  of_free(string_arr_p);
                  string_arr_p = NULL;
               }
               return (CC_ERROR);
            }
            else
            {
               of_free (partial_p);
               if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
               {
                  of_free(string_arr_p);
                  string_arr_p = NULL;
               }
               return (CC_REDISPLAY);
            }
         }
      }

      cm_cli_puts (cli_session_p, "\n\r");

      for(jj = 0; jj < match_count_ui; jj++)
      {
         index_ui = match_index_array_ui[jj];
         cm_cli_puts (cli_session_p, "\n\t");
         sprintf (buff_a, "%s", string_arr_p->string_arr_p[index_ui]);
         cm_cli_puts (cli_session_p, buff_a);
      }//End of For Loop
   }//Match count is greater than 1

   if((cmd_b == TRUE)&&(string_arr_p && string_arr_p->count_ui > 0))
   {
      of_free(string_arr_p);
      string_arr_p = NULL;
   }
   cm_cli_puts (cli_session_p, "\n\r");
   return (CC_REDISPLAY);
}

/***************************************************************************
 * Function Name : cm_cli_display_param_value
 * Description   : This API is used to get the value of a Parameter from the
 *               : security application and will display it's value.
 * Input         : param_name_p - Name of the Parameter to be displayed
 * Output        : NONE
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_display_param_value (char * param_name_p)
{
   int32_t return_value, ii;
   struct cm_array_of_nv_pair *keys_array_p = NULL;
   struct cm_array_of_nv_pair *out_array_of_nv_pair_arr = NULL;
   struct cm_cli_session *tmp_cli_session_p = cli_session_p;

   /* Get the Row Information from Security Application.
    * Display the value of this particular Parameter
    */

   return_value = cm_dm_get_keys_array_from_name_path (tmp_cli_session_p->tnsprt_channel_p,
         tmp_cli_session_p->dmpath_a,
         CM_CLI_MGMT_ENGINE_ID,
         &tmp_cli_session_p->role_info, &keys_array_p);
   if (return_value != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " Failed to fetch key parameter(s).\n\r");
      return OF_FAILURE;
   }

   /* Get the record from the sec_appl database and display the
    * Parameter value
    */
   return_value = cm_get_exact_record (tmp_cli_session_p->tnsprt_channel_p,
         CM_CLI_MGMT_ENGINE_ID,
         tmp_cli_session_p->role_info.admin_role,
         tmp_cli_session_p->dmpath_a,
         keys_array_p, &out_array_of_nv_pair_arr);
   if (return_value == OF_SUCCESS)
   {
      for (ii = 0; ii < out_array_of_nv_pair_arr->count_ui; ii++)
      {
         if (of_strcmp (param_name_p, out_array_of_nv_pair_arr->nv_pairs[ii].name_p))
         {
            cm_cli_puts (cli_session_p, "\n\t Param_name \t\tParam_value\n\r");
            if(out_array_of_nv_pair_arr->nv_pairs[ii].identifier_len_ui == 0)
            {
               sprintf (buff_a, "\n\t %s \t\t%s\n\r",
                     out_array_of_nv_pair_arr->nv_pairs[ii].name_p,
                     (char*)out_array_of_nv_pair_arr->nv_pairs[ii].value_p);
            }
            else
            {
               sprintf (buff_a, "\n\t %s \t\t%s \t\t%s\n\r",
                     out_array_of_nv_pair_arr->nv_pairs[ii].name_p,
                     out_array_of_nv_pair_arr->nv_pairs[ii].cli_identifier_p,
                     (char*)out_array_of_nv_pair_arr->nv_pairs[ii].value_p);
            }
            cm_cli_puts (cli_session_p, buff_a);

            /* Free Keys Array */
            if (keys_array_p)
            {
               CM_FREE_PTR_NVPAIR_ARRAY (keys_array_p, keys_array_p->count_ui);
            }

            /* Free Outnv_pair_array */
            if(out_array_of_nv_pair_arr)
            {
               CM_FREE_PTR_NVPAIR_ARRAY (out_array_of_nv_pair_arr,
                     out_array_of_nv_pair_arr->count_ui);
            }
            return OF_SUCCESS;
         }
      }
   }

   cm_cli_puts (cli_session_p, " Parameter value does not exist.\n\r");
   return OF_FAILURE;
}

/***************************************************************************
 * Function Name : cm_cli_display_table_help
 * Description   : New help for "tablename <enter>" or "tablename <tab>"
 * Input         : tnsprt_channel_p - Transport channel pointer
                   dm_path_p - Data model template tree path
                   mgmt_engine_id - Management engine id
                   role_info_p - Roles and permissions 
 * Output        : none 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_table_help (void * tnsprt_channel_p,
                                   char * dm_path_p,
                                   uint32_t mgmt_engine_id,
                                   struct cm_role_info *role_info_p,
           unsigned char is_vsg_table_b)
{
   struct cm_dm_node_info *node_info_p = NULL, *tmp_node_info_p, *tmp_node_info_arr_p;
   struct cm_array_of_structs *child_info_arr_p; 
   char tmp_key_buff[16][MAX_A_BUFF_SIZE];
   char tmp_mand_buff[64][MAX_A_BUFF_SIZE];
   char tmp_opt_buff[MAX_A_BUFF_SIZE][MAX_A_BUFF_SIZE];
   char tmp_buff_a[CM_CLI_MAX_PROMPT_LEN];

   uint32_t ii = 0, cnt_ui = 0, tmp_attrib_cnt_i = 0, tmp_mand_cnt_i = 0, tmp_key_cnt_i = 0;
   unsigned char mand_param_b = FALSE, opt_param_b = FALSE, key_param_b = FALSE;

   table_info_arr_p_g = (struct cm_array_of_structs*)of_calloc(1, sizeof(struct cm_array_of_structs));
   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            dm_path_p, CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }
   if((table_info_arr_p_g != NULL) && (child_info_arr_p->count_ui > 0))
   {
      table_info_arr_p_g->count_ui = child_info_arr_p->count_ui;
      tmp_node_info_arr_p = (struct cm_dm_node_info*)of_calloc(table_info_arr_p_g->count_ui,
            sizeof(struct cm_dm_node_info));
   }
   /* find the child table nodes */
   for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
   {
      mand_param_b = FALSE;
      opt_param_b = FALSE;
      key_param_b = FALSE;
      of_memset(tmp_buff_a, 0, sizeof(tmp_buff_a));
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
      if(tmp_node_info_p != NULL)
      {
         of_memset(buff_a, 0, sizeof(buff_a));
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_SCALAR_VAR && tmp_node_info_p->element_attrib.visible_b == TRUE)
         {
            if (tmp_node_info_p->element_attrib.mandatory_b == TRUE && tmp_node_info_p->element_attrib.non_config_leaf_node_b != TRUE) 
            {
               /* //VortiQa Requirement
                  sprintf (buff_a, "%-20s\t::\t\t", tmp_node_info_p->name_p);
                  */
               sprintf (buff_a, "%-32s: ", tmp_node_info_p->name_p);
               of_strcpy(tmp_buff_a,buff_a); 
               if (tmp_node_info_p->element_attrib.key_b == TRUE )
                  key_param_b = TRUE;
               else
                  mand_param_b = TRUE;
            }
            else if( tmp_node_info_p->element_attrib.non_config_leaf_node_b != TRUE)
            {
               if(tmp_node_info_p->element_attrib.cli_identifier_p)
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "%-20s\t::\t%s\t", tmp_node_info_p->name_p                                   ,tmp_node_info_p->element_attrib.cli_identifier_p);  
                     */
                  sprintf(tmp_buff_a,"%s(%s)",tmp_node_info_p->name_p, tmp_node_info_p->element_attrib.cli_identifier_p);   
                  sprintf (buff_a, "%-32s: ", tmp_buff_a);                
               }
               else
               {
                  /* //VortiQa Requirement
                     sprintf (buff_a, "%-20s\t::\t\t", tmp_node_info_p->name_p);
                     */
                  sprintf (buff_a, "%-32s: ", tmp_node_info_p->name_p);
               }
               of_strcpy(tmp_buff_a,buff_a);         
               opt_param_b = TRUE;
            }

            switch (tmp_node_info_p->data_attrib.data_type)
            {
               case CM_DATA_TYPE_STRING:
               case CM_DATA_TYPE_STRING_SPECIAL_CHARS:
                  of_strcat(tmp_buff_a," String"); 
                  break;
               case CM_DATA_TYPE_INT:
                  of_strcat(tmp_buff_a, " Integer ");
                  break;
               case CM_DATA_TYPE_UINT:
                  of_strcat(tmp_buff_a, " Unsigned Integer ");
                  break;
               case CM_DATA_TYPE_INT64:
                  of_strcat(tmp_buff_a, " Long Integer ");
                  break;
               case CM_DATA_TYPE_UINT64:
                  of_strcat(tmp_buff_a, " Unsigned Long Integer ");
                  break;

               case CM_DATA_TYPE_BOOLEAN:
                  of_strcat(tmp_buff_a, " Boolean ");
                  break;
               case CM_DATA_TYPE_DATETIME:
                  of_strcat(tmp_buff_a, " Date and Time ");
                  break;
               case CM_DATA_TYPE_BASE64:
                  of_strcat(tmp_buff_a, " Base64 ");
                  break;
               case CM_DATA_TYPE_IPADDR:
                  of_strcat(tmp_buff_a, " IPv4 Address ");
                  break;
               case CM_DATA_TYPE_UNKNOWN:
                  of_strcat(tmp_buff_a, " - ");
                  break;
            }
            switch (tmp_node_info_p->data_attrib.attrib_type)
            {
               case CM_DATA_ATTRIB_NONE:
                  break;
               case CM_DATA_ATTRIB_INT_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.int_range.start_value,
                        tmp_node_info_p->data_attrib.attr.int_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_UINT_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.uint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.uint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_INT_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.int_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%d",
                           tmp_node_info_p->data_attrib.attr.int_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a, buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_UINT_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.uint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%u",
                           tmp_node_info_p->data_attrib.attr.uint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_INT64_RANGE:
                  sprintf (buff_a, " [ %ld to %ld ]",
                        tmp_node_info_p->data_attrib.attr.longint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.longint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_UINT64_RANGE:
                  sprintf (buff_a, " [ %ld to %ld ]",
                        tmp_node_info_p->data_attrib.attr.ulongint_range.start_value,
                        tmp_node_info_p->data_attrib.attr.ulongint_range.end_value);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_INT64_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.longint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%ld",
                           tmp_node_info_p->data_attrib.attr.longint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a, buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_UINT64_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.ulongint_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%lu",
                           tmp_node_info_p->data_attrib.attr.ulongint_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_STR_ENUM:
                  of_strcat(tmp_buff_a, " { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.string_enum.count_ui; cnt_ui++)
                  {
                     sprintf (buff_a, "%s",
                           tmp_node_info_p->data_attrib.attr.string_enum.array[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;

               case CM_DATA_ATTRIB_STR_RANGE:
                  sprintf (buff_a, " [ %d to %d ]",
                        tmp_node_info_p->data_attrib.attr.string_range.min_length,
                        tmp_node_info_p->data_attrib.attr.string_range.max_length);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               case CM_DATA_ATTRIB_IPADDR_ENUM:
                  of_strcat(tmp_buff_a," { ");
                  for (cnt_ui = 0; cnt_ui < tmp_node_info_p->data_attrib.attr.ip_enum.count_ui;cnt_ui++)
                  {
                     sprintf (buff_a, "%s",
                           tmp_node_info_p->data_attrib.attr.ip_enum.ip_arr_a[cnt_ui]);
                     if(cnt_ui > 0)
                        of_strcat(tmp_buff_a, CM_CLI_ENUM_SEPERATOR);
                     of_strcat(tmp_buff_a,buff_a);
                  }
                  of_strcat(tmp_buff_a," } ");
                  break;
               case CM_DATA_ATTRIB_IPADDR_RANGE:
                  sprintf (buff_a, " Start IP: (%s) ",
                        tmp_node_info_p->data_attrib.attr.ip_range.start_ip);
                  of_strcat(tmp_buff_a,buff_a);
                  sprintf (buff_a, " End IP: (%s)",
                        tmp_node_info_p->data_attrib.attr.ip_range.end_ip);
                  of_strcat(tmp_buff_a,buff_a);
                  break;
               default:
                  of_strcat (tmp_buff_a, "Unknown type: default");
                  break;
            }  
            if(key_param_b == TRUE)
            {
               of_strcpy(tmp_key_buff[tmp_key_cnt_i], tmp_buff_a);
               tmp_key_cnt_i++;
            }  
            if(mand_param_b == TRUE)
            {
               if(tmp_node_info_p->element_attrib.cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_buff_a, "\r\n\tNote:");
                  of_strcat(tmp_buff_a, tmp_node_info_p->element_attrib.cli_idenetifier_help_p);
               }        
               of_strcpy(tmp_mand_buff[tmp_mand_cnt_i], tmp_buff_a);
               tmp_mand_cnt_i++;
            }  
            if(opt_param_b == TRUE)
            {
               if(tmp_node_info_p->element_attrib.cli_idenetifier_help_p)
               {          
                  of_strcat(tmp_buff_a, "\r\n\tNote:");
                  of_strcat(tmp_buff_a, tmp_node_info_p->element_attrib.cli_idenetifier_help_p);
               }        
               of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i], tmp_buff_a);
               tmp_attrib_cnt_i++;    
            }  
         }
         cm_cli_copy_node_info_into_array(tmp_node_info_p, tmp_node_info_arr_p, ii);
      }

   }
   if((table_info_arr_p_g != NULL) && (child_info_arr_p->count_ui > 0))
   {
      table_info_arr_p_g->struct_arr_p = (void*) tmp_node_info_arr_p;
   }

   //Display scalars
   /*  //Commented according to VortiQa Requirement
       if(tmp_key_cnt_i > 1)
       cm_cli_puts (cli_session_p, "TableName <KeyParamName1=Value,keyparamName2=Value,...,KeyParamNameN=Value>\n\n");
       else
       cm_cli_puts (cli_session_p, "TableName <Keyparam_value>\n\n");
       for(cnt_ui = 0; cnt_ui < tmp_key_cnt_i; cnt_ui++)
       {
       if(cnt_ui == 0)
       cm_cli_puts(cli_session_p, "Key Parameter(s):\n\t");
       cm_cli_puts(cli_session_p, tmp_key_buff[cnt_ui]);
       cm_cli_puts(cli_session_p, "\n\t");
       }
       cm_cli_puts(cli_session_p, "\n\t(or)\n\t\n\t");
       */
   if(tmp_key_cnt_i > 1)
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a,"%s <Keyparam_value1 Keyparam_value2 ... Keyparam_valueN> <Mandparam_value1 Mandparam_value2 ... Mandparam_valueN> [OptParamName1 <value>] ... [OptParamNameN <value>]\n\n",table_name_a_g);
      cm_cli_puts(cli_session_p, buff_a);
   }
   else if(tmp_key_cnt_i == 1)
   {
      of_memset(buff_a, 0, sizeof(buff_a));
      sprintf(buff_a, "%s <Keyparam_value> <Mandparam_value1 Mandparam_value2 ... Mandparam_valueN> [OptParamName1 <value>] ... [OptParamNameN <value>]\n\n", table_name_a_g);
      cm_cli_puts(cli_session_p, buff_a);
   }
   for(cnt_ui = 0; cnt_ui < tmp_key_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, " Key Parameter(s):\n\t");
      cm_cli_puts(cli_session_p, tmp_key_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }
   for(cnt_ui = 0; cnt_ui < tmp_mand_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, "\n Mandatory Parameter(s) (in the order):\n\t");
      cm_cli_puts(cli_session_p, tmp_mand_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }
   for(cnt_ui = 0; cnt_ui < tmp_attrib_cnt_i; cnt_ui++)
   {
      if(cnt_ui == 0)
         cm_cli_puts(cli_session_p, "\n Optional Parameter(s):\n\t");
      cm_cli_puts(cli_session_p, tmp_opt_buff[cnt_ui]);
      cm_cli_puts(cli_session_p, "\n\t");
   }

   //should not display anchors and tables inside vsg table when "igd/>vsg <tab>" is pressed
   if(is_vsg_table_b == TRUE)
      return;

   //Display Tables and Anchors 
   tmp_attrib_cnt_i = 0;
   for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
      if(tmp_node_info_p != NULL && tmp_node_info_p->element_attrib.visible_b == TRUE)
      {
         //Display Anchors
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR )
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "\n\t%-20s", tmp_node_info_p->name_p);  
               */
            sprintf (buff_a, "\n\t%s/", tmp_node_info_p->name_p);  
            cm_cli_puts(cli_session_p, buff_a);
         }
         //Display tables
         if(tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE )
         {
            /* //VortiQa Requirement
               sprintf (buff_a, "\n\t%-20s(table)", tmp_node_info_p->name_p);  
               */
            sprintf (buff_a, "\n\t%s", tmp_node_info_p->name_p);  
            of_strcpy(tmp_opt_buff[tmp_attrib_cnt_i], buff_a);
            tmp_attrib_cnt_i++;    
            //cm_cli_puts(cli_session_p, buff_a);
         }
      }
   }
   cm_cli_puts(cli_session_p, "\n\r");
   //Print Tables
   for(cnt_ui = 0; cnt_ui < tmp_attrib_cnt_i; cnt_ui++)
   {
      cm_cli_puts(cli_session_p, tmp_opt_buff[cnt_ui]);
   }
   cm_cli_puts(cli_session_p, "\r\n");
}

/***************************************************************************
 * Function Name : cm_cli_copy_node_info_into_array 
 * Description   : This API is used to copy Datamodel node info into another
                   Datamodel node info
 * Input         : node_info_p - Data Model node info
 * Output        : node_info_array_p - Array of Datamodel nodes 
 * Return value  : OF_SUCCESS / OF_FAILURE
***************************************************************************/
int32_t cm_cli_copy_node_info_into_array (struct cm_dm_node_info * node_info_p,
                                                struct cm_dm_node_info * node_info_array_p,
                                                uint32_t index_ui)
{
   struct cm_dm_node_info *tmp_node_info_p;

   tmp_node_info_p = (node_info_array_p + index_ui);
   of_memcpy (tmp_node_info_p, node_info_p, sizeof (struct cm_dm_node_info));
   /* name_p */
   tmp_node_info_p->name_p = (char *) of_calloc (1,
         of_strlen (node_info_p->name_p) + 1);
   if (tmp_node_info_p->name_p)
      of_strcpy (tmp_node_info_p->name_p, node_info_p->name_p);
   else
   {
      return OF_FAILURE;
   }


   if(node_info_p->friendly_name_p)
   {
      tmp_node_info_p->friendly_name_p = (char *) of_calloc (1,
            of_strlen (node_info_p->friendly_name_p) + 1);
      /* friendly_name_p */
      if(tmp_node_info_p->friendly_name_p)
         of_strcpy (tmp_node_info_p->friendly_name_p, node_info_p->friendly_name_p);
      else
      {
         of_free(tmp_node_info_p->name_p);
         return OF_FAILURE;
      }
   }
   else
   {
      tmp_node_info_p->friendly_name_p = NULL;
   }

   /* description_p */
   tmp_node_info_p->description_p = (char *) of_calloc (1,
         of_strlen
         (node_info_p->description_p)
         + 1);
   if (tmp_node_info_p->description_p)
      of_strcpy (tmp_node_info_p->description_p, node_info_p->description_p);
   else
   {
      if(tmp_node_info_p->friendly_name_p !=NULL)
         of_free(tmp_node_info_p->friendly_name_p);
      of_free(tmp_node_info_p->name_p);
      return OF_FAILURE;
   }

   /* dm_path_p */
   tmp_node_info_p->dm_path_p = (char *) of_calloc (1,
         of_strlen
         (node_info_p->dm_path_p) + 1);
   if (tmp_node_info_p->dm_path_p)
      of_strcpy (tmp_node_info_p->dm_path_p, node_info_p->dm_path_p);
   else
   {
      of_free(tmp_node_info_p->description_p);
      if(tmp_node_info_p->friendly_name_p !=NULL)
         of_free(tmp_node_info_p->friendly_name_p);
      of_free(tmp_node_info_p->name_p);
      return OF_FAILURE;
   }

   /* command_name_p */
   if( node_info_p->element_attrib.command_name_p)
   {
      tmp_node_info_p->element_attrib.command_name_p = (char *) of_calloc (1,
            of_strlen
            (node_info_p->element_attrib.command_name_p)
            + 1);
      if (tmp_node_info_p->element_attrib.command_name_p)
         of_strcpy ( tmp_node_info_p->element_attrib.command_name_p, node_info_p->element_attrib.command_name_p);
      else
      {
         of_free(tmp_node_info_p->dm_path_p);
         of_free(tmp_node_info_p->description_p);
         if(tmp_node_info_p->friendly_name_p !=NULL)
            of_free(tmp_node_info_p->friendly_name_p);
         of_free(tmp_node_info_p->name_p);
         return OF_FAILURE;
      }
   }
   else
   {
      tmp_node_info_p->element_attrib.command_name_p = NULL;
   }

   //cli_identifier_p
   if( node_info_p->element_attrib.cli_identifier_p)
   {
      tmp_node_info_p->element_attrib.cli_identifier_p = (char *) of_calloc (1,
            of_strlen
            (node_info_p->element_attrib.cli_identifier_p)
            + 1);
      if (tmp_node_info_p->element_attrib.cli_identifier_p)
         of_strcpy ( tmp_node_info_p->element_attrib.cli_identifier_p, node_info_p->element_attrib.cli_identifier_p);
      else
      {
         if(tmp_node_info_p->element_attrib.command_name_p!=NULL)
            of_free(tmp_node_info_p->element_attrib.command_name_p);
         of_free(tmp_node_info_p->dm_path_p);
         of_free(tmp_node_info_p->description_p);
         if(tmp_node_info_p->friendly_name_p !=NULL)
            of_free(tmp_node_info_p->friendly_name_p);
         of_free(tmp_node_info_p->name_p);
         return OF_FAILURE;
      }
   }
   else
   {
      tmp_node_info_p->element_attrib.cli_identifier_p = NULL;
   }

   //cli_idenetifier_help_p
   if( node_info_p->element_attrib.cli_idenetifier_help_p)
   {
      tmp_node_info_p->element_attrib.cli_idenetifier_help_p = (char *) of_calloc (1,
            of_strlen(node_info_p->element_attrib.cli_idenetifier_help_p) + 1);
      if (tmp_node_info_p->element_attrib.cli_idenetifier_help_p)
         of_strcpy ( tmp_node_info_p->element_attrib.cli_idenetifier_help_p, node_info_p->element_attrib.cli_idenetifier_help_p);
      else
      {
         if(tmp_node_info_p->element_attrib.cli_identifier_p!=NULL)
            of_free(tmp_node_info_p->element_attrib.cli_identifier_p);
         if(tmp_node_info_p->element_attrib.command_name_p!=NULL)
            of_free(tmp_node_info_p->element_attrib.command_name_p);
         of_free(tmp_node_info_p->dm_path_p);
         of_free(tmp_node_info_p->description_p);
         if(tmp_node_info_p->friendly_name_p !=NULL)
            of_free(tmp_node_info_p->friendly_name_p);
         of_free(tmp_node_info_p->name_p);
         return OF_FAILURE;
      }
   }
   else
   {
      tmp_node_info_p->element_attrib.cli_idenetifier_help_p = NULL;
   }

   return OF_SUCCESS;
}
/***************************************************************************
 * Function Name : cm_cli_display_instances_and_key_params
 * Description   : this API is used to display instances and key params under
                   a table node with childs 
 * Input         : table_name_p - Table name to display 
 * Output        : none 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_display_instances_and_key_params (char * table_name_p, unsigned char system_command_b)
{
   /* TODO: Should update this API as per Suren's review comments*/
   struct cm_cli_session *tmp_cli_session_p = cli_session_p;
   UCMDllQNode_t *dll_q_node_p;
   struct cm_cli_data_ele_node *data_ele_node_p;
   char dmpath_a[CM_CLI_MAX_PROMPT_LEN + 1];
   uint32_t count_ui = 0, ii;
   int32_t return_value;
   struct cm_dm_instance_map *map_p = NULL;
   unsigned char found_b = FALSE, is_vsg_table_b = FALSE;
   struct cm_dm_node_info *node_info_p = NULL;
   unsigned char parent_trans_b = FALSE, non_cfg_node_b = FALSE;

   if (table_name_p == NULL)
   {
      CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         of_memset (dmpath_a, 0, sizeof (dmpath_a));
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
               list_node);


         if (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE)
         {
            of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
            of_strcat (dmpath_a, ".");
            of_strcat (dmpath_a, data_ele_node_p->node_name);

            return_value =
               cm_dm_get_instance_map_entry_list_using_name_path (tmp_cli_session_p->tnsprt_channel_p,
                     dmpath_a,
                     CM_CLI_MGMT_ENGINE_ID,
                     &tmp_cli_session_p->role_info,
                     &count_ui, &map_p);
            if (return_value == OF_SUCCESS)
            {
               if (count_ui)
               {
                  found_b = TRUE;
                  cm_cli_puts (cli_session_p, "\n\t***********************************");
                  sprintf (buff_a, "\n\t Instances of [%s] table",
                        data_ele_node_p->node_name);
                  cm_cli_puts (cli_session_p, buff_a);
                  cm_cli_puts (cli_session_p, "\n\t***********************************");

                  /* Display instances of the entered table */
                  for (ii = 0; ii < count_ui; ii++)
                  {
                     /* TODO: Based on the Datatype we need to display the value */
                     sprintf (buff_a, "\n\t\t %s ", (char*)map_p[ii].key_p);
                     cm_cli_puts (cli_session_p, buff_a);
                  }

                  cm_cli_free_instance_map_list (map_p, count_ui);
               }
            }
         }
      }
      CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->data_elements_list, dll_q_node_p,
            UCMDllQNode_t *)
      {
         of_memset (dmpath_a, 0, sizeof (dmpath_a));
         data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
               list_node);
         if (data_ele_node_p->node_type == CM_DMNODE_TYPE_SCALAR_VAR)
         {
            of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
            of_strcat (dmpath_a, ".");
            of_strcat (dmpath_a, data_ele_node_p->node_name);
            cm_cli_display_records_of_scalar(dmpath_a,NULL,FALSE,NULL,FALSE,NULL);
         }
      }
   }
   else
   {
      of_strcpy (dmpath_a, tmp_cli_session_p->dmpath_a);
      of_strcat (dmpath_a, ".");
      of_strcat (dmpath_a, table_name_p);
      return_value =
         cm_dm_get_instance_map_entry_list_using_name_path (tmp_cli_session_p->tnsprt_channel_p,
               dmpath_a,
               CM_CLI_MGMT_ENGINE_ID,
               &tmp_cli_session_p->role_info,
               &count_ui, &map_p);
      if (return_value == OF_SUCCESS)
      {
         if (count_ui)
         {
            found_b = TRUE;
            /* //Deepthi - Need to uncomment later
               sprintf (buff_a, "\n\t* * * * %s Table Instances * * * *", table_name_p);

               cm_cli_puts (cli_session_p, buff_a);

            // Display instances of the given table 

            cm_cli_puts (cli_session_p, "\n\t{");
            for (ii = 0; ii < count_ui; ii++)
            {
            sprintf (buff_a, "\n\t %s ", (char*)map_p[ii].key_p);
            cm_cli_puts (cli_session_p, buff_a);
            }
            cm_cli_puts (cli_session_p, " }\n\r");*/

            cm_cli_free_instance_map_list (map_p, count_ui);
         }
      }
      else
      {
         /* //Deepthi - Need to uncomment later
            sprintf (buff_a, "No instances exists for %s Table\n\r", table_name_p);
            cm_cli_puts (cli_session_p, buff_a);
            */
      }
      return_value = cm_dm_get_key_child_info (cli_session_p->tnsprt_channel_p,
            dmpath_a, CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info, &node_info_p);
      if ((return_value != OF_SUCCESS) || (!node_info_p))
      {
         if(return_value != CM_COMMON_NO_KEY_FOR_TABLE)
         {
            cm_cli_puts (cli_session_p, " Failed to get Key Child information.\n\r");
            return OF_FAILURE;
         }
      }
      cm_cli_puts (cli_session_p, "\n\t");

      /*Displays new help with mandatory params*/ 
      of_memset(table_name_a_g,0,sizeof(table_name_a_g));
      of_strcpy(table_name_a_g, table_name_p);
      if(of_strcmp(table_name_p, "vsg") == 0)
      {
         is_vsg_table_b = TRUE;
      }
      else
      {
         is_vsg_table_b = FALSE;

         CM_DLLQ_SCAN (&tmp_cli_session_p->current_node_p->child_list, dll_q_node_p,
               UCMDllQNode_t *)
         {
            data_ele_node_p = CM_DLLQ_LIST_MEMBER (dll_q_node_p, struct cm_cli_data_ele_node *,
                  list_node);
            if( (of_strcmp(data_ele_node_p->node_name, table_name_a_g) == 0) && (data_ele_node_p->node_type == CM_DMNODE_TYPE_TABLE) )
            {
               parent_trans_b = data_ele_node_p->parent_trans_b;
               non_cfg_node_b = data_ele_node_p->non_config_leaf_node_b;
               break;
            }
         }


         if ( (cli_session_p->cd_table_b == TRUE && (cli_session_p->curr_table_ctx_b == FALSE && parent_trans_b == TRUE)) ||
               (cli_session_p->cd_table_b == TRUE && cli_session_p->curr_table_ctx_b == FALSE && parent_trans_b == FALSE && cli_session_p->dmpath_a[of_strlen(cli_session_p->dmpath_a)-1] != '}') )
         {
            cm_cli_puts(cli_session_p, "Only the following commands can be used at this context:\n\t");
#ifdef CM_ROLES_PERM_SUPPORT
            cm_cli_puts(cli_session_p,"setrole\n\tgetrole\n\tcd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\r\n");
#else
            cm_cli_puts(cli_session_p,"cd table-name\n\tanchor-name\n\tcd anchor-name\n\t..\n\tcd ..\n\tshow\n\tshowall\n\tsave\n\tdel\r\n");
#endif

            if (node_info_p)
               cm_cli_free_dm_node_info (node_info_p, TRUE);

            return OF_FAILURE;
         }
      }

      if(return_value != CM_COMMON_NO_KEY_FOR_TABLE)
      {
         if(!system_command_b)
         {
            if(non_cfg_node_b != TRUE)
            {
               sprintf (buff_a, "To add or modify the record of \'%s\' table, use the below syntax:\n\t",
                     table_name_p);
               cm_cli_puts (cli_session_p, buff_a);
            }
         }
         else
         {
            sprintf (buff_a, " To execute %s command, use the below syntax:\n\t",
                  table_name_p);
            cm_cli_puts (cli_session_p, buff_a);
         }
      }

      cm_cli_display_table_help (cli_session_p->tnsprt_channel_p,
            dmpath_a, CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info, is_vsg_table_b);

      if (node_info_p)
         cm_cli_free_dm_node_info (node_info_p, TRUE);
   }
   cm_cli_puts (cli_session_p, "\n\r");

   if (found_b == FALSE)
      return OF_FAILURE;
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_nv_pair_array
 * Description   : This API is used to display name value pairs 
 * Input         : nv_pair_array_p - Name value pairs
                   dm_path_p - Datamodel path
 * Output        : none 
 * Return value  : none
 ***************************************************************************/
 void cm_cli_display_nv_pair_array (struct cm_array_of_nv_pair * nv_pair_array_p,
                                           uint32_t count_ui,char * dm_path_p)
{
   int32_t cnt_i;
   static int32_t rep_count_i=0;
   char temp_buf[4],ch;
   of_memset(temp_buf,0,sizeof(temp_buf));

   if ((nv_pair_array_p == NULL || nv_pair_array_p->count_ui == 0))
   {
      cm_cli_puts (cli_session_p, " Invalid nv pairs.\n\r");
      return;
   }

   cm_cli_return_enum_string(nv_pair_array_p,dm_path_p,count_ui);
   //cm_cli_puts (cli_session_p, CM_CLI_SHOW_RECORD_DELIMITER);
   for (cnt_i = 0; cnt_i < count_ui; cnt_i++)
   {
      cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_START_DELIMITER );
      /* Atmaram - Calling node and child node for each nvpair in
       * cm_cli_return_enum_string function. one call is enought for all nvpairs. hence moving  it to top*/
      //   cm_cli_return_enum_string(&nv_pair_array_p[cnt_i],dm_path_p);
      cm_cli_display_nv_pair(nv_pair_array_p[cnt_i].count_ui, &nv_pair_array_p[cnt_i],dm_path_p);
      cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_END_DELIMITER );
      cm_cli_puts (cli_session_p, CM_CLI_SHOW_RECORD_DELIMITER);
  
      if((cnt_i>0) && (cnt_i%CM_REC_DISP_IN_EACH_PAGE == 0))
      {
        cm_cli_puts(cli_session_p,"\r\n Press the Enter key to continue...");
        scanf("%c",&ch);
        if(ch == '\n')continue;
        else if((ch == 'q')||(ch=='Q'))break;
        else return;
      }

   }
   rep_count_i += count_ui;

   if((cnt_i < CM_REC_DISP_IN_EACH_PAGE) && (rep_count_i >= CM_MAX_DISP_LINES))
   {
      cm_cli_puts(cli_session_p,"\r\n Press the Enter key to continue...");
      if(!of_fgets (temp_buf, 4 , CM_CLI_STDIN))
         return ;
      rep_count_i = 0;
      of_memset(temp_buf,0,sizeof(temp_buf));
   }
   return;
}

/***************************************************************************
 * Function Name : cm_cli_display_nv_pair
 * Description   : This API is used to display name value pairs 
 * Input         : nv_pair_array_p - Name value pairs
                   dm_path_p - Data model tree path
 * Output        : none 
 * Return value  : none
 ***************************************************************************/
void cm_cli_display_nv_pair(uint32_t count_ui, struct cm_array_of_nv_pair *nv_pair_array_p,char * dm_path_p)
{
   uint32_t  max_buf_ui= 10240;
   int32_t ii;
   char buff_a[max_buf_ui];
   char *name_p = NULL;
   char *identifier_p = NULL;


   for (ii = 0; ii < nv_pair_array_p->count_ui; ii++)
   {
      if(ii == 0)
        cm_cli_puts (cli_session_p, CM_CLI_SHOW_NEWLINE_DELIMITER);
      else
        cm_cli_puts (cli_session_p, CM_CLI_SHOW_RECORD_DELIMITER);
      of_memset(buff_a,0,sizeof(buff_a));

      #ifdef CM_CLI_FRND_NAME
      if(nv_pair_array_p->nv_pairs[ii].friendly_name_length > 0)
      {
         name_p = nv_pair_array_p->nv_pairs[ii].friendly_name_p;
      }
      else
      {
         name_p = nv_pair_array_p->nv_pairs[ii].name_p;
      }
      #else	
         name_p = nv_pair_array_p->nv_pairs[ii].name_p;
      #endif
      if(nv_pair_array_p->nv_pairs[ii].identifier_len_ui > 0)
      {
         identifier_p = nv_pair_array_p->nv_pairs[ii].cli_identifier_p;

         if(nv_pair_array_p->nv_pairs[ii].enum_val_len_ui > 0) 
         {
            snprintf (buff_a,max_buf_ui-1,"  %s : %s : %s(%s)", name_p, identifier_p, 
                  (char*)nv_pair_array_p->nv_pairs[ii].enum_value_p,
                  (char*)nv_pair_array_p->nv_pairs[ii].value_p);
         }
         else
         {
            snprintf (buff_a,max_buf_ui-1,"  %s : %s : %s", name_p,identifier_p,
                  (char*)nv_pair_array_p->nv_pairs[ii].value_p);
         }
      }
      else
      {
         if(nv_pair_array_p->nv_pairs[ii].enum_val_len_ui > 0) 
         {
            snprintf (buff_a,max_buf_ui-1,"  %s : %s(%s)", name_p,
                  (char*)nv_pair_array_p->nv_pairs[ii].enum_value_p,
                  (char*)nv_pair_array_p->nv_pairs[ii].value_p);
         }
         else
         {
            snprintf (buff_a,max_buf_ui-1,"  %s : %s", name_p,
                  (char*)nv_pair_array_p->nv_pairs[ii].value_p);
         }
      }
      cm_cli_puts (cli_session_p, buff_a);
//      cm_cli_puts (cli_session_p, CM_CLI_SHOW_DELIMITER);
   }
}

/***************************************************************************
 * Function Name : cm_cli_display_records_of_table
 * Description   : This api is used to display all records in a table 
 * Input         : dm_path_p - Data model path
                   keys_array_p - array of name value pairs 
 * Output        : none 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_display_records_of_table (char * dm_path_p,
      struct cm_array_of_nv_pair *keys_array_p,
      unsigned char exact_b)
{
   struct cm_cli_session *tmp_cli_session_p = cli_session_p;
   struct cm_array_of_nv_pair *out_nv_pair_array_p = NULL/*, *keys_array_p1 = NULL*/;
   struct cm_array_of_nv_pair prev_rec_key_arr={};
   struct cm_dm_node_info *node_info_p = NULL, *tmp_node_info_p;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   uint32_t count_ui = 1, table_child_cnt_ui = 0;
   char dmpath_a[CM_DM_MAX_PATH_LEN + 1], tmp_dmpath_a[CM_DM_MAX_PATH_LEN + 1];
   int32_t return_value, ii;//, nv_cnt_i;
   unsigned char table_b = FALSE;

   /* Get Node and Child info */
   if (cm_dm_get_node_and_child_info (tmp_cli_session_p->tnsprt_channel_p,
            dm_path_p, CM_CLI_MGMT_ENGINE_ID,
            &tmp_cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed.\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   if(node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
   {
      table_b = TRUE;
   }

   /* find the child table nodes */
   for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
      if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
      {
         table_child_cnt_ui++;
      }

   }

   if (exact_b)
   {
      if(!keys_array_p)
      {
#ifdef CM_CLI_DEBUG 
         cm_cli_puts(cli_session_p, "Invalid keys_array_p for GetExactRecord");
#endif
         return OF_FAILURE;
      }
      return_value = cm_get_exact_record (tmp_cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            tmp_cli_session_p->role_info.admin_role,
            dm_path_p, keys_array_p, &out_nv_pair_array_p);
      if (return_value == OF_FAILURE)
      {
#ifdef CM_CLI_DEBUG 
         cm_cli_puts (cli_session_p, "cm_get_exact_record failed\n\r");
#endif
         return OF_FAILURE;
      }
      cm_cli_display_nv_pair_array (out_nv_pair_array_p, 1,dm_path_p);
      if(!table_child_cnt_ui && (node_info_p->element_attrib.global_trans_b == FALSE ||
               node_info_p->element_attrib.parent_trans_b == FALSE))
      {
         return OF_SUCCESS;
      }
      else
      {
         for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
            if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
            {
               /*Frame DMPath*/
               of_memset(dmpath_a, 0, sizeof(dmpath_a));
               of_memset(dmpath_a, 0, sizeof(dmpath_a));
               of_strcpy(dmpath_a, dm_path_p);
               of_strcat(dmpath_a, ".");
               of_strcat(dmpath_a, tmp_node_info_p->name_p);
               cm_cli_display_records_of_table (dmpath_a, keys_array_p, FALSE);
               continue;
            }

            if(tmp_node_info_p->element_attrib.parent_trans_b == TRUE &&
                  tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR)
            {
               of_memset(dmpath_a, 0, sizeof(dmpath_a));
               of_strcpy(dmpath_a, dm_path_p);
               of_strcat(dmpath_a, ".");
               of_strcat(dmpath_a, tmp_node_info_p->name_p);
               if(tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
               {
                  cm_cli_display_records_of_scalar(dmpath_a,NULL,FALSE,NULL,FALSE,NULL);
               }
               cm_cli_display_records_of_table (dmpath_a, keys_array_p, FALSE);
               continue;
            }             
         }
      }
   }
   else
   {
      if(table_b == TRUE)
      {
         /* Call GetFirstNrecords */
         return_value = cm_get_first_n_records (tmp_cli_session_p->tnsprt_channel_p,
               CM_CLI_MGMT_ENGINE_ID,
               tmp_cli_session_p->role_info.admin_role,
               dm_path_p,
               keys_array_p, &count_ui, &out_nv_pair_array_p);
         if ((return_value == OF_FAILURE) || (count_ui == 0))
         {
            //cm_cli_puts (cli_session_p, "No records exists\n\r");
            sprintf(buff_a, "\n Zero records in the \'%s\' table.\n\r",
                  node_info_p->name_p);
            cm_cli_puts(cli_session_p, buff_a);
            return OF_SUCCESS;
         }

         /* Display the received information */
         cm_cli_display_nv_pair_array (out_nv_pair_array_p, count_ui,dm_path_p);

         if(table_child_cnt_ui || (node_info_p->element_attrib.global_trans_b == TRUE ||
                  node_info_p->element_attrib.parent_trans_b == TRUE))
         {
            /* Frame Keys array including this rec Key Info */
            cm_cli_get_prev_record_key_array (&out_nv_pair_array_p[count_ui - 1], &prev_rec_key_arr, dm_path_p, FALSE);
            of_memset(dmpath_a, 0, sizeof(dmpath_a));
            of_strcpy(dmpath_a, dm_path_p);
            of_strcat(dmpath_a, "{");
            if(prev_rec_key_arr.count_ui == 1)
            {
               of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[0].value_p);
            }
            else
            {
               for(ii=0; ii < prev_rec_key_arr.count_ui ; ii++)
               {
                  of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[ii].name_p);
                  of_strcat(dmpath_a, "=");
                  of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[ii].value_p);
                  if(ii+1 < prev_rec_key_arr.count_ui)
                  {
                     of_strcat(dmpath_a, ",");
                  }
               }
            }
            of_strcat(dmpath_a, "}");

            CM_FREE_NVPAIR_ARRAY(prev_rec_key_arr,prev_rec_key_arr.count_ui);

            for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
            {
               tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
               if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
               {
                  /*Frame DMPath*/
                  of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
                  of_strcpy(tmp_dmpath_a, dmpath_a);
                  of_strcat(tmp_dmpath_a, ".");
                  of_strcat(tmp_dmpath_a, tmp_node_info_p->name_p);
                  cm_cli_display_records_of_table (tmp_dmpath_a, keys_array_p, FALSE);
                  continue;
               }
               if(tmp_node_info_p->element_attrib.parent_trans_b == TRUE &&
                     tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR)
               {
                  of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
                  of_strcpy(tmp_dmpath_a, dmpath_a);
                  of_strcat(tmp_dmpath_a, ".");
                  of_strcat(tmp_dmpath_a, tmp_node_info_p->name_p);
                  if(tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
                  {
                     cm_cli_display_records_of_scalar(tmp_dmpath_a,NULL,FALSE,NULL, FALSE,NULL);
                  }
                  cm_cli_display_records_of_table (tmp_dmpath_a, keys_array_p, FALSE);
                  continue;
               }
            }
         }
         while (1)
         {
            cm_cli_get_prev_record_key_array (&out_nv_pair_array_p[count_ui - 1], &prev_rec_key_arr, dm_path_p, TRUE);
            /*CM_FREE_PTR_ARRAY_OF_NVPAIR_ARRAY (out_nv_pair_array_p, count_ui);*/
            out_nv_pair_array_p = NULL;

            count_ui = 1; //Must reset to 1 
            return_value = cm_get_next_n_records (tmp_cli_session_p->tnsprt_channel_p,
                  CM_CLI_MGMT_ENGINE_ID, tmp_cli_session_p->role_info.admin_role,
                  dm_path_p, &prev_rec_key_arr, keys_array_p,
                  &count_ui, &out_nv_pair_array_p);
            CM_FREE_NVPAIR_ARRAY(prev_rec_key_arr,prev_rec_key_arr.count_ui);

            if ((return_value == OF_SUCCESS) && (count_ui))
            {
               cm_cli_display_nv_pair_array(out_nv_pair_array_p, count_ui,dm_path_p);
               //    if(table_child_cnt_ui)
               if(table_child_cnt_ui || (node_info_p->element_attrib.global_trans_b == TRUE ||
                        node_info_p->element_attrib.parent_trans_b == TRUE))
               {
                  /* Frame Keys array including this rec Key Info */
                  cm_cli_get_prev_record_key_array (&out_nv_pair_array_p[count_ui - 1], &prev_rec_key_arr, dm_path_p, FALSE);

                  of_memset(dmpath_a, 0, sizeof(dmpath_a));
                  of_strcpy(dmpath_a, dm_path_p);
                  of_strcat(dmpath_a, "{");

                  if(prev_rec_key_arr.count_ui == 1)
                  {
                     of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[0].value_p);
                  }
                  else
                  {
                     for(ii=0; ii < prev_rec_key_arr.count_ui ; ii++)
                     {
                        of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[ii].name_p);
                        of_strcat(dmpath_a, "=");
                        of_strcat(dmpath_a, prev_rec_key_arr.nv_pairs[ii].value_p);
                        if(ii+1 < prev_rec_key_arr.count_ui)
                        {
                           of_strcat(dmpath_a, ",");
                        }
                     }
                  }

                  of_strcat(dmpath_a, "}");

                  CM_FREE_NVPAIR_ARRAY(prev_rec_key_arr,prev_rec_key_arr.count_ui);

                  for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
                  {
                     tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
                     if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
                     {
                        /*Frame DMPath*/
                        of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
                        of_strcpy(tmp_dmpath_a, dmpath_a);
                        of_strcat(tmp_dmpath_a, ".");
                        of_strcat(tmp_dmpath_a, tmp_node_info_p->name_p);
                        cm_cli_display_records_of_table (tmp_dmpath_a, keys_array_p, FALSE);
                        continue;
                     }
                     if(tmp_node_info_p->element_attrib.parent_trans_b == TRUE &&
                           tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR)
                     {
                        of_memset(tmp_dmpath_a, 0, sizeof(tmp_dmpath_a));
                        of_strcpy(tmp_dmpath_a, dmpath_a);
                        of_strcat(tmp_dmpath_a, ".");
                        of_strcat(tmp_dmpath_a, tmp_node_info_p->name_p);
                        if(tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
                        {
                           cm_cli_display_records_of_scalar(tmp_dmpath_a,NULL,FALSE,NULL, FALSE,NULL);
                        }
                        cm_cli_display_records_of_table (tmp_dmpath_a, keys_array_p, FALSE);
                        continue;
                     }
                  }
               }  
            }
            else
            {
               break;
            }
         }
      }
      else
      {
         for (ii = 0; ii < child_info_arr_p->count_ui; ii++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + ii;
            if (tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_TABLE)
            {
               /*Frame DMPath*/
               of_memset(dmpath_a, 0, sizeof(dmpath_a));
               of_strcpy(dmpath_a, dm_path_p);
               of_strcat(dmpath_a, ".");
               of_strcat(dmpath_a, tmp_node_info_p->name_p);
               cm_cli_display_records_of_table (dmpath_a, keys_array_p, FALSE);
               continue;
            }

            if(tmp_node_info_p->element_attrib.parent_trans_b == TRUE &&
                  tmp_node_info_p->element_attrib.element_type == CM_DMNODE_TYPE_ANCHOR)
            {
               of_memset(dmpath_a, 0, sizeof(dmpath_a));
               of_strcpy(dmpath_a, dm_path_p);
               of_strcat(dmpath_a, ".");
               of_strcat(dmpath_a, tmp_node_info_p->name_p);
               if(tmp_node_info_p->element_attrib.scalar_group_b == TRUE)
               {
                  cm_cli_display_records_of_scalar(dmpath_a,NULL,FALSE,NULL,FALSE,NULL);
               }
               cm_cli_display_records_of_table (dmpath_a, keys_array_p, FALSE);
               continue;
            }
         }
      }
      cm_cli_puts (cli_session_p, "\n\r");
   }
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_display_records_of_scalar
 * Description   : this API is used to display records 
 * Input         : dm_path_p - DMPath
 *      : params_p - parameter names to send request
 *      : identifier_b - when the entered command is identifier ex: show rto
 *      : param_name_p - name of the identifier. ex: name to 'rto' is 'reqtimeout' 
 * Output        : 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_display_records_of_scalar (char * dm_path_p, 
                                           struct cm_cli_params *params_p,
                                               unsigned char identifier_b,
                                               char *param_name_p, 
                                              unsigned char parent_table_b,
                                struct cm_array_of_nv_pair *nv_pairs_array_p)
{
   struct cm_cli_session *tmp_cli_session_p = cli_session_p;
   struct cm_array_of_nv_pair *out_nv_pair_array_p = NULL;
   struct cm_array_of_nv_pair nv_pairs_array;
   struct cm_array_of_nv_pair *scan_nv_pairs_array_p = NULL;
   struct cm_array_of_nv_pair *key_nv_pairs_p=NULL;
   int32_t return_value, ii = 0;
   char param_a[CM_CLI_MAX_NAME_LEN + 1];
   char* table_name_p = NULL;
   char* value_p = NULL;

   //printf("\r\n %s():: Entered", __FUNCTION__);
   of_memset (param_a, 0, sizeof (param_a));

   of_memset(&nv_pairs_array,0,sizeof(struct cm_array_of_nv_pair));


   if(params_p != NULL && parent_table_b)
   {
      if(identifier_b == FALSE)
      {
         of_strcpy (param_a, (char *) params_p[0].param_value);
      }
      else //if the user entered value is cli identifier, copy the name of the field.
      {
         of_strcpy (param_a, param_name_p);
      }

      table_name_p = of_strrchr(dm_path_p, '{'); //reverse find
      if(table_name_p)//EX: table_name_p will be {1.1.1.1}
      {
         value_p = (char*)of_calloc(1,of_strlen(table_name_p));
         //copying table name without "{" and "}"
         of_strncpy(value_p, table_name_p+1, of_strlen(table_name_p)-2);
      } 

      return_value=cm_cli_prepare_keys_array_from_token(dm_path_p,value_p, &key_nv_pairs_p);
      if(return_value == OF_FAILURE)
      {
         if(value_p)
            of_free(value_p);
         //cm_cli_puts (cli_session_p, "Failed to create key pair.\n\r");
         return OF_FAILURE;
      }
      if(value_p)
         of_free(value_p);

      return_value = cm_get_exact_record (tmp_cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            tmp_cli_session_p->role_info.admin_role,
            dm_path_p, key_nv_pairs_p, &out_nv_pair_array_p);
      if (return_value == OF_FAILURE)
      {
#ifdef CM_CLI_DEBUG 
         cm_cli_puts (cli_session_p, "cm_get_exact_record failed\n\r");
#endif
         return OF_FAILURE;
      }
   }
   else
   {
      if(params_p != NULL)
      {
         of_strcpy (param_a, (char *) params_p[0].param_value);

         nv_pairs_array.count_ui = 1;
         nv_pairs_array.nv_pairs = (struct cm_nv_pair *)of_calloc(1,sizeof(struct cm_nv_pair));
         if(nv_pairs_array.nv_pairs == NULL)
         {
#ifdef CM_CLI_DEBUG 
            sprintf (buff_a, "Memory allocation failed");
            cm_cli_puts(cli_session_p,buff_a);
#endif
            return OF_FAILURE;
         }

         nv_pairs_array.nv_pairs->name_length = of_strlen(param_a) + 1;
         nv_pairs_array.nv_pairs->name_p = (char *) of_calloc(1,nv_pairs_array.nv_pairs->name_length);
         if(nv_pairs_array.nv_pairs->name_p == NULL)
         {
#ifdef CM_CLI_DEBUG 
            sprintf (buff_a, "Memory allocation failed");
            cm_cli_puts(cli_session_p,buff_a);
#endif
            CM_FREE_PTR_NVPAIR(nv_pairs_array.nv_pairs);
            return OF_FAILURE;
         }

         of_strncpy(nv_pairs_array.nv_pairs->name_p, param_a, nv_pairs_array.nv_pairs->name_length);

         nv_pairs_array.nv_pairs->value_p = (char *) of_calloc(1,nv_pairs_array.nv_pairs->name_length);

         if(nv_pairs_array.nv_pairs->value_p == NULL)
         {
#ifdef CM_CLI_DEBUG 
            sprintf (buff_a, "Memory allocation failed");
            cm_cli_puts(cli_session_p,buff_a);
#endif
            CM_FREE_PTR_NVPAIR(nv_pairs_array.nv_pairs);
            return OF_FAILURE;
         }

         of_strcpy(nv_pairs_array.nv_pairs->value_p, "1");
         nv_pairs_array.nv_pairs->value_length = 1;
      }
      if(nv_pairs_array_p == NULL)
      {
         scan_nv_pairs_array_p = &nv_pairs_array;
      }
      else
      {
         scan_nv_pairs_array_p = nv_pairs_array_p;
      }

      return_value = cm_get_exact_record (tmp_cli_session_p->tnsprt_channel_p,
            CM_CLI_MGMT_ENGINE_ID,
            tmp_cli_session_p->role_info.admin_role,
            dm_path_p, scan_nv_pairs_array_p, &out_nv_pair_array_p);
      if (return_value == OF_FAILURE)
      {
#ifdef CM_CLI_DEBUG 
         cm_cli_puts (cli_session_p, "cm_get_exact_record failed\n\r");
#endif
         return OF_FAILURE;
      }
   }

   //Copy and display the value of the required scalar
   if(params_p != NULL)
   {
      for(ii = 0; ii < out_nv_pair_array_p->count_ui; ii++)
      {
         if(of_strcmp(param_a, out_nv_pair_array_p->nv_pairs[ii].name_p) ==0)
         {
            nv_pairs_array.count_ui = 1;
            nv_pairs_array.nv_pairs = (struct cm_nv_pair *)of_calloc(1,sizeof(struct cm_nv_pair));
            if(nv_pairs_array.nv_pairs == NULL)
            {  
#ifdef CM_CLI_DEBUG 
               sprintf (buff_a, "Memory allocation failed for nv_pairs\r\n");
               cm_cli_puts(cli_session_p,buff_a);
#endif
               return OF_FAILURE;
            }
            nv_pairs_array.nv_pairs->name_length = of_strlen(param_a);
            nv_pairs_array.nv_pairs->name_p = (char *) of_calloc(1,nv_pairs_array.nv_pairs->name_length+1);
            if(nv_pairs_array.nv_pairs->name_p == NULL)
            {
#ifdef CM_CLI_DEBUG 
               sprintf (buff_a, "name - Memory allocation failed\r\n");
               cm_cli_puts(cli_session_p,buff_a);
#endif
               nv_pairs_array.nv_pairs->name_length = 0;
               CM_FREE_PTR_NVPAIR(nv_pairs_array.nv_pairs);
               return OF_FAILURE;
            }

            of_strncpy(nv_pairs_array.nv_pairs->name_p, param_a, nv_pairs_array.nv_pairs->name_length);
            nv_pairs_array.nv_pairs->value_length = out_nv_pair_array_p->nv_pairs[ii].value_length;
            nv_pairs_array.nv_pairs->value_p = (char *) of_calloc(1,nv_pairs_array.nv_pairs->value_length+1);

            if(nv_pairs_array.nv_pairs->value_p == NULL)
            {
#ifdef CM_CLI_DEBUG 
               sprintf (buff_a, "value - Memory allocation failed\r\n");
               cm_cli_puts(cli_session_p,buff_a);
#endif
               nv_pairs_array.nv_pairs->value_length = 0;
               CM_FREE_PTR_NVPAIR(nv_pairs_array.nv_pairs);
               return OF_FAILURE;
            }   
            of_strcpy(nv_pairs_array.nv_pairs->value_p, (char*)out_nv_pair_array_p->nv_pairs[ii].value_p);
      	    cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_START_DELIMITER );
            cm_cli_return_enum_string(&nv_pairs_array,dm_path_p,1);
            cm_cli_display_nv_pair(nv_pairs_array.count_ui, &nv_pairs_array,dm_path_p);
      	    cm_cli_puts (cli_session_p, CM_CLI_SHOW_TAB_END_DELIMITER );
//            cm_cli_puts (cli_session_p, CM_CLI_SHOW_RECORD_DELIMITER);
            break;
         }
      }
   }
   else
      cm_cli_display_nv_pair_array (out_nv_pair_array_p, 1,dm_path_p);

   //  if(out_nv_pair_array_p)
   //    CM_FREE_PTR_NVPAIR_ARRAY (out_nv_pair_array_p, out_nv_pair_array_p->count_ui);
   if(key_nv_pairs_p)
      CM_FREE_PTR_NVPAIR_ARRAY (key_nv_pairs_p, 1);
   if(nv_pairs_array.nv_pairs)
      CM_FREE_PTR_NVPAIR(nv_pairs_array.nv_pairs);

   cm_cli_puts (cli_session_p, "\n\r");
   return OF_SUCCESS;
}
/***************************************************************************
 * Function Name : cm_cli_validate_path
 * Description   : 
 * Input         : 
 * Output        : 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_validate_path (char * path_p)
{
   int32_t ii;
   uint32_t open_cnt_ui = 0, close_cnt_ui = 0;
   ii = 0;

   while (path_p[ii] != '\0')
   {
      if ((isalnum (path_p[ii]) == 0) && (path_p[ii] != '{') &&
            (path_p[ii] != '}') && (path_p[ii] != '_') && (path_p[ii] != '-') &&
            (path_p[ii] != ',') && (path_p[ii] != '=') &&
            (path_p[ii] != '.') && (path_p[ii] != '/') )
      {
         return OF_FAILURE;
      }

      if (path_p[ii] == '{')
      {
         open_cnt_ui++;
      }
      else if (path_p[ii] == '}')
      {
         close_cnt_ui++;
      }
      ii++;
   }
   if (open_cnt_ui != close_cnt_ui)
      return OF_FAILURE;

   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_get_prev_record_key_array
 * Description   : This API is used to get array of previous record keys 
 * Input         : mand_b -- True mandatory params are also required.
                   out_nv_pair_array_p - Array of Name value pairs
                   dm_path_p - Data model tree path
 * Output        : prev_rec_keys_arr_p -Array of Name value pairs 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_get_prev_record_key_array (struct cm_array_of_nv_pair * out_nv_pair_array_p,
                                        struct cm_array_of_nv_pair * prev_rec_keys_arr_p,
                                        char * dm_path_p, unsigned char mand_b)
{
   int32_t node_cnt_i,nv_cnt_i,cnt_i=0;
   struct cm_dm_node_info *node_info_p = NULL, *tmp_node_info_p=NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   int32_t mand_param_cnt_i=0;

#if 0
   return_value = cm_dm_get_key_child_info (cli_session_p->tnsprt_channel_p,
         dm_path_p, CM_CLI_MGMT_ENGINE_ID,
         &cli_session_p->role_info, &node_info_p);
   if (return_value != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, "Failed to get Key Childinfo\n\r");
      return OF_FAILURE;
   }

#endif
   if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
            dm_path_p, CM_CLI_MGMT_ENGINE_ID,
            &cli_session_p->role_info,
            &node_info_p, &child_info_arr_p) != OF_SUCCESS)
   {
#ifdef CM_CLI_DEBUG 
      sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r",
            __FUNCTION__);
      cm_cli_puts (cli_session_p, buff_a);
#endif
      return OF_FAILURE;
   }

   /* Find Mandatory Parameters count to */
   for (node_cnt_i = 0; node_cnt_i < child_info_arr_p->count_ui; node_cnt_i++)
   {
      tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + node_cnt_i;
      if (tmp_node_info_p->element_attrib.key_b == TRUE ||
            (mand_b && tmp_node_info_p->element_attrib.mandatory_b == TRUE))
      {
         for (nv_cnt_i=0; nv_cnt_i < out_nv_pair_array_p->count_ui; nv_cnt_i++)
         {
            if (of_strcmp (out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p, tmp_node_info_p->name_p) == 0)
            {
               mand_param_cnt_i++;
            }
         }
      }
   }

   prev_rec_keys_arr_p->count_ui=mand_param_cnt_i;
   if(mand_param_cnt_i)
   {
      prev_rec_keys_arr_p->nv_pairs= ( struct cm_nv_pair *) of_calloc (mand_param_cnt_i, sizeof(struct cm_nv_pair));
      if (cli_session_p->current_node_p)
      {
         for (node_cnt_i = 0,nv_cnt_i=0; (node_cnt_i < child_info_arr_p->count_ui ); node_cnt_i++)
         {
            tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + node_cnt_i;
            if (tmp_node_info_p->element_attrib.key_b == TRUE ||
                  (mand_b && tmp_node_info_p->element_attrib.mandatory_b == TRUE))
            {
               for (nv_cnt_i = 0; nv_cnt_i < out_nv_pair_array_p->count_ui; nv_cnt_i++)
               {
                  if (of_strcmp (out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p, tmp_node_info_p->name_p) == 0)
                  {
                     prev_rec_keys_arr_p->nv_pairs[cnt_i].name_length = out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_length;
                     prev_rec_keys_arr_p->nv_pairs[cnt_i].name_p =
                        (char *) of_calloc (1, prev_rec_keys_arr_p->nv_pairs[cnt_i].name_length + 1);
                     if (prev_rec_keys_arr_p->nv_pairs[cnt_i].name_p)
                     {
                        of_strncpy (prev_rec_keys_arr_p->nv_pairs[cnt_i].name_p, out_nv_pair_array_p->nv_pairs[nv_cnt_i].name_p,
                              prev_rec_keys_arr_p->nv_pairs[cnt_i].name_length);
                     }
                     prev_rec_keys_arr_p->nv_pairs[cnt_i].value_type = out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_type;
                     prev_rec_keys_arr_p->nv_pairs[cnt_i].value_length = out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_length;
                     prev_rec_keys_arr_p->nv_pairs[cnt_i].value_p =
                        (char *) of_calloc (1, prev_rec_keys_arr_p->nv_pairs[cnt_i].value_length + 1);
                     if (prev_rec_keys_arr_p->nv_pairs[cnt_i].value_p)
                     {
                        of_strncpy (prev_rec_keys_arr_p->nv_pairs[cnt_i].value_p, out_nv_pair_array_p->nv_pairs[nv_cnt_i].value_p,
                              prev_rec_keys_arr_p->nv_pairs[cnt_i].value_length);
                     }
                     cnt_i++;
                  }
               }
            }
         }
      }

   }
   if (node_info_p)
   {
      cm_cli_free_dm_node_info (node_info_p, TRUE);
   }

   if (child_info_arr_p)
   {
      cm_cli_free_array_of_node_info (child_info_arr_p);
   }
   return OF_SUCCESS;
}

/***************************************************************************
 * Function Name : cm_cli_get_prev_record_key
 * Description   : This API is used to get previous record key 
 * Input         : out_nv_pair_array_p - Array of Name value pairs
                   dm_path_p - Data model tree path
 * Output        : prev_rec_key_p - Name value pairs 
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
 int32_t cm_cli_get_prev_record_key (struct cm_array_of_nv_pair * out_nv_pair_array_p,
                                        struct cm_nv_pair * prev_rec_key_p,
                                        char * dm_path_p)
{
   int32_t ii, return_value;
   struct cm_dm_node_info *node_info_p = NULL;

   return_value = cm_dm_get_key_child_info (cli_session_p->tnsprt_channel_p,
         dm_path_p, CM_CLI_MGMT_ENGINE_ID,
         &cli_session_p->role_info, &node_info_p);
   if (return_value != OF_SUCCESS)
   {
      cm_cli_puts (cli_session_p, " Failed to get Key Child information.\n\r");
      return OF_FAILURE;
   }

   if (cli_session_p->current_node_p)
   {
      for (ii = 0; ii < out_nv_pair_array_p->count_ui; ii++)
      {
         if (of_strcmp (out_nv_pair_array_p->nv_pairs[ii].name_p, node_info_p->name_p) == 0)
         {
            prev_rec_key_p->name_length = out_nv_pair_array_p->nv_pairs[ii].name_length;
            prev_rec_key_p->name_p =
               (char *) of_calloc (1, prev_rec_key_p->name_length + 1);
            if (prev_rec_key_p->name_p)
            {
               of_strncpy (prev_rec_key_p->name_p, out_nv_pair_array_p->nv_pairs[ii].name_p,
                     prev_rec_key_p->name_length);
            }
            prev_rec_key_p->value_type = out_nv_pair_array_p->nv_pairs[ii].value_type;
            prev_rec_key_p->value_length = out_nv_pair_array_p->nv_pairs[ii].value_length;
            prev_rec_key_p->value_p =
               (char *) of_calloc (1, prev_rec_key_p->value_length + 1);
            if (prev_rec_key_p->value_p)
            {
               of_strncpy (prev_rec_key_p->value_p, out_nv_pair_array_p->nv_pairs[ii].value_p,
                     prev_rec_key_p->value_length);
            }
            return OF_SUCCESS;
         }
      }
   }
   return OF_FAILURE;
}

#if 0
int32_t ucmCliGetKeyInfo(struct cm_cli_session * cli_session_p,  char * dm_path_p,
      uint32_t mgmt_engine_id,  struct cm_role_info * role_info_p,
      struct cm_array_of_nv_pair **pOutKeysArray)
{

   struct cm_array_of_nv_pair *keys_array_p=NULL;
   struct cm_dm_node_info *node_info_p;

   keys_array_p=(struct cm_array_of_nv_pair *)of_calloc(1,sizeof(struct cm_array_of_nv_pair));
   /* Get Last Parenthesis {} value from dm path */
   key_p=GetLastKeyfromdmpath(dm_path_p);
   if (key_p== NULL )
   {
      /* Instance not exists... no need to prepare this KeyNv Pair*/
      *pOutKeysArray=keys_array_p;
      return OF_FAILURE;
   }
   
   return_value = cm_dm_get_key_child_info (cli_session_p->tnsprt_channel_p,
         dm_path_p, CM_CLI_MGMT_ENGINE_ID,
         &cli_session_p->role_info, &node_info_p);

   if (return_value == OF_FAILURE)
   {
      sprintf (buff_a, "Failed to fetch Key parameters from DMPath(%s)\n\r",
            dm_path_p);
      cm_cli_puts (cli_session_p, buff_a);
      *pOutKeysArray=keys_array_p;
      return OF_FAILURE;
   }
   keys_array_p->count_ui=1;
   keys_array_p->nv_pairs=(struct cm_nv_pair *)of_calloc(1,sizeof(struct cm_nv_pair));
   keys_array_p->nv_pairs[0].name_length= of_strlen(node_info_p->name_p);
   keys_array_p->nv_pairs[0].name_p= (char *)of_calloc(1,keys_array_p->nv_pairs[0].name_length + 1);
   of_strncpy( keys_array_p->nv_pairs[0].name_p,node_info_p->name_p);
   keys_array_p->nv_pairs[0].value_type= node_info_p->element_attrib.data_type;
   keys_array_p->nv_pairs[0].value_length= of_strlen(key_p);
   keys_array_p->nv_pairs[0].value_p= (char *)of_calloc(1,key_ps + 1);
   of_strncpy( keys_array_p->nv_pairs[0].value_p,key_p);

  *pOutKeysArray=keys_array_p;
   return OF_SUCCESS;
}
char *GetLastKeyfromdmpath(char *dm_path_p)
{

   char *sep = ".";
   char *word;
   char *pLastToken;
   for (word = strtok (path_p, sep); word; word = strtok (NULL, sep))
   {
      {
         CM_JE_DEBUG_PRINT (" word is %s", word);
         pLastToken = word;
      }
   }
   CM_JE_DEBUG_PRINT ("Last word is %s", pLastToken);
   return pLastToken;


}
#endif

/***************************************************************************
 * Function Name : cm_cli_return_enum_string 
 * Description   : This API is used to get cli identifiers, friendly names and enumerators
 * Input         : dm_path_p - Data model tree path
 * Output        : in_nv_pair_array_p - Array of Name value pairs
 * Return value  : OF_SUCCESS / OF_FAILURE
 ***************************************************************************/
int32_t cm_cli_return_enum_string(struct cm_array_of_nv_pair * in_nv_pair_array_p,char *dm_path_p, uint32_t array_cnt_ui)
{
   struct cm_dm_node_info *node_info_p=NULL;
   struct cm_dm_node_info *tmp_node_info_p = NULL;
   struct cm_array_of_structs *child_info_arr_p = NULL;
   uint32_t cnt_ui = 0;
   uint32_t index_i = 0;
   uint32_t dm_index_i = 0;
   uint32_t array_index_i = 0;
   char *temp_value_p=NULL;

   if(cli_session_p->dmpath_a != NULL)
   {
      if (cm_dm_get_node_and_child_info (cli_session_p->tnsprt_channel_p,
               dm_path_p,
               CM_CLI_MGMT_ENGINE_ID,
               &cli_session_p->role_info,
               &node_info_p, &child_info_arr_p) != OF_SUCCESS)
      {
#ifdef CM_CLI_DEBUG 
         sprintf (buff_a, "%s :: cm_dm_get_node_and_child_info failed\n\r", __FUNCTION__);
         cm_cli_puts (cli_session_p, buff_a);
#endif
         return OF_FAILURE;
      }

   }

   while(array_index_i < array_cnt_ui)//in_nv_pair_array_p->count_ui) //Loop till end of nv_pair_arrayCount
   {
     cnt_ui = 0;
     for (index_i = 0; index_i < in_nv_pair_array_p[array_index_i].count_ui; index_i++)
     {
       for(dm_index_i=0;dm_index_i<child_info_arr_p->count_ui;dm_index_i++)
       {
         tmp_node_info_p = (struct cm_dm_node_info *) (child_info_arr_p->struct_arr_p) + dm_index_i;
         if(of_strcmp(in_nv_pair_array_p[array_index_i].nv_pairs[index_i].name_p,tmp_node_info_p->name_p)==0)
         {
           if(tmp_node_info_p->friendly_name_p!=NULL)   
           {
             /* Atmaram - NvPair is used across all the modules. cli identifier, string enums used
             * only in cli. Use a local structure and copy additional data to display,
             * instead of using struct cm_nv_pair */

             in_nv_pair_array_p[array_index_i].nv_pairs[index_i].friendly_name_length = of_strlen(tmp_node_info_p->friendly_name_p);
             in_nv_pair_array_p[array_index_i].nv_pairs[index_i].friendly_name_p = (char*)of_calloc(1,of_strlen(tmp_node_info_p->friendly_name_p) + 1);
             of_strcpy(in_nv_pair_array_p[array_index_i].nv_pairs[index_i].friendly_name_p,tmp_node_info_p->friendly_name_p);
           }
           if(tmp_node_info_p->data_attrib.attrib_type == CM_DATA_ATTRIB_STR_ENUM)
           {
             while(cnt_ui < tmp_node_info_p->data_attrib.attr.string_enum.count_ui)
             {
               if (!strcmp(in_nv_pair_array_p[array_index_i].nv_pairs[index_i].value_p,
                     tmp_node_info_p->data_attrib.attr.string_enum.array[cnt_ui]))//Logic to get friendly names
               {
                 if(tmp_node_info_p->data_attrib.attr.string_enum.aFrdArr[cnt_ui] != NULL)
                 {
                   if(of_strlen(tmp_node_info_p->data_attrib.attr.string_enum.aFrdArr[cnt_ui])!=0)
                   {
                     temp_value_p = tmp_node_info_p->data_attrib.attr.string_enum.aFrdArr[cnt_ui];

                     in_nv_pair_array_p[array_index_i].nv_pairs[index_i].enum_val_len_ui = of_strlen(temp_value_p);
                     in_nv_pair_array_p[array_index_i].nv_pairs[index_i].enum_value_p = (char*)of_calloc(1,strlen(temp_value_p));
                     of_strcpy(in_nv_pair_array_p[array_index_i].nv_pairs[index_i].enum_value_p,temp_value_p);
                   }
                 }
                 break;
               }
               cnt_ui++;
             }
           }//if(tmp_node_info_p->data_attrib.attrib_type == CM_DATA_ATTRIB_STR_ENUM)
           break;
         }
       }
     }
     array_index_i++;
   }

   /* Atmaram - Memory Leak - Node Info and child info not freed 
      - Fixed Now
    */
   cm_cli_free_node_info(node_info_p);
   cm_cli_cleanup_array_of_node_info(child_info_arr_p);

   return OF_SUCCESS; 
}
#endif /* CM_CLIENG_SUPPORT */
